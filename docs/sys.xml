<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="C:\HaxeToolkit\haxe\std/Any.hx">
		<from><icast><d/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<meta><m n=":forward.variance"/></meta>
		<impl><class path="_Any.Any_Impl_" params="" file="C:\HaxeToolkit\haxe\std/Any.hx" private="1" module="Any" final="1">
	<__promote params="T" get="inline" set="null" line="37" static="1">
		<f a="this">
			<d/>
			<c path="__promote.T"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":to"/>
		</meta>
	</__promote>
	<toString get="inline" set="null" line="40" static="1">
		<f a="this">
			<d/>
			<c path="String"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</toString>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="_Any.Any_Impl_" params="" file="C:\HaxeToolkit\haxe\std/Any.hx" private="1" module="Any" final="1">
		<__promote params="T" get="inline" set="null" line="37" static="1">
			<f a="this">
				<d/>
				<c path="__promote.T"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":to"/>
			</meta>
		</__promote>
		<toString get="inline" set="null" line="40" static="1">
			<f a="this">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</toString>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="neko.Lib" params="" file="C:\HaxeToolkit\haxe\std/neko/Lib.hx">
		<load public="1" set="method" line="34" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Load and return a Neko primitive from a NDLL library.</haxe_doc>
		</load>
		<loadLazy public="1" set="method" line="38" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</loadLazy>
		<rethrow public="1" set="method" line="66" static="1">
			<f a="e">
				<d/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Rethrow an exception. This is useful when manually filtering an exception in order
		to keep the previous exception stack.</haxe_doc>
		</rethrow>
		<haxe_doc>Platform-specific Neko Library. Provides some platform-specific functions
	for the Neko target, such as conversion from Haxe types to native types
	and vice-versa.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Array" params="T" file="C:\HaxeToolkit\haxe\std/neko/_std/Array.hx" final="1">
		<new1 params="T" set="method" line="35" static="1"><f a="a:l">
	<c path="neko.NativeArray"><c path="new1.T"/></c>
	<x path="Int"/>
	<c path="Array"><c path="new1.T"/></c>
</f></new1>
		<__hx_toString_depth expr="0" line="92" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__hx_toString_depth>
		<__a><c path="neko.NativeArray"><c path="Array.T"/></c></__a>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method" line="42">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<copy public="1" set="method" line="53">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="57">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="Array.T"/></c></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="61">
			<f a=""><c path="haxe.iterators.ArrayKeyValueIterator"><c path="Array.T"/></c></f>
			<haxe_doc>Returns an iterator of the Array indices and values.</haxe_doc>
		</keyValueIterator>
		<insert public="1" set="method" line="65">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<join public="1" set="method" line="80">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<toString public="1" set="method" line="94">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<pop public="1" set="method" line="117">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method" line="126">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<unshift public="1" set="method" line="133">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<remove public="1" set="method" line="141">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<contains public="1" set="method" line="158">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether `this` Array contains `x`.

		If `x` is found by checking standard equality, the function returns `true`, otherwise
		the function returns `false`.</haxe_doc>
		</contains>
		<indexOf public="1" set="method" line="171">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method" line="188">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<reverse public="1" set="method" line="204">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method" line="218">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method" line="231">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method" line="249">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method" line="272">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<map public="1" params="S" get="inline" set="null" line="298">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" get="inline" set="null" line="307">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<resize public="1" set="method" line="315">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<__get set="method" line="327"><f a="pos">
	<x path="Int"/>
	<c path="Array.T"/>
</f></__get>
		<__set set="method" line="331"><f a="pos:v">
	<x path="Int"/>
	<c path="Array.T"/>
	<c path="Array.T"/>
</f></__set>
		<__grow set="method" line="352"><f a="l">
	<x path="Int"/>
	<x path="Void"/>
</f></__grow>
		<__neko set="method" line="368"><f a=""><c path="neko.NativeArray"><c path="Array.T"/></c></f></__neko>
		<new public="1" set="method" line="30">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="C:\HaxeToolkit\haxe\std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/Date.hx" final="1">
		<date_format expr="Lib.load(&quot;std&quot;, &quot;date_format&quot;, 2)" line="125" static="1">
			<f a=":">
				<d/>
				<x path="Null"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "date_format", 2)</e></m></meta>
		</date_format>
		<date_set_hour expr="Lib.load(&quot;std&quot;, &quot;date_set_hour&quot;, 4)" line="127" static="1">
			<f a=":::">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "date_set_hour", 4)</e></m></meta>
		</date_set_hour>
		<date_set_day expr="Lib.load(&quot;std&quot;, &quot;date_set_day&quot;, 4)" line="128" static="1">
			<f a=":::">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "date_set_day", 4)</e></m></meta>
		</date_set_day>
		<int32_to_float expr="Lib.load(&quot;std&quot;, &quot;int32_to_float&quot;, 1)" line="134" static="1">
			<f a="">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "int32_to_float", 1)</e></m></meta>
		</int32_to_float>
		<__string set="method" line="138" static="1">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
		</__string>
		<__t><d/></__t>
		<getTime public="1" set="method" line="33">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of `this` date.
		On cpp and neko, this function only has a second resolution, so the
		result will always be a multiple of `1000.0`, e.g. `1454698271000.0`.
		To obtain the current timestamp with better precision on cpp and neko,
		see the `Sys.time` API.

		For measuring time differences with millisecond accuracy on
		all platforms, see `haxe.Timer.stamp`.</haxe_doc>
		</getTime>
		<toString public="1" set="method" line="97">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Returns a string representation of `this` Date in the local timezone
		using the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for
		other formatting rules.</haxe_doc>
		</toString>
		<new public="1" set="method" line="28">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11 (note that this is zero-based)
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970 UTC.

	## Supported range

	Due to platform limitations, only dates in the range 1970 through 2038 are
	supported consistently. Some targets may support dates outside this range,
	depending on the OS at runtime. The `Date.fromTime` method will not work with
	timestamps outside the range on any target.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="EReg" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/EReg.hx" final="1">
		<regexp_new_options expr="neko.Lib.load(&quot;regexp&quot;, &quot;regexp_new_options&quot;, 2)" line="205" static="1">
			<f a=":">
				<d/>
				<d/>
				<d/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("regexp", "regexp_new_options", 2)</e></m></meta>
		</regexp_new_options>
		<regexp_match expr="neko.Lib.load(&quot;regexp&quot;, &quot;regexp_match&quot;, 4)" line="206" static="1">
			<f a=":::">
				<d/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("regexp", "regexp_match", 4)</e></m></meta>
		</regexp_match>
		<regexp_matched expr="neko.Lib.load(&quot;regexp&quot;, &quot;regexp_matched&quot;, 2)" line="207" static="1">
			<f a=":">
				<d/>
				<x path="Int"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("regexp", "regexp_matched", 2)</e></m></meta>
		</regexp_matched>
		<r><d/></r>
		<last><c path="String"/></last>
		<global><x path="Bool"/></global>
		<match public="1" set="method" line="35">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="44">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, the result is unspecified.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<new public="1" set="method" line="27">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="C:\HaxeToolkit\haxe\std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="C:\HaxeToolkit\haxe\std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="C:\HaxeToolkit\haxe\std/EnumValue.hx" private="1" module="EnumValue" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="IntIterator" params="" file="C:\HaxeToolkit\haxe\std/IntIterator.hx">
		<min><x path="Int"/></min>
		<max><x path="Int"/></max>
		<hasNext public="1" get="inline" set="null" line="53">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="62">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.

		If this is called while hasNext() is false, the result is unspecified.</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="45">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterates from `min` (inclusive) to `max` (exclusive).

		If `max <= min`, the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>IntIterator is used for implementing interval iterations.

	It is usually not used explicitly, but through its special syntax:
	`min...max`

	While it is possible to assign an instance of IntIterator to a variable or
	field, it is worth noting that IntIterator does not reset after being used
	in a for-loop. Subsequent uses of the same instance will then have no
	effect.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="Map" params="K:V" file="C:\HaxeToolkit\haxe\std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="C:\HaxeToolkit\haxe\std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="_Math.MathImpl" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/Math.hx" private="1" module="Math">
		<__rnd static="1"><d/></__rnd>
		<_rand_float expr="Lib.load(&quot;std&quot;, &quot;random_float&quot;, 1)" line="29" static="1">
			<f a="">
				<d/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "random_float", 1)</e></m></meta>
		</_rand_float>
		<_rand_int expr="Lib.load(&quot;std&quot;, &quot;random_int&quot;, 2)" line="30" static="1">
			<d/>
			<meta><m n=":value"><e>Lib.load("std", "random_int", 2)</e></m></meta>
		</_rand_int>
		<min public="1" set="method" line="32" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</min>
		<max public="1" set="method" line="36" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</max>
		<random public="1" set="method" line="40" static="1"><f a=""><x path="Float"/></f></random>
		<isNaN public="1" set="method" line="44" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</isNaN>
		<isFinite public="1" set="method" line="48" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</isFinite>
		<meta>
			<m n=":native"><e>"Math"</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="Math" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/Math.hx" extern="1" final="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, Ï€. `PI` is approximately `3.141592653589793`.</haxe_doc>
		</PI>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		`NaN` stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: `Math.sqrt(-1)`.

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.</haxe_doc>
		</NaN>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of `1.0 / 0.0`.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of `-1.0 / 0.0`.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		- If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		- If `v` is positive or `0`, the result is unchanged. Otherwise the result is `-v`.
		- If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		`exp(1.0)` is approximately `2.718281828459`.

		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<fround public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<ffloor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to `0.0`,
		and less than `1.0`.</haxe_doc>
		</random>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is `Math.NaN`.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, `null`, `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Reflect" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/Reflect.hx">
		<fields public="1" set="method" line="72" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Int" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Float" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="neko.Boot" params="" file="C:\HaxeToolkit\haxe\std/neko/Boot.hx">
		<__tmp_str set="method" line="28" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
		</__tmp_str>
		<__enum_str set="method" line="32" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__enum_str>
		<__interfLoop set="method" line="58" static="1"><f a="cc:cl">
	<d/>
	<d/>
	<x path="Bool"/>
</f></__interfLoop>
		<__instanceof set="method" line="74" static="1">
			<f a="o:cl">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":ifFeature"><e>"typed_catch"</e></m>
			</meta>
		</__instanceof>
		<__serialize set="method" line="95" static="1">
			<f a="o">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__serialize>
		<__tagserialize set="method" line="115" static="1">
			<f a="o">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__tagserialize>
		<__unserialize set="method" line="124" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__unserialize>
		<__init set="method" line="147" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</__init>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="Std" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/Std.hx">
		<is public="1" get="inline" set="null" line="25" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":ifFeature"><e>"typed_cast"</e></m>
				<m n=":deprecated"><e>"Std.is is deprecated. Use Std.isOfType instead."</e></m>
			</meta>
			<haxe_doc>DEPRECATED. Use `Std.isOfType(v, t)` instead.

		Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</is>
		<isOfType public="1" set="method" line="29" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</isOfType>
		<string public="1" set="method" line="42" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" line="46" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="53" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		`x` may optionally start with a + or - to denote a postive or negative value respectively.

		If the optional sign is followed 0x or 0X, hexadecimal notation is recognized where the following
		digits may contain 0-9 and A-F. Both the prefix and digits are case insensitive.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. Octal and binary
		notations are not supported.

		Parsing continues until an invalid character is detected, in which case the result up to
		that point is returned. Scientific notation is not supported. That is `Std.parseInt('10e2')` produces `10`.

		If `x` is `null`, the result is `null`.
		If `x` cannot be parsed as integer or is empty, the result is `null`.

		If `x` starts with a hexadecimal prefix which is not followed by at least one valid hexadecimal
		digit, the result is unspecified.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="65" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of `null`. Also, hexadecimal support is **not** specified.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.

		It may also end with `e` or `E` followed by optional minus or plus sign and a sequence of
		digits (defines exponent to base 10).</haxe_doc>
		</parseFloat>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Null" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/String.hx" final="1">
		<__is_String expr="true" line="23" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</__is_String>
		<__split expr="neko.Lib.load(&quot;std&quot;, &quot;string_split&quot;, 2)" line="24" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "string_split", 2)</e></m></meta>
		</__split>
		<fromCharCode public="1" set="method" line="216" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<charAt public="1" set="method" line="41">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method" line="53">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method" line="59">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`.

		If `startIndex` exceeds `this.length`, -1 is returned.

		If `startIndex` is negative, the result is unspecifed.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method" line="78">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `startIndex` is negative, the result is unspecifed.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method" line="95">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method" line="111">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method" line="142">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toLowerCase public="1" set="method" line="166">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method" line="182">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toString public="1" set="method" line="198">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<__compare set="method" line="203">
			<f a="o">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__compare>
		<__add set="method" line="207">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__add>
		<__radd set="method" line="211">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__radd>
		<new public="1" set="method" line="32">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="StringBuf" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/StringBuf.hx">
		<__make expr="neko.Lib.load(&quot;std&quot;, &quot;buffer_new&quot;, 0)" line="52" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "buffer_new", 0)</e></m></meta>
		</__make>
		<__add expr="neko.Lib.load(&quot;std&quot;, &quot;buffer_add&quot;, 2)" line="53" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "buffer_add", 2)</e></m></meta>
		</__add>
		<__add_char expr="neko.Lib.load(&quot;std&quot;, &quot;buffer_add_char&quot;, 2)" line="54" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "buffer_add_char", 2)</e></m></meta>
		</__add_char>
		<__to_string expr="neko.Lib.load(&quot;std&quot;, &quot;buffer_string&quot;, 1)" line="56" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "buffer_string", 1)</e></m></meta>
		</__to_string>
		<b><d/></b>
		<new public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="C:\HaxeToolkit\haxe\std/StringTools.hx">
		<isSpace public="1" set="method" line="282" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String `""`, or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="300" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="325" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="347" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for `ltrim(rtrim(s))`.</haxe_doc>
		</trim>
		<hex public="1" set="method" line="438" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its `length` equals `digits`.</haxe_doc>
		</hex>
		<_urlEncode expr="neko.Lib.load(&quot;std&quot;, &quot;url_encode&quot;, 1)" line="629" static="1">
			<f a="">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "url_encode", 1)</e></m></meta>
		</_urlEncode>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Sys" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/Sys.hx">
		<println public="1" set="method" line="30" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Prints any value to the standard output, followed by a newline.
		On Windows, this function outputs a CRLF newline.
		LF newlines are printed on all other platforms.</haxe_doc>
		</println>
		<time public="1" set="method" line="118" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value available (in seconds).</haxe_doc>
		</time>
		<sys_time expr="neko.Lib.load(&quot;std&quot;, &quot;sys_time&quot;, 0)" line="159" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_time", 0)</e></m></meta>
		</sys_time>
		<haxe_doc>This class provides access to various base functions of system platforms.
	Look in the `sys` package for more system APIs.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<enum path="ValueType" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="Type" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/Type.hx">
		<getClassName public="1" set="method" line="58" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="65" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<typeof public="1" set="method" line="174" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="UInt" params="" file="C:\HaxeToolkit\haxe\std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned `Int` type is only defined for Flash and C#.
	Simulate it for other platforms.

	@see https://haxe.org/manual/types-basic-types.html</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="_UInt.UInt_Impl_" params="" file="C:\HaxeToolkit\haxe\std/UInt.hx" private="1" module="UInt" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.CallStack" params="" file="C:\HaxeToolkit\haxe\std/haxe/CallStack.hx">
		<from><icast><c path="Array"><e path="haxe.StackItem"/></c></icast></from>
		<this><c path="Array"><e path="haxe.StackItem"/></c></this>
		<haxe_doc>Get information about the call stack.</haxe_doc>
		<meta>
			<m n=":allow"><e>haxe.Exception</e></m>
			<m n=":using"><e>haxe.CallStack</e></m>
		</meta>
		<impl><class path="haxe._CallStack.CallStack_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1"><meta>
	<m n=":keep"/>
	<m n=":using"><e>haxe.CallStack</e></m>
	<m n=":allow"><e>haxe.Exception</e></m>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Function" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.NotVoid" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with anything but `Void`.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.NotVoid_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints" interface="1">
		<get public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Null"><c path="haxe.IMap.V"/></x>
</f></get>
		<keys public="1" set="method"><f a=""><t path="Iterator"><c path="haxe.IMap.K"/></t></f></keys>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="sys.thread.EventLoop" params="" file="C:\HaxeToolkit\haxe\std/sys/thread/EventLoop.hx">
		<CREATED static="1"><x path="Bool"/></CREATED>
		<mutex final="1" expr="new Mutex()">
			<c path="sys.thread.Mutex"/>
			<meta><m n=":value"><e>new Mutex()</e></m></meta>
		</mutex>
		<oneTimeEvents final="1" expr="new Array&lt;Null&lt;Void -&gt; Void&gt;&gt;()">
			<c path="Array"><x path="Null"><f a=""><x path="Void"/></f></x></c>
			<meta><m n=":value"><e><![CDATA[new Array<Null<Void -> Void>>()]]></e></m></meta>
		</oneTimeEvents>
		<oneTimeEventsIdx expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</oneTimeEventsIdx>
		<waitLock final="1" expr="new Lock()">
			<c path="sys.thread.Lock"/>
			<meta><m n=":value"><e>new Lock()</e></m></meta>
		</waitLock>
		<promisedEventsCount expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</promisedEventsCount>
		<regularEvents><x path="Null"><c path="sys.thread._EventLoop.RegularEvent"/></x></regularEvents>
		<isMainThread><x path="Bool"/></isMainThread>
		<loop public="1" set="method" line="179">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Execute all pending events.
		Wait and execute as many events as the number of times `promise()` was called.
		Runs until all repeating events are cancelled and no more events are expected.

		Depending on a target platform this method may be non-reentrant. It must
		not be called from event callbacks.</haxe_doc>
		</loop>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<haxe_doc>An event loop implementation used for `sys.thread.Thread`</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.thread.Mutex" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/sys/thread/Mutex.hx">
		<mutex_create expr="neko.Lib.loadLazy(&quot;std&quot;, &quot;mutex_create&quot;, 0)" line="45" static="1">
			<f a=""><d/></f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("std", "mutex_create", 0)</e></m></meta>
		</mutex_create>
		<mutex_release expr="neko.Lib.loadLazy(&quot;std&quot;, &quot;mutex_release&quot;, 1)" line="46" static="1">
			<f a="">
				<d/>
				<d/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("std", "mutex_release", 1)</e></m></meta>
		</mutex_release>
		<mutex_acquire expr="neko.Lib.loadLazy(&quot;std&quot;, &quot;mutex_acquire&quot;, 1)" line="47" static="1">
			<f a="">
				<d/>
				<d/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("std", "mutex_acquire", 1)</e></m></meta>
		</mutex_acquire>
		<m><d/></m>
		<acquire public="1" set="method" line="33">
			<f a=""><x path="Void"/></f>
			<haxe_doc>The current thread acquire the mutex or wait if not available.
		The same thread can acquire several times the same mutex but
		must release it as many times it has been acquired.</haxe_doc>
		</acquire>
		<release public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Release a mutex that has been acquired by the current thread.
		The behavior is undefined if the current thread does not own
		the mutex.</haxe_doc>
		</release>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a mutex.</haxe_doc>
		</new>
		<haxe_doc>Creates a mutex, which can be used to acquire a temporary lock
	to access some ressource. The main difference with a lock is
	that a mutex must always be released by the owner thread.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.thread._Thread.HaxeThread" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread">
		<thread_create static="1"><f a="callb:_">
	<f a="_">
		<d/>
		<x path="Void"/>
	</f>
	<d/>
	<t path="sys.thread._Thread.ThreadHandle"/>
</f></thread_create>
		<thread_current static="1"><f a=""><t path="sys.thread._Thread.ThreadHandle"/></f></thread_current>
		<thread_send static="1"><f a="handle:msg">
	<t path="sys.thread._Thread.ThreadHandle"/>
	<d/>
	<x path="Void"/>
</f></thread_send>
		<thread_read_message static="1"><f a="block">
	<x path="Bool"/>
	<d/>
</f></thread_read_message>
		<mainThreadHandle static="1"><t path="sys.thread._Thread.ThreadHandle"/></mainThreadHandle>
		<mainThread static="1"><c path="sys.thread._Thread.HaxeThread"/></mainThread>
		<threads static="1"><c path="Array"><a>
	<thread><c path="sys.thread._Thread.HaxeThread"/></thread>
	<handle><t path="sys.thread._Thread.ThreadHandle"/></handle>
</a></c></threads>
		<threadsMutex static="1"><c path="sys.thread.Mutex"/></threadsMutex>
		<current public="1" set="method" line="102" static="1"><f a=""><c path="sys.thread._Thread.HaxeThread"/></f></current>
		<create public="1" set="method" line="123" static="1"><f a="callb:withEventLoop">
	<f a=""><x path="Void"/></f>
	<x path="Bool"/>
	<x path="sys.thread.Thread"/>
</f></create>
		<dropThread set="method" line="166" static="1"><f a="deleteItem">
	<a>
		<thread><c path="sys.thread._Thread.HaxeThread"/></thread>
		<handle><t path="sys.thread._Thread.ThreadHandle"/></handle>
	</a>
	<x path="Void"/>
</f></dropThread>
		<events public="1" set="null"><x path="Null"><c path="sys.thread.EventLoop"/></x></events>
		<handle public="1"><t path="sys.thread._Thread.ThreadHandle"/></handle>
		<new public="1" set="method" line="181"><f a="handle">
	<t path="sys.thread._Thread.ThreadHandle"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.EntryPoint" params="" file="C:\HaxeToolkit\haxe\std/haxe/EntryPoint.hx">
		<run public="1" set="method" line="126" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Start the main loop. Depending on the platform, this can return immediately or will only return when the application exits.</haxe_doc>
		</run>
		<haxe_doc>If `haxe.MainLoop` is kept from DCE, then we will insert an `haxe.EntryPoint.run()` call just at then end of `main()`.
	This class can be redefined by custom frameworks so they can handle their own main loop logic.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.EnumTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:

			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="138" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="149" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="163" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="175" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.Exception" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/haxe/Exception.hx">
		<caught set="method" line="17" static="1"><f a="value">
	<x path="Any"/>
	<c path="haxe.Exception"/>
</f></caught>
		<message public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>Exception message.</haxe_doc>
		</message>
		<__exceptionMessage>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__exceptionMessage>
		<__nativeStack>
			<x path="Any"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeStack>
		<__skipStack expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
			</meta>
		</__skipStack>
		<__nativeException>
			<x path="Any"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeException>
		<__previousException>
			<x path="Null"><c path="haxe.Exception"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__previousException>
		<toString public="1" set="method" line="55">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns exception message.</haxe_doc>
		</toString>
		<get_message set="method" line="75"><f a=""><c path="String"/></f></get_message>
		<new public="1" set="method" line="38">
			<f a="message:?previous:?native">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new Exception instance.

		The `previous` argument could be used for exception chaining.

		The `native` argument is for internal usage only.
		There is no need to provide `native` argument manually and no need to keep it
		upon extending `haxe.Exception` unless you know what you're doing.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Base class for exceptions.

	If this class (or derivatives) is used to catch an exception, then
	`haxe.CallStack.exceptionStack()` will not return a stack for the exception
	caught. Use `haxe.Exception.stack` property instead:
	```haxe
	try {
		throwSomething();
	} catch(e:Exception) {
		trace(e.stack);
	}
	```

	Custom exceptions should extend this class:
	```haxe
	class MyException extends haxe.Exception {}
	//...
	throw new MyException('terrible exception');
	```

	`haxe.Exception` is also a wildcard type to catch any exception:
	```haxe
	try {
		throw 'Catch me!';
	} catch(e:haxe.Exception) {
		trace(e.message); // Output: Catch me!
	}
	```

	To rethrow an exception just throw it again.
	Haxe will try to rethrow an original native exception whenever possible.
	```haxe
	try {
		var a:Array<Int> = null;
		a.push(1); // generates target-specific null-pointer exception
	} catch(e:haxe.Exception) {
		throw e; // rethrows native exception instead of haxe.Exception
	}
	```]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.Int32" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int32.hx" private="1" module="haxe.Int32" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int64.hx" private="1" module="haxe.Int64" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>This typedef will fool `@:coreApi` into thinking that we are using
	the same underlying type, even though it might be different on
	specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe._Int64.___Int64" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<high public="1"><x path="haxe.Int32"/></high>
		<low public="1"><x path="haxe.Int32"/></low>
		<new public="1" get="inline" set="null" line="473"><f a="high:low">
	<x path="haxe.Int32"/>
	<x path="haxe.Int32"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Log" params="" file="C:\HaxeToolkit\haxe\std/haxe/Log.hx">
		<formatOutput public="1" set="method" line="33" static="1">
			<f a="v:infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<c path="String"/>
			</f>
			<haxe_doc>Format the output of `trace` before printing it.</haxe_doc>
		</formatOutput>
		<trace public="1" set="dynamic" line="62" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:

			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.MainEvent" params="" file="C:\HaxeToolkit\haxe\std/haxe/MainLoop.hx" module="haxe.MainLoop">
		<f><f a=""><x path="Void"/></f></f>
		<prev><c path="haxe.MainEvent"/></prev>
		<next><c path="haxe.MainEvent"/></next>
		<isBlocking public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Tells if the event can lock the process from exiting (default:true)</haxe_doc>
		</isBlocking>
		<nextRun public="1" set="null"><x path="Float"/></nextRun>
		<priority public="1" set="null"><x path="Int"/></priority>
		<new set="method" line="22"><f a="f:p">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.MainLoop" params="" file="C:\HaxeToolkit\haxe\std/haxe/MainLoop.hx">
		<pending static="1"><c path="haxe.MainEvent"/></pending>
		<hasEvents public="1" set="method" line="71" static="1"><f a=""><x path="Bool"/></f></hasEvents>
		<sortEvents set="method" line="104" static="1"><f a=""><x path="Void"/></f></sortEvents>
		<tick set="method" line="169" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Run the pending events. Return the time for next event.</haxe_doc>
		</tick>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":access"><e>haxe.MainEvent</e></m>
		</meta>
	</class>
	<typedef path="haxe._NativeStackTrace.NativeTrace" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/haxe/NativeStackTrace.hx" private="1" module="haxe.NativeStackTrace"><a>
	<stack final="1" set="null"><d/></stack>
	<skip final="1" set="null"><x path="Int"/></skip>
</a></typedef>
	<class path="haxe.NativeStackTrace" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/haxe/NativeStackTrace.hx">
		<saveStack public="1" get="inline" set="null" line="17" static="1">
			<f a="exception">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":ifFeature"><e>"haxe.NativeStackTrace.exceptionStack"</e></m></meta>
		</saveStack>
		<exceptionStack public="1" set="method" line="24" static="1">
			<f a=""><t path="haxe._NativeStackTrace.NativeTrace"/></f>
			<meta><m n=":has_untyped"/></meta>
		</exceptionStack>
		<haxe_doc>Do not use manually.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\HaxeToolkit\haxe\std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>`PosInfos` is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	`(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<typedef path="haxe._Rest.NativeRest" params="T" file="C:\HaxeToolkit\haxe\std/haxe/Rest.hx" private="1" module="haxe.Rest"><c path="Array"><c path="haxe._Rest.NativeRest.T"/></c></typedef>
	<abstract path="haxe.Rest" params="T" file="C:\HaxeToolkit\haxe\std/haxe/Rest.hx">
		<from><icast field="of"><c path="Array"><c path="of.T"/></c></icast></from>
		<this><t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t></this>
		<to><icast field="toArray"><c path="Array"><c path="haxe.Rest.T"/></c></icast></to>
		<haxe_doc><![CDATA[A special type that represents a "rest" function argument.

	The special `...` syntax can be used for convenience and improved readability:

	```haxe
	function f(...rest:Int) {
		$type(rest); // haxe.Rest<Int>
	}

	f(1, 2, 3);

	final array = [1, 2, 3];
	f(...array);
	```

	Should be used as a type for the last argument of a method, indicating that
	an arbitrary number of arguments of the given type can be passed to that method.

	Allows to use array access by index to get values of rest arguments.
	If the index exceeds the amount of rest arguments passed, the result is unspecified.]]></haxe_doc>
		<meta><m n=":coreApi"/></meta>
		<impl><class path="haxe._Rest.Rest_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Rest.hx" private="1" module="haxe.Rest" final="1"><meta>
	<m n=":keep"/>
	<m n=":coreApi"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.Serializer" params="" file="C:\HaxeToolkit\haxe\std/haxe/Serializer.hx">
		<USE_CACHE public="1" expr="false" line="57" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set `USE_CACHE` to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of `Serializer` by
		setting their `useCache` field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" expr="false" line="69" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of `Serializer` by
		setting their `useEnumIndex` field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="71" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<run public="1" set="method" line="582" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serializes `v` and returns the String representation.

	This is a convenience function for creating a new instance of
	Serializer, serialize `v` into it and obtain the result through a call
	to `toString()`.</haxe_doc>
		</run>
		<base_encode expr="neko.Lib.load(&quot;std&quot;, &quot;base_encode&quot;, 2)" line="589" static="1">
			<f a=":">
				<t path="haxe.io.BytesData"/>
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "base_encode", 2)</e></m></meta>
		</base_encode>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See `USE_CACHE` for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See `USE_ENUM_INDEX` for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="118">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		https://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="154"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="174"><f a="v">
	<d/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="211"><f a="v">
	<a/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="229">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Serializes `v`.

	All haxe-defined values and objects with the exception of functions can
	be serialized. Serialization of external/native objects is not
	guaranteed to work.

	The values of `this.useCache` and `this.useEnumIndex` may affect
	serialization output.</haxe_doc>
		</serialize>
		<__getField get="inline" set="null" line="557"><f a="o:f">
	<d/>
	<c path="String"/>
	<d/>
</f></__getField>
		<new public="1" set="method" line="103">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each `Serializer` instance maintains its own cache if `this.useCache` is
		`true`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The Serializer class can be used to encode values and objects into a `String`,
	from which the `Unserializer` class can recreate the original representation.

	This class can be used in two ways:

	- create a `new Serializer()` instance, call its `serialize()` method with
		any argument and finally retrieve the String representation from
		`toString()`
	- call `Serializer.run()` to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/std-serialization-format.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ValueException" params="" file="C:\HaxeToolkit\haxe\std/haxe/ValueException.hx">
		<extends path="haxe.Exception"/>
		<value public="1" set="null">
			<x path="Any"/>
			<haxe_doc>Thrown value.</haxe_doc>
		</value>
		<new public="1" set="method" line="23"><f a="value:?previous:?native">
	<x path="Any"/>
	<c path="haxe.Exception"/>
	<x path="Any"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception containing arbitrary value.

	This class is automatically used for throwing values, which don't extend `haxe.Exception`
	or native exception type.
	For example:
	```haxe
	throw "Terrible error";
	```
	will be compiled to
	```haxe
	throw new ValueException("Terrible error");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Bytes" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="549" static="1">
			<f a="length">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a new `Bytes` instance with the given `length`. The values of the
		bytes are not initialized and may not be zero.</haxe_doc>
		</alloc>
		<ofString public="1" set="method" line="580" static="1">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the `Bytes` representation of the given `String`, using the
		specified encoding (UTF-8 by default).</haxe_doc>
		</ofString>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<blit public="1" set="method" line="90">
			<f a="pos:src:srcpos:len">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Copies `len` bytes from `src` into this instance.
		@param pos Zero-based location in `this` instance at which to start writing
			bytes.
		@param src Source `Bytes` instance from which to copy bytes.
		@param srcpos Zero-based location at `src` from which bytes will be copied.
		@param len Number of bytes to be copied.</haxe_doc>
		</blit>
		<fill public="1" set="method" line="132">
			<f a="pos:len:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets `len` consecutive bytes starting from index `pos` of `this` instance
		to `value`.</haxe_doc>
		</fill>
		<sub public="1" set="method" line="155">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a new `Bytes` instance that contains a copy of `len` bytes of
		`this` instance, starting at index `pos`.</haxe_doc>
		</sub>
		<setDouble public="1" set="method" line="292">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Stores the given IEEE double-precision value `v` at the given position
		`pos` in little-endian encoding. Result is unspecified if writing outside
		of bounds.</haxe_doc>
		</setDouble>
		<toString public="1" set="method" line="502">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a `String` representation of the bytes interpreted as UTF-8.</haxe_doc>
		</toString>
		<new set="method" line="34"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.ArraySort" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/ArraySort.hx">
		<sort public="1" params="T" set="method" line="42" static="1">
			<f a="a:cmp">
				<c path="Array"><c path="sort.T"/></c>
				<f a=":">
					<c path="sort.T"/>
					<c path="sort.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
		`cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
		negative Int if `x < y`.

		This operation modifies Array `a` in place.

		This operation is stable: The order of equal elements is preserved.

		If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec params="T" set="method" line="46" static="1"><f a="a:cmp:from:to">
	<c path="Array"><c path="rec.T"/></c>
	<f a=":">
		<c path="rec.T"/>
		<c path="rec.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge params="T" set="method" line="68" static="1"><f a="a:cmp:from:pivot:to:len1:len2">
	<c path="Array"><c path="doMerge.T"/></c>
	<f a=":">
		<c path="doMerge.T"/>
		<c path="doMerge.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate params="T" set="method" line="94" static="1"><f a="a:cmp:from:mid:to">
	<c path="Array"><c path="rotate.T"/></c>
	<f a=":">
		<c path="rotate.T"/>
		<c path="rotate.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd set="method" line="115" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper params="T" set="method" line="124" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="upper.T"/></c>
	<f a=":">
		<c path="upper.T"/>
		<c path="upper.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower params="T" set="method" line="139" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="lower.T"/></c>
	<f a=":">
		<c path="lower.T"/>
		<c path="lower.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap params="T" set="method" line="153" static="1"><f a="a:i:j">
	<c path="Array"><c path="swap.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<haxe_doc>ArraySort provides a stable implementation of merge sort through its `sort`
	method. It should be used instead of `Array.sort` in cases where the order
	of equal elements has to be retained on all targets.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<get_height public="1" get="inline" set="null" line="264"><f a=""><x path="Int"/></f></get_height>
		<new public="1" set="method" line="252">
			<f a="l:k:v:r:?h" v="::::-1">
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<c path="haxe.ds.TreeNode.K"/>
				<c path="haxe.ds.TreeNode.V"/>
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : -1 }</e></m></meta>
		</new>
		<haxe_doc>A tree node of `haxe.ds.BalancedTree`.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.IntMap" params="T" file="C:\HaxeToolkit\haxe\std/neko/_std/haxe/ds/IntMap.hx">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<h><d/></h>
		<get public="1" set="method" line="36">
			<f a="key">
				<x path="Int"/>
				<x path="Null"><c path="haxe.ds.IntMap.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<keys public="1" set="method" line="48">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.List" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/List.hx">
		<h><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></h>
		<q><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<push public="1" set="method" line="68">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<pop public="1" set="method" line="99">
			<f a=""><x path="Null"><c path="haxe.ds.List.T"/></x></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.

		The element is removed from `this` List.</haxe_doc>
		</pop>
		<clear public="1" set="method" line="123">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Empties `this` List.

		This function does not traverse the elements, but simply sets the
		internal references to null and `this.length` to 0.</haxe_doc>
		</clear>
		<new public="1" set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of element container objects
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole list content every time.

	@see https://haxe.org/manual/std-List.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="neko.NativeArray" params="T" file="C:\HaxeToolkit\haxe\std/neko/NativeArray.hx"><meta><m n=":keep"/></meta></class>
	<class path="haxe.ds._List.ListNode" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/List.hx" private="1" module="haxe.ds.List" extern="1">
		<extends path="neko.NativeArray"><d/></extends>
		<create public="1" params="T" get="inline" set="null" line="257" static="1">
			<f a="item:next">
				<c path="create.T"/>
				<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
				<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<item public="1" get="accessor" set="accessor"><c path="haxe.ds._List.ListNode.T"/></item>
		<next public="1" get="accessor" set="accessor"><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c></next>
		<get_item get="inline" set="null" line="250"><f a=""><c path="haxe.ds._List.ListNode.T"/></f></get_item>
		<set_item get="inline" set="null" line="252"><f a="v">
	<c path="haxe.ds._List.ListNode.T"/>
	<c path="haxe.ds._List.ListNode.T"/>
</f></set_item>
		<get_next get="inline" set="null" line="254"><f a=""><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c></f></get_next>
		<set_next get="inline" set="null" line="256"><f a="v">
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c>
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c>
</f></set_next>
	</class>
	<class path="haxe.ds._List.ListIterator" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/List.hx" private="1" module="haxe.ds.List">
		<head><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListIterator.T"/></c></head>
		<hasNext public="1" get="inline" set="null" line="284"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="288"><f a=""><c path="haxe.ds._List.ListIterator.T"/></f></next>
		<new public="1" get="inline" set="null" line="280"><f a="head">
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta>
			<m n=":transitive"/>
			<m n=":multiType"><e>@:followWithAbstracts K</e></m>
		</meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
	<_new public="1" set="method" static="1">
		<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
		<meta><m n=":noCompletion"/></meta>
		<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
	</_new>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.ds._Map.Map_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
		<_new public="1" set="method" static="1">
			<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
		</_new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="C:\HaxeToolkit\haxe\std/neko/_std/haxe/ds/ObjectMap.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<h><a/></h>
		<k><a/></k>
		<get public="1" set="method" line="54">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Null"><c path="haxe.ds.ObjectMap.V"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<keys public="1" set="method" line="68">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<new public="1" set="method" line="42">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="haxe.ds.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>keyValueIterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>contains</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="C:\HaxeToolkit\haxe\std/neko/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<h><d/></h>
		<get public="1" get="inline" set="null" line="36">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<keys public="1" set="method" line="48">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="neko.NativeArray"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector" final="1">
	<_new public="1" get="inline" set="null" line="64" static="1">
		<f a="length">
			<x path="Int"/>
			<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new Vector of length `length`.

		Initially `this` Vector contains `length` neutral elements:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
		<overloads><_new public="1" get="inline" set="null" line="96">
	<f a="length:defaultValue">
		<x path="Int"/>
		<c path="haxe.ds.Vector.T"/>
		<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
	</f>
	<meta>
		<m n=":has_untyped"/>
		<m n=":noCompletion"/>
	</meta>
	<haxe_doc>Creates a new Vector of length `length` filled with `defaultValue` elements.

		Can be faster than `new Vector(length)` for iteration on some targets for non-nullable elements.

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
</_new></overloads>
	</_new>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.ds._Vector.Vector_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector" final="1">
		<_new public="1" get="inline" set="null" line="64" static="1">
			<f a="length">
				<x path="Int"/>
				<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new Vector of length `length`.

		Initially `this` Vector contains `length` neutral elements:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
			<overloads><_new public="1" get="inline" set="null" line="96">
	<f a="length:defaultValue">
		<x path="Int"/>
		<c path="haxe.ds.Vector.T"/>
		<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
	</f>
	<meta>
		<m n=":has_untyped"/>
		<m n=":noCompletion"/>
	</meta>
	<haxe_doc>Creates a new Vector of length `length` filled with `defaultValue` elements.

		Can be faster than `new Vector(length)` for iteration on some targets for non-nullable elements.

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
</_new></overloads>
		</_new>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.extern.EitherType" params="T1:T2" file="C:\HaxeToolkit\haxe\std/haxe/extern/EitherType.hx">
		<from>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
		</to>
		<haxe_doc><![CDATA[An abstract type allowing values to be either of `T1` or `T2` type.
	Supports implicit casts from/to either types.

	It is useful for interfacing with external code on dynamic platforms
	such as JavaScript or Python.

	Otherwise, use of this type is discouraged.

	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe.io.ArrayBufferViewData" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/ArrayBufferView.hx" module="haxe.io.ArrayBufferView"><c path="haxe.io.ArrayBufferViewImpl"/></typedef>
	<abstract path="haxe.io.ArrayBufferView" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/ArrayBufferView.hx">
		<this><t path="haxe.io.ArrayBufferViewData"/></this>
		<impl><class path="haxe.io._ArrayBufferView.ArrayBufferView_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/ArrayBufferView.hx" private="1" module="haxe.io.ArrayBufferView" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe.io.BytesData" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/BytesData.hx"><c path="neko.NativeString"/></typedef>
	<enum path="haxe.io.Encoding" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Encoding.hx">
		<UTF8/>
		<RawNative><haxe_doc>Output the string the way the platform represent it in memory. This is the most efficient but is platform-specific</haxe_doc></RawNative>
		<haxe_doc>String binary encoding supported by Haxe I/O</haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="haxe.io.Error" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.io.FPHelper" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/FPHelper.hx">
		<_double_bytes expr="neko.Lib.load(&quot;std&quot;, &quot;double_bytes&quot;, 2)" line="118" static="1">
			<f a=":">
				<x path="Float"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "double_bytes", 2)</e></m></meta>
		</_double_bytes>
		<haxe_doc>Helper that converts between floating point and binary representation.
	Always works in low-endian encoding.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.Float32ArrayData" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Float32Array.hx" module="haxe.io.Float32Array"><t path="haxe.io.ArrayBufferViewData"/></typedef>
	<abstract path="haxe.io.Float32Array" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Float32Array.hx">
		<this><t path="haxe.io.Float32ArrayData"/></this>
		<impl><class path="haxe.io._Float32Array.Float32Array_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Float32Array.hx" private="1" module="haxe.io.Float32Array" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.iterators.ArrayIterator" params="T" file="C:\HaxeToolkit\haxe\std/haxe/iterators/ArrayIterator.hx">
		<array final="1"><c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c></array>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="44">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="52">
			<f a=""><c path="haxe.iterators.ArrayIterator.T"/></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35">
			<f a="array">
				<c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `ArrayIterator`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[This iterator is used only when `Array<T>` is passed to `Iterable<T>`]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.iterators.ArrayKeyValueIterator" params="T" file="C:\HaxeToolkit\haxe\std/haxe/iterators/ArrayKeyValueIterator.hx">
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<array><c path="Array"><c path="haxe.iterators.ArrayKeyValueIterator.T"/></c></array>
		<hasNext public="1" get="inline" set="null" line="34"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="38"><f a=""><a>
	<value><c path="haxe.iterators.ArrayKeyValueIterator.T"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new public="1" get="inline" set="null" line="30"><f a="array">
	<c path="Array"><c path="haxe.iterators.ArrayKeyValueIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":ifFeature">
				<e>"anon_read.keyValueIterator"</e>
				<e>"dynamic_read.keyValueIterator"</e>
			</m>
		</meta>
	</class>
	<class path="haxe.iterators.RestIterator" params="T" file="C:\HaxeToolkit\haxe\std/haxe/iterators/RestIterator.hx">
		<args final="1"><x path="haxe.Rest"><c path="haxe.iterators.RestIterator.T"/></x></args>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="12"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="16"><f a=""><c path="haxe.iterators.RestIterator.T"/></f></next>
		<new get="inline" set="null" line="8">
			<f a="args">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>haxe.Rest</e></m></meta>
		</new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="neko.NativeString" params="" file="C:\HaxeToolkit\haxe\std/neko/NativeString.hx"><meta><m n=":keep"/></meta></class>
	<abstract path="neko.vm.LoaderHandle" params="" file="C:\HaxeToolkit\haxe\std/neko/vm/Loader.hx" module="neko.vm.Loader">
		<this><x path="neko.vm.LoaderHandle"/></this>
		<haxe_doc>The Neko object that implements the loader.</haxe_doc>
		<meta>
			<m n=":callable"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="neko.vm.ModuleHandle" params="" file="C:\HaxeToolkit\haxe\std/neko/vm/Module.hx" module="neko.vm.Module">
		<this><x path="neko.vm.ModuleHandle"/></this>
		<haxe_doc>The abstract Neko module handle.</haxe_doc>
		<meta>
			<m n=":callable"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<typedef path="sys.FileStat" params="" file="C:\HaxeToolkit\haxe\std/sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>The user id for the file owner.</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>The size of the file, in bytes.</haxe_doc>
			</size>
			<rdev>
				<x path="Int"/>
				<haxe_doc>The device type on which stat resides (special files only).</haxe_doc>
			</rdev>
			<nlink>
				<x path="Int"/>
				<haxe_doc>The number of hard links to stat.</haxe_doc>
			</nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>The last modification time for the file.</haxe_doc>
			</mtime>
			<mode>
				<x path="Int"/>
				<haxe_doc>The permission bits of stat. The meaning of the bits is platform dependent.</haxe_doc>
			</mode>
			<ino>
				<x path="Int"/>
				<haxe_doc>The inode number for stat.</haxe_doc>
			</ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>The user group id for the file owner.</haxe_doc>
			</gid>
			<dev>
				<x path="Int"/>
				<haxe_doc>The device on which stat resides.</haxe_doc>
			</dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>The creation time for the file (not all file systems support this).</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>The last access time for the file (when enabled by the file system).</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File information, as given by `sys.FileSystem.stat`.</haxe_doc>
	</typedef>
	<abstract path="sys.thread.EventHandler" params="" file="C:\HaxeToolkit\haxe\std/sys/thread/EventLoop.hx" module="sys.thread.EventLoop">
		<from><icast><c path="sys.thread._EventLoop.RegularEvent"/></icast></from>
		<this><c path="sys.thread._EventLoop.RegularEvent"/></this>
		<to><icast><c path="sys.thread._EventLoop.RegularEvent"/></icast></to>
		<impl><class path="sys.thread._EventLoop.EventHandler_Impl_" params="" file="C:\HaxeToolkit\haxe\std/sys/thread/EventLoop.hx" private="1" module="sys.thread.EventLoop" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="sys.thread._EventLoop.RegularEvent" params="" file="C:\HaxeToolkit\haxe\std/sys/thread/EventLoop.hx" private="1" module="sys.thread.EventLoop">
		<nextRunTime public="1"><x path="Float"/></nextRunTime>
		<interval final="1" public="1"><x path="Float"/></interval>
		<run final="1" public="1"><f a=""><x path="Void"/></f></run>
		<next public="1"><x path="Null"><c path="sys.thread._EventLoop.RegularEvent"/></x></next>
		<cancelled public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</cancelled>
		<new public="1" set="method" line="286"><f a="run:nextRunTime:interval">
	<f a=""><x path="Void"/></f>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="sys.thread.Lock" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/sys/thread/Lock.hx">
		<lock_create expr="neko.Lib.load(&quot;std&quot;, &quot;lock_create&quot;, 0)" line="41" static="1">
			<f a=""><d/></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "lock_create", 0)</e></m></meta>
		</lock_create>
		<lock_wait expr="neko.Lib.load(&quot;std&quot;, &quot;lock_wait&quot;, 2)" line="43" static="1">
			<f a=":">
				<d/>
				<x path="Null"><x path="Float"/></x>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "lock_wait", 2)</e></m></meta>
		</lock_wait>
		<l><d/></l>
		<wait public="1" set="method" line="33">
			<f a="?timeout">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Waits for the lock to be released, or `timeout` (in seconds)
		to expire. Returns `true` if the lock is released and `false`
		if a time-out occurs.</haxe_doc>
		</wait>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Lock which is initially locked.</haxe_doc>
		</new>
		<haxe_doc>A Lock allows blocking execution until it has been unlocked. It keeps track
	of how often `release` has been called, and blocks exactly as many `wait`
	calls.

	The order of the `release` and `wait` calls is irrelevant. That is, a Lock
	can be released before anyone waits for it. In that case, the `wait` call
	will execute immediately.

	Usage example:

	```haxe
	var lock = new Lock();
	var elements = [1, 2, 3];
	for (element in elements) {
		// Create one thread per element
		new Thread(function() {
			trace(element);
			Sys.sleep(1);
			// Release once per thread = 3 times
			lock.release();
		});
	}
	for (_ in elements) {
		// Wait 3 times
		lock.wait();
	}
	trace("All threads finished");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="sys.thread._Thread.ThreadImpl" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread"><c path="sys.thread._Thread.HaxeThread"/></typedef>
	<abstract path="sys.thread.Thread" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/sys/thread/Thread.hx">
		<from><icast><t path="sys.thread._Thread.ThreadImpl"/></icast></from>
		<this><t path="sys.thread._Thread.ThreadImpl"/></this>
		<impl><class path="sys.thread._Thread.Thread_Impl_" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread" final="1">
	<processEvents set="method" line="62" static="1">
		<f a=""><x path="Void"/></f>
		<meta><m n=":keep"/></meta>
	</processEvents>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="sys.thread._Thread.Thread_Impl_" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread" final="1">
		<processEvents set="method" line="62" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</processEvents>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="sys.thread._Thread.NativeThreadHandle" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread">
		<this><x path="sys.thread._Thread.NativeThreadHandle"/></this>
		<meta>
			<m n=":callable"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<typedef path="sys.thread._Thread.ThreadHandle" params="" file="C:\HaxeToolkit\haxe\std/neko/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread"><x path="sys.thread._Thread.NativeThreadHandle"/></typedef>
	<class path="vision.Vision" params="" file="src/vision/Vision.hx">
		<combine public="1" set="method" line="70" static="1">
			<f a="image:?with:?percentage" v="::50">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ percentage : 50 }</e></m></meta>
			<haxe_doc>Combines two images by averaging out the values of each pixel's color channels, according to `percentage`.

		The images can be of different sizes. 
		
		| Original | Combined With Default |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-combine.png)|

		@param image The image to combine on. When this function returns, that image should be modified
		@param with The second image to combine with. That image is preserved throughout the function.
		@param percentage The ratio between the contributions of each pixel within the two images, from 0 to 100: a lower value will make the first image's pixels contribute more to the the final image, thus making that image more similar to the first image, and vice-versa.</haxe_doc>
		</combine>
		<grayscale public="1" set="method" line="98" static="1">
			<f a="image:?simpleGrayscale" v=":false">
				<x path="vision.ds.Image"/>
				<x path="Bool"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ simpleGrayscale : false }</e></m></meta>
			<haxe_doc><![CDATA[Grayscales an image, by averaging the color channels of each pixel.

		If for some reason, you want to get a lower quality grayscale, set `simpleGrayscale` to `true`.

		Example:

		| Original | `simpleGrayscale` | `!simpleGrayscale` default) |
		|---|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-grayscale.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-grayscale&vision_better_grayscale.png)|

		@param image The image to be grayscaled.
		@param simpleGrayscale When enabled, gets the gray by averaging pixel's color-channel values, instead of using a special ratio for more accurate grayscaling. Defaults to `false`.

		@return The grayscaled image.]]></haxe_doc>
		</grayscale>
		<invert public="1" set="method" line="128" static="1">
			<f a="image">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Inverts an image.

		Inversion is just flipping the values of each color channel - `0xFFFFFF` will turn into `0x000000`, `0xFF00FF` will turn into `0x00FF00`, etc.

		The math behind inversion is just subtracting the current value of the channel from `0xFF`:

		| Color | Process | Result|
		|:---:|:---:|:---:|
		|`0xFFFF00` |FF - FF = **`00`**, FF - FF = **`00`**, FF - 00 = **`FF`**| `0x0000FF` |
		|`0xB13FFF` |FF - B1 = **`E4`**, FF - 3F = **`C0`**, FF - FF = **`00`**| `0xE4C000` |

		Example:

		| Original | Inverted |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-invert.png)|

		@param image The image to be inverted.

		@return The inverted image.</haxe_doc>
		</invert>
		<sepia public="1" set="method" line="144" static="1">
			<f a="image:?strength" v=":0.25">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ strength : 0.25 }</e></m></meta>
			<haxe_doc>Makes an image look "old".

		Does so by interpolating each pixel with `Color.SEPIA`.

		| Original | `strength = 0.25` |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-sepia.png)|</haxe_doc>
		</sepia>
		<blackAndWhite public="1" set="method" line="165" static="1">
			<f a="image:?threshold" v=":128">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ threshold : 128 }</e></m></meta>
			<haxe_doc>Converts an image to COMPLETE black and white.

		It does so by taking the color channel with the highest value, and checking if that maximum surpasses `threshold`.

		| Original | `threshold = 128` |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-blackAndWhite.png)|

		@param image The image to be converted.
		@param threshold The threshold for converting to black and white: `threshold` is the maximum average of the three color components, that will still be considered black. `threshold` is a value between 0 and 255. The higher the value, the more "sensitive" the conversion. The default value is 128.

		@return The converted image.</haxe_doc>
		</blackAndWhite>
		<contrast public="1" set="method" line="187" static="1">
			<f a="image">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Gets a contrast-enhanced version of an image,
		with more exaggerated colors.

		| Original | Processed |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-contrast.png)|

		@param image The image to be contrasted.</haxe_doc>
		</contrast>
		<smooth public="1" set="method" line="209" static="1">
			<f a="image:?strength:?affectAlpha:?kernelRadius:?circularKernel:?iterations" v=":0.1:false:1:true:1">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ iterations : 1, circularKernel : true, kernelRadius : 1, affectAlpha : false, strength : 0.1 }</e></m></meta>
			<haxe_doc>Smooths out an image, by averaging the pixel values around each pixel, and
		interpolating it with the currently processed pixel.

		This is a lower quality, but faster alternative to `Vision.bilateralDenoise`.

		| Original | Processed |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-smooth.png)|

		@param image The image to be smoothed.
		@param strength The strength of the smoothing. Higher values will result in more smoothing. Ranges from 0 to 1. Default is `0.1`.
		@param affectAlpha If `true`, the alpha channel will be smoothed as well. Defaults to `false`.
		@param kernelRadius The radius of the smoothing kernel. Higher values will result in more smoothing. Default is `1`, which uses a 3x3 kernel.
		@param circularKernel If `true`, the kernel will be circular. If `false`, the kernel will be square.
		@param iterations The number of times the smoothing should be applied. Higher values will result in more smoothing. Default is `1`.
		@return The smoothed image. The given image is modified.</haxe_doc>
		</smooth>
		<pixelate public="1" set="method" line="248" static="1">
			<f a="image:?averagePixels:?pixelSize:?affectAlpha" v=":true:2:true">
				<x path="vision.ds.Image"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ affectAlpha : true, pixelSize : 2, averagePixels : true }</e></m></meta>
			<haxe_doc>"Pixel-art"ifies an image, by "skipping" every `pixelSize` pixels, and filling 
		in the missing space by either averaging out the remaining pixel and the 
		missing ones, or just using the original.

		| Original | Processed |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-pixelate.png)|

		@param image The image to pixelate
		@param averagePixels Whether to use pixel averaging to get resulting pixels, or just use the original, remaining pixel.
		@param pixelSize the new "pixel size"
		@param affectAlpha Whether this effect applies to the alpha channel of each pixel or not
		@return The given image, pixelated. The original image is modified.</haxe_doc>
		</pixelate>
		<posterize public="1" set="method" line="295" static="1">
			<f a="image:?bitsPerChannel:?affectAlpha" v=":4:true">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ affectAlpha : true, bitsPerChannel : 4 }</e></m></meta>
			<haxe_doc>"Posterizes" an image - reduces the amount of colors an image uses by reducing
		the amount of bits each color channel uses. Usually, a color is represented
		using 4 channels of 8 bits, resulting in an integer, containing the red, green, 
		blue and alpha channel. This functions reduces the amount of bits used by
		each channel for each pixel.
		
		| Original | Processed (16-bit colors, 4 bits per channel) |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-posterize.png)|

		@param image The image to be posterized.
		@param bitsPerChannel The number of bits per channel. Defaults to `4`. Ranges from `1` to `8`.
		@param affectAlpha If `true`, the alpha channel will be posterized as well. Defaults to `true`.</haxe_doc>
		</posterize>
		<sharpen public="1" set="method" line="323" static="1">
			<f a="image">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Returns a sharpened version of the provided image.

		When an image is sharpened. it's color differences are exaggerated. The more times
		the image is sharpened, the more "deepfried" it'll look.

		Example:

		| Original | Sharpened |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-sharpen.png)|

		@param image The image to be contrasted.
		@return The sharpened image. The original copy is not preserved.</haxe_doc>
		</sharpen>
		<deepfry public="1" set="method" line="341" static="1">
			<f a="image:?iterations" v=":2">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ iterations : 2 }</e></m></meta>
			<haxe_doc>Deepfries an image by running to through a sharpening filter `iterations` times.

		Example:

		| Original | `iterations = 1` | `iterations = 2` |
		|---|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After One Iteration](https://spacebubble-io.pages.dev/vision/docs/valve-sharpen.png)|![After Two Iterations](https://spacebubble-io.pages.dev/vision/docs/valve-deepfry.png)|

		The higher the value, the more deepfried the image will look.
		@param image The image to be deepfried.
		@param iterations The amount of times the image gets sharpened. default is `2`.
		@return The deepfried image. The original copy is not preserved.</haxe_doc>
		</deepfry>
		<vignette public="1" set="method" line="368" static="1">
			<f a="image:?strength:?intensity:?ratioDependent:?color" v=":0.2:1:false:Color.BLACK">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ color : Color.BLACK, ratioDependent : false, intensity : 1, strength : 0.2 }</e></m></meta>
			<haxe_doc>Applies a vignette effect to the image.
		
		Vignette is a visual effect that makes the edges of the image gradually become
		of a certain color, usually to draw attention to the center.

		| Original | `ratioDependent = true` | `ratioDependent = false` |
		|---|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-vignette%28ratioDependent%20=%20true%29.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-vignette%28ratioDependent%20=%20false%29.png)|
		
		@param image The image to apply vignette on
		@param strength in percentage, the amount of the image that has vignette, from the edge. Ranges from `0` to `1`. Defaults to `0.2`
		@param intensity Determines how quickly vignette sets in when a pixel is supposed to be affected. The higher the value, 
		the quicker it turns to the target color. The closer the value is to `0`, the slower it 
		turns into the target color, and the less effected the edges.
		@param ratioDependent DEtermines if the effect should always treat the image as a square, 
		and thus be circular (`false`) or if it should consider different dimensions, 
		and appear "elliptical" (`true`) 
		@param color The target color for the vignette effect
		@return the given image, with vignette applied. The original image is modified.</haxe_doc>
		</vignette>
		<fisheyeDistortion public="1" set="method" line="396" static="1">
			<f a="image:?strength" v=":1.5">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ strength : 1.5 }</e></m></meta>
			<haxe_doc>Applies a fish-eye effect to an image from it's center, with a given strength.

		| Original | `strength = 1` | `strength = 2` |
		|---|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-fisheyeDistortion%28strength%20=%201%29.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-fisheyeDistortion%28strength%20=%202%29.png)|


	    @param image The image to apply the distortion to
	    @param strength The "amount" of warping done to the image. A higher value means pixels closer to the center are more distorted.    @return Image
		@returns the image, with fish-eye effect. The original image is preserved.</haxe_doc>
		</fisheyeDistortion>
		<barrelDistortion public="1" set="method" line="441" static="1">
			<f a="image:?strength" v=":0.2">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ strength : 0.2 }</e></m></meta>
			<haxe_doc>Applies a perspective perception change, such that the pixels closer to the 
		center of the image appear closer, and pixels that are closer to the corners appear further.

		This causes a bulging effect on straight lines, as seen in the following graph image:  
		![barrel effect](https://upload.wikimedia.org/wikipedia/commons/thumb/6/63/Barrel_distortion.svg/100px-Barrel_distortion.svg.png)
		
		This shows the library's implementation in effect, with `strength = 0.2`:

		| Original | Processed|
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![Processed](https://spacebubble-io.pages.dev/vision/docs/valve-barrelDistortion.png)|

		@param image The image to distort
		@param strength The amount of distortion to apply. The higher the value the more distortion 
		there is. A negative value implies `Vision.pincushionDistortion`. 
		Values converging to 0 distort the image less and less. Default is `0.2`.
		@returns A distorted copy of the given image.</haxe_doc>
		</barrelDistortion>
		<pincushionDistortion public="1" set="method" line="486" static="1">
			<f a="image:?strength" v=":0.2">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ strength : 0.2 }</e></m></meta>
			<haxe_doc>Applies a perspective perception change, such that the pixels closer to the 
		center of the image appear further, and pixels that are closer to the corners appear closer, 
		similar to when taking an image of the inside of a spherical object.

		This causes an inward rounding effect on straight lines, as seen in the following graph image:  
		![pincushion effect](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/Pincushion_distortion.svg/100px-Pincushion_distortion.svg.png)
		
		This shows the library's implementation in effect, with `strength = 0.2`:

		| Original | Processed|
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![Processed](https://spacebubble-io.pages.dev/vision/docs/valve-pincushionDistortion.png)|

		@param image The image to distort
		@param strength The amount of distortion to apply. The higher the value, the more distortion 
		there is. A negative value implies `Vision.barrelDistortion`. 
		Values converging to 0 distort the image less and less. Default is `0.2`.
		@returns A distorted copy of the given image. The original image is preserved.</haxe_doc>
		</pincushionDistortion>
		<mustacheDistortion public="1" set="method" line="507" static="1">
			<f a="image:?amplitude" v=":0.2">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ amplitude : 0.2 }</e></m></meta>
			<haxe_doc><![CDATA[A combination of `Vision.barrelDistortion` & `Vision.pincushionDistortion`, where the former
		affects the portion closer to the center of the image, and the latter affects the edges:  
		![mustache effect](https://upload.wikimedia.org/wikipedia/commons/thumb/3/3c/Mustache_distortion.svg/100px-Mustache_distortion.svg.png)
	
		For reference, here are the two mentioned distortions, held in reference to this one:

		| Original | Barrel | Pincushion | Mustache |
		|---|---|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![Processed](https://spacebubble-io.pages.dev/vision/docs/valve-barrelDistortion.png)|![Processed](https://spacebubble-io.pages.dev/vision/docs/valve-pincushionDistortion.png)|![Processed](https://spacebubble-io.pages.dev/vision/docs/valve-mustacheDistortion.png)|
	
		@param image The image to distort
		@param strength The amount of distortion to apply. The higher the value, the more distortion 
		there is. A negative value flips the effect. 
		Values converging to 0 distort the image less and less. Default is `0.2`.
		@returns A distorted copy of the image. The original image is preserved.]]></haxe_doc>
		</mustacheDistortion>
		<dilate public="1" set="method" line="560" static="1">
			<f a="image:?dilationRadius:?colorImportanceOrder:?circularKernel" v=":2:RedGreenBlue:true">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="vision.ds.specifics.ColorImportanceOrder"/>
				<x path="Bool"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ circularKernel : true, colorImportanceOrder : RedGreenBlue, dilationRadius : 2 }</e></m></meta>
			<haxe_doc>Loops over the given image's pixels with a kernel, and replaces the center pixel of that kernel with the "maximum value" inside that kernel:

		**What does replacing with the maximum value mean?**

		Basically, if a nearby pixel is lighter than the current pixel, the current pixel is replaced with the lighter pixel.
		That check is applied to all neighboring pixels, resulting in each pixel's color being the lightest color in its surroundings. 
		
		**example:** an image being dilated with a 5x5 square kernel. you should see how each time the kernel moves, it picks the lightest colors inside of it, and continues.

		![example](https://upload.wikimedia.org/wikipedia/commons/thumb/7/70/Grayscale_Morphological_Dilation.gif/220px-Grayscale_Morphological_Dilation.gif)

		| Original | Dilated |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-dilate.png)|

		@param image The image to operate on.
		@param dilationRadius The radius of the kernel used for the dilation process. The radius does not include the center pixel, so a radius of `2` should give a `5x5` kernel. The higher this value, the further each pixel checks for a nearby lighter pixel.
		@param colorImportanceOrder Since there may be conflicts when calculating the difference in lightness between colors with similar values in different color channels (e.g. `0xFF0000` and `0x0000FF` - channel values are "similar", colors are not), this parameter is used to favor the given color channels. The default is `RedGreenBlue` - `red` is the most important, and is considered the "lightest", followed by green, and blue is considered the "darkest".
		@param circularKernel When enabled, the kernel used to loop over the pixels becomes circular instead of being a square. This results in a slight performance increase, and a massive quality increase. Turned on by default.
		@return The dilated image. The original copy is not preserved.</haxe_doc>
		</dilate>
		<erode public="1" set="method" line="598" static="1">
			<f a="image:?erosionRadius:?colorImportanceOrder:?circularKernel" v=":2:RedGreenBlue:true">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="vision.ds.specifics.ColorImportanceOrder"/>
				<x path="Bool"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ circularKernel : true, colorImportanceOrder : RedGreenBlue, erosionRadius : 2 }</e></m></meta>
			<haxe_doc>Loops over the given image's pixels with a kernel, and replaces the center pixel of that kernel with the "minimum value" inside that kernel:

		**What does replacing with the minimum value mean?**

		Basically, if a nearby pixel is darker than the current pixel, the current pixel is replaced with the darker pixel.
		That check is applied to all neighboring pixels, resulting in each pixel's color being the darkest color in its surroundings. 
		
		**example:** an image being eroded with a square 5x5 kernel. You should see how each time the kernel moves, it picks the darkest colors inside of it, and continues.

		![example](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b9/Grayscale_Morphological_Erosion.gif/220px-Grayscale_Morphological_Erosion.gif)

		| Original | Eroded |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-erode.png)|

		@param image The image to operate on.
		@param dilationRadius The radius of the kernel used for the erosion process. The radius does not include the center pixel, so a radius of `2` should give a `5x5` kernel. The higher this value, the further each pixel checks for a nearby darker pixel.
		@param colorImportanceOrder Since there may be conflicts when calculating the difference in darkness between colors with similar values in different color channels (e.g. `0xFF0000` and `0x0000FF` - channel values are "similar", colors are not), this parameter is used to favor the given color channels. The default is `RedGreenBlue` - `red` is the most important, and is considered the "darkest", followed by green, and blue is considered the "lightest".
		@param circularKernel When enabled, the kernel used to loop over the pixels becomes circular instead of being a square. This results in a slight performance increase, and a massive quality increase. Turned on by default.
		@return The eroded image. The original copy is not preserved.</haxe_doc>
		</erode>
		<saltAndPepperNoise public="1" set="method" line="629" static="1">
			<f a="image:?percentage" v=":25">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ percentage : 25 }</e></m></meta>
			<haxe_doc><![CDATA[Applies noise to an image, in a "salt & pepper" fashion:

		every `100 / percentage` pixels or so, a randomly generated mask bitmask is applied to the color, using **color interpolation**
		
		| Original | `percentage = 25` |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-saltAndPepperNoise.png)
		
		@param image The image to apply salt&pepper noise on.
		@param percentage How much of the image should be "corrupted", in percentages between 0 to 100 - 0 means no change, 100 means fully "corrupted". Default is 25.
		@return The noisy image. The original copy is not preserved.

		@see Color.interpolate()]]></haxe_doc>
		</saltAndPepperNoise>
		<dropOutNoise public="1" set="method" line="661" static="1">
			<f a="image:?percentage:?threshold" v=":5:128">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ threshold : 128, percentage : 5 }</e></m></meta>
			<haxe_doc><![CDATA[Applies noise to an image, in a "drop-out" fashion:

		every `100 / percentage` pixels or so, a pixel is set to either black or white, 
		depending on the pixel it replaces - a lighter pixel is replaced by black, 
		while a darker pixel is replaced by white.
		
		| Original | Processed |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-dropOutNoise.png)
		
		@param image The image to apply salt&pepper noise on
		@param percentage How much of the image should be "corrupted", in percentages between 0 to 100 - 0 means no change, 100 means fully "corrupted". Default is 5
		@return The noisy image. The original copy is not preserved.]]></haxe_doc>
		</dropOutNoise>
		<whiteNoise public="1" set="method" line="688" static="1">
			<f a="image:?percentage:?whiteNoiseRange" v=":25:RANGE_16">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="vision.ds.specifics.WhiteNoiseRange"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ whiteNoiseRange : RANGE_16, percentage : 25 }</e></m></meta>
			<haxe_doc><![CDATA[Applies white noise to an image. White noise is the "snow" screen you see on televisions when they pick up unwanted electric/radiated electromagnetic signals instead of the channels you want to watch.

		Instead of applying white noise every couple of pixels, white noise is sort of "combined" with the image, according to `percentage`:
		
		| Original | Processed |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-whiteNoise.png)
		
		@param image The image to apply salt&pepper noise on
		@param percentage How white-noisy the resulting image should be, or, the ratio between the contributions of each pixel from the original image and the white noise to the final image, from 0 to 100: a lower value will make the first image's pixels contribute more to the the final image, thus making the resulting image less noisy, and vice-versa.
		@param whiteNoiseRange The number of shades of gray used to generate the white noise. Shouldn't really effect performance, but you may want to change it to get a "higher/lower quality" white noise.
		@return The noisy image. The original copy is not preserved.]]></haxe_doc>
		</whiteNoise>
		<normalize public="1" set="method" line="729" static="1">
			<f a="image:?rangeStart:?rangeEnd" v=":0x00000000:0xFFFFFFFF">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ rangeEnd : 0xFFFFFFFF, rangeStart : 0x00000000 }</e></m></meta>
			<haxe_doc><![CDATA[Limits the range of colors on an image, by resizing the range of a given color channel, according to the values
		of `rangeStart`'s and `rangeEnd`'s color channels.
		
		### How Does this work?
		
		1. before calculating anything, you get the min & max values of each color channel from the two given colors.
		For example, if `rangeStart` is `0xFF05F243` and `rangeEnd` is `0x239A6262`, the min/max values of the `red` channel 
		will be set to (`0x05`, `0x9A`), the min/max values of the green channel will be set to (`0x62`, `0xF2`)...
		2. Loop over the pixels, and calculate the ratios between the the pixel's color channel's and the values (`0x00`, `0xFF`)
		3. Now, calculate the step between each color value of the new range, by dividing each channel's (`max` - `min`) by `255`. The
		default step between each color value is `1` by default (`(0xFF - 0x00) / 0xFF = 1`).
		4. Loop over the channels, and multiply their value by the value of the new `step` (for example, 4
		`newStep = (0x88 - 0x00) / 0xFF = 0.5`, `color.red = color.red * newStep`);
		5. enjoy your normalized image :)
		
		
		@param image The image to be normalized.
		@param rangeStart The start of the range of channels. By default, this value is `0x00000000`
		@param rangeEnd The end of the range of channels. By default, this value is `0xFFFFFFFF`
		@return The normalized image. The original copy is not preserved.]]></haxe_doc>
		</normalize>
		<limitColorRanges public="1" set="method" line="759" static="1">
			<f a="image:?rangeStart:?rangeEnd" v=":0x00000000:0xFFFFFFFF">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ rangeEnd : 0xFFFFFFFF, rangeStart : 0x00000000 }</e></m></meta>
			<haxe_doc>Limits the range of colors on an image, by limiting the range of a given color channel, according to the values
		of `rangeStart`'s and `rangeEnd`'s color channels.
		
		@param image The image to be li processed.
		@param rangeStart The start of the range of channels. By default, this value is `0x00000000`
		@param rangeEnd The end of the range of channels. By default, this value is `0xFFFFFFFF`
		@return The normalized image. The original copy is not preserved.</haxe_doc>
		</limitColorRanges>
		<replaceColorRanges public="1" set="method" line="780" static="1">
			<f a="image:?ranges">
				<x path="vision.ds.Image"/>
				<c path="Array"><a>
	<replacement><x path="vision.ds.Color"/></replacement>
	<rangeStart><x path="vision.ds.Color"/></rangeStart>
	<rangeEnd><x path="vision.ds.Color"/></rangeEnd>
</a></c>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc><![CDATA[Replaces the colors inside each range with the given color inside that range object:  
		```haxe
		[{rangeStart: 0x00000000, rangeEnd = 0x88888888, replacement: 0xFFFFFFFF}] 
		```
		will replace every pixel inside the given color range with the color `0xFFFFFFFF`
		
		@param image The image process.
		@param ranges array of color ranges & replacement colors.
		@return A processed version of the image. The original image is not preserved.]]></haxe_doc>
		</replaceColorRanges>
		<convolve public="1" set="method" line="823" static="1">
			<f a="image:?kernel" v=":Identity">
				<x path="vision.ds.Image"/>
				<x path="haxe.extern.EitherType">
					<e path="vision.ds.Kernel2D"/>
					<c path="Array"><c path="Array"><x path="Float"/></c></c>
				</x>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ kernel : Identity }</e></m></meta>
			<haxe_doc>manipulates the image's pixel data by passing the pixels' value through a kernel.

		This is useful for many things, such as simple blurring, sharpening, noise maps, and more that comes to mind :).

		There are a couple of preexisting matrices you can use, and also a custom tool to let you create your own kernels from scratch using enums.

		### How does this work?

		simply put, it takes each pixel, and multiples its surrounding pixels by the values you give the matrix.

		In the following demo, you can see how convolution works for the `Sharpen` matrix:

		![Sharpen Convolution](https://upload.wikimedia.org/wikipedia/commons/thumb/1/19/2D_Convolution_Animation.gif/220px-2D_Convolution_Animation.gif)

		1. multiply the current pixel's value by the value of the center of the matrix
		1. multiply the current pixel's immediate neighbors (vertical/horizontal) by the matching value on the matrix 
		(the pixel to the right of the current pixel will be multiplied by the value to the right of the center of the matrix)
		1. do the same thing with the other neighbors
		1. enjoy your convolved image :)

		@param image the image to be manipulated
		@param kernel the type/value of the kernel. can be: **`Identity`**, **`BoxBlur`**, **`RidgeDetection`**, **`Sharpen`**, **`UnsharpMasking`**, **`Assemble3x3`**, **`Assemble5x5`**,
		or just a matrix: both `convolve(image, BoxBlur)` and `convolve(image, [[1,1,1],[1,1,1],[1,1,1]])` are valid ways to represent a box blur.
		@return A convolved version of the image. The original image is not preserved.</haxe_doc>
		</convolve>
		<affineTransform public="1" set="method" line="919" static="1">
			<f a="image:?matrix:?expansionMode:?originPoint:?originMode" v="::RESIZE::CENTER">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.TransformationMatrix2D"/>
				<x path="vision.ds.specifics.ImageExpansionMode"/>
				<c path="vision.ds.Point2D"/>
				<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ originMode : CENTER, expansionMode : RESIZE }</e></m></meta>
			<haxe_doc>Manipulates the image's pixel data by applying the given transformation matrix - 
		a 3x3 "grid" used to Move the image's pixels from one position to another. 

		The given transformation matrix must be one that maps one parallel line to another. 
		The clearest indicator of this is an empty last row, aside from a `1` at the end.

		Differs from `Vision.convolve` in that it doesn't change the pixels color (like a `BoxBlur`, for example), but instead modifies the position of pixels within the image.  
		This makes it easy to rotate, scale or translate an image.

		A matrix can be a literal 2D array: `[[1, 0, 0], [0, 1, 0], [0, 0, 1]]`, an instance of `Array2D`, 
		an instance of `Matrix2D`, or one of our home-made matrices using the static properties on `Matrix2D` :).

		**Some things to note:**
		 - The matrix's size must be 3x3. If the matrix is not 3x3, an error will be thrown.
		 - Some transformations can move pixels outside of the image's original bounds 
		   (for example, rotation, translation)), so, depending on the value of `expandImageBounds`, the image may resize.
		 - If you want to know how the pixel position-manipulation is done, see `Matrix2D`'s documentation.

		Examples for some of the pre-made matrices:

		| Original | Shearing | Rotation | Rotation (`!expandImageBounds`) |
		|---|---|---|---| 
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![Sheared](https://spacebubble-io.pages.dev/vision/docs/valve-affineWarpShear.png)|![Rotated, expanded](https://spacebubble-io.pages.dev/vision/docs/valve-affineWarpRotate%28expandImageBounds%20=%20true%29.png)|![Rotated, original size](https://spacebubble-io.pages.dev/vision/docs/valve-affineWarpRotate%28expandImageBounds%20=%20false%29.png)|

		@param image The image to manipulate.
		@param matrix a transformation matrix to use when manipulating the image. expects a 3x3 matrix. any other size may throw an error.
		@param expansionMode how to expand the image if the matrix moves the image outside of its original bounds, or never reaches the original bounds. Defaults to `ImageExpansionMode.SAME_SIZE`.
		@param originPoint **OPTION 1**: the point in the image to use as the origin of the transformation matrix. Before a point is passed to the matrix, it's coordinates are incremented by this point, and after the matrix is applied, it's coordinates are decremented by this point. Useful for rotation transformations. Defaults to `(0, 0)`.
		@param originMode **OPTION 2**: To avoid code-bloat, you can provide a pre-made representation of the origin point, via `TransformationMatrixOrigination` enum. Defaults to `TransformationMatrixOrigination.TOP_LEFT`.
		@returns A new, manipulated image. The provided image remains unchanged.
		@throws MatrixMultiplicationError if the size of the given matrix is not 3x3.

		@see `Vision.convolve()` for color-manipulation matrices (or, kernels).
		@see `Vision.perspectiveWarp()` for "3d" manipulations.</haxe_doc>
		</affineTransform>
		<projectiveTransform public="1" set="method" line="995" static="1">
			<f a="image:?matrix:?expansionMode" v="::RESIZE">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.TransformationMatrix2D"/>
				<x path="vision.ds.specifics.ImageExpansionMode"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ expansionMode : RESIZE }</e></m></meta>
			<haxe_doc>Manipulates the image's pixel data by applying the given transformation matrix - 
		a 3x3 "grid" used to Move the image's pixels from one position to another. 

		Differs from `affineTransform()` in one, major way: while`affineTransform()` only supports two-dimensional, parallel-to-parallel transformations.
		`perspectiveWarp` supports transformations in all three dimensions.

		It also differs from `Vision.convolve` in that it doesn't change the pixels color (like a `BoxBlur`, for example), 
		but instead modifies the position of pixels within the image.

		A matrix can be a literal 2D array: `[[1, 0, 0], [0, 1, 0], [0, 0, 1]]`, an instance of `Array2D`, 
		an instance of `Matrix2D`, or one of our home-made matrices using the static properties on `Matrix2D` :).

		Examples for some of the pre-made matrices:

		| Original | Depth | Perspective | Rotation (`!expandImageBounds`) |
		|---|---|---|---| 
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![Sheared](https://spacebubble-io.pages.dev/vision/docs/valve-affineWarpShear.png)|![Rotated, expanded](https://spacebubble-io.pages.dev/vision/docs/valve-affineWarpRotate%28expandImageBounds%20=%20true%29.png)|![Rotated, original size](https://spacebubble-io.pages.dev/vision/docs/valve-affineWarpRotate%28expandImageBounds%20=%20false%29.png)|

		@param image The image to manipulate.
		@param matrix a transformation matrix to use when manipulating the image. expects a 3x3 matrix. any other size may throw an error.
		@param expansionMode How to expand the image's bounds when the resulting image after transformation changes dimensions. Defaults to `RESIZE`.</haxe_doc>
		</projectiveTransform>
		<nearestNeighborBlur public="1" set="method" line="1057" static="1">
			<f a="image:?iterations" v=":1">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ iterations : 1 }</e></m></meta>
			<haxe_doc>Uses an iterative, nearest-neighbor style algorithm to blur an image.

		The algorithm is very simple and quite fast, but also very sensitive 
		performance-wise. The maximum value recommended to use for the 
		`iterations` property is 100, altho you shouldn't really find yourself using more than `25`.

		Example:

		| Original | `iterations = 1` | `iterations = 4` |
		|---|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-nearestNeighborBlur%28iterations%20=%201%29.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-nearestNeighborBlur%28iterations%20=%204%29.png)|

		@param image The image to be blurred.
		@param iterations The number of times the algorithm will be run. The more iterations, the more blurry the image will be, and the higher the "blur range". **For example:** a value of 3 will produce a blur range of 3 pixels on each object.

		@return A blurred version of the image. The original image is not preserved.</haxe_doc>
		</nearestNeighborBlur>
		<gaussianBlur public="1" set="method" line="1084" static="1">
			<f a="image:?sigma:?kernelSize:?fast" v=":1:GaussianKernelSize.X5:false">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="vision.ds.gaussian.GaussianKernelSize"/>
				<x path="Bool"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ fast : false, kernelSize : GaussianKernelSize.X5, sigma : 1 }</e></m></meta>
			<haxe_doc><![CDATA[Uses the gaussian blur algorithm to blur an image.

		This algorithm works by creating a 5x5 (thats the default size) matrix, and then applying
		the gaussian distribution function to that matrix.

		That matrix will go over each pixel and decide it's color based on the values of 
		the pixels covered by the 5x5 matrix, and the [gaussian distribution function](https://en.wikipedia.org/wiki/Gaussian_function).

		You can modify the values of the matrix by passing a float to the `sigma` parameter.
		The higher the value of `sigma`, the blurrier the image:
		
		| Original | `sigma = 0.5` | `sigma = 1`| `sigma = 1`, `fast = true` | `sigma = 2` |
		|---|---|---|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-gaussianBlur%28sigma%20=%200.5%29.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-gaussianBlur%28sigma%20=%201%29.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-gaussianBlur%28sigma%20=%201%47%20fast%20=%20true%29.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-gaussianBlur%28sigma%20=%202%29.png)|

		@param image The image to be blurred.
		@param sigma The sigma value to use for the gaussian distribution on the kernel. a lower value will focus more on the center pixel, while a higher value will shift focus to the surrounding pixels more, effectively blurring it better.
		@param kernelSize The size of the kernel (`width` & `height`)
		@throws InvalidGaussianKernelSize if the kernel size is even, negative or `0`, this error is thrown.
		@return A blurred version of the image. The original image is not preserved.]]></haxe_doc>
		</gaussianBlur>
		<medianBlur public="1" set="method" line="1105" static="1">
			<f a="image:?kernelSize" v=":5">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ kernelSize : 5 }</e></m></meta>
			<haxe_doc><![CDATA[Applies a median filter to an image to reduce the amount of noise in that image.

		Median filter "blurs" the image by taking a pixel & its surrounding, 
		finding the median of that group, and setting the center pixel to that median.

		Example of the filter in action:

		| Original | `kernelSize = 5` | `kernelSize = 10` | `kernelSize = 15` |
		|---|---|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-medianBlur%28kernelRadius%20=%205%29.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-medianBlur%28kernelRadius%20=%2010%29.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-medianBlur%28kernelRadius%20=%2015%29.png)|

		@param image The image to apply median blurring to.
		@param kernelSize the width & height of the kernel in which we should search for the median. A radius of `9` will check in a `19x19` (`radius(9)` + `center(1)` + `radius(9)`) square around the center pixel.
		@return A filtered version of the image, using median blurring. The original image is not preserved.]]></haxe_doc>
		</medianBlur>
		<simpleLine2DDetection public="1" set="method" line="1128" static="1">
			<f a="image:?accuracy:?minLineLength:?speedToAccuracyRatio" v=":50:10:Medium_Intermediate">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="vision.ds.specifics.AlgorithmSettings"/>
				<c path="Array"><c path="vision.ds.Line2D"/></c>
			</f>
			<meta><m n=":value"><e>{ speedToAccuracyRatio : Medium_Intermediate, minLineLength : 10, accuracy : 50 }</e></m></meta>
			<haxe_doc>Uses a simple, partially recursive algorithm to detect line segments in an image.

		those lines can be partially incomplete, but they will be detected as lines.

		@param image The image to be line detected.
		@param accuracy When a line is detected, the algorithm checks how much of the line actually covers a  "line portion" of the image. `accuracy` is set to `50` by default - at least half of the line has to match with the image. To optimize for line count, `40` and below is recommended. Otherwise, `50` to `60` should be fine.
		@param minLineLength The minimum length of a line segment to be detected.
		@param speedToAccuracyRatio  If the algorithm is too slow/too inaccurate for you, you can change this setting.

		@return The line detected image.</haxe_doc>
		</simpleLine2DDetection>
		<sobelEdgeDiffOperator public="1" set="method" line="1188" static="1">
			<f a="image">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Applies the sobel filter to an image.

		The image doesn't have to get grayscaled before being passed 
		to this function.
		
		It is different from the `sobelEdgeDetection` function, since
		it doesn't try to threshold the resulting image to extract the strong edges,
		and leaves that information in. Example of this filter in action:

		| Original | After Filtering |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-sobelEdgeDiffOperator.png)|

		@param image The image to be operated on
		@return A new image, containing the gradients of the edges as whitened pixels.</haxe_doc>
		</sobelEdgeDiffOperator>
		<perwittEdgeDiffOperator public="1" set="method" line="1209" static="1">
			<f a="image">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Applies the perwitt filter to an image.
		
		The image doesn't have to get grayscaled before being passed 
		to this function.
		
		It is different from the `perwittEdgeDetection` function, since
		it doesn't try to threshold the resulting image to extract the strong edges,
		and leaves that information in. Example of this filter in action:
		
		| Original | After Filtering |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-perwittEdgeDiffOperator.png)|

		@param image The image to be operated on
		@return A new image, containing the gradients of the edges as whitened pixels.</haxe_doc>
		</perwittEdgeDiffOperator>
		<robertEdgeDiffOperator public="1" set="method" line="1231" static="1">
			<f a="image">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Applies the Robert's Cross operator to an image.
		
		The image doesn't have to get grayscaled before being passed 
		to this function.
		
		While being the one of the oldest forms of edge gradient operators (dates back to 1963!),
		Its one of the fastest, if not *the* fastest.

		It does have its caveats though: while generally being 2x faster, its *way* more sensitive to noise, and may produce a more "jagged" image.
		
		| Original | After Filtering |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-robertEdgeDiffOperator.png)|

		@param image The image to be operated on
		@return A new image, containing the gradients of the edges as whitened pixels.</haxe_doc>
		</robertEdgeDiffOperator>
		<laplacianEdgeDiffOperator public="1" set="method" line="1253" static="1">
			<f a="image:?filterPositive" v=":true">
				<x path="vision.ds.Image"/>
				<x path="Bool"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ filterPositive : true }</e></m></meta>
			<haxe_doc>Applies the laplacian filter to an image.
		
		The image doesn't have to get grayscaled before being passed 
		to this function.
		
		It is different from the `perwittEdgeDetection` function, since
		it doesn't try to threshold the resulting image to extract the strong edges,
		and leaves that information in. Example of this filter in action:
		
		| Original | After Filtering (Positive) | After Filtering (Negative) |
		|---|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-laplacianEdgeDiffOperator%28filterPositive%20=%20true%29.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-laplacianEdgeDiffOperator%28filterPositive%20=%20false%29.png)|

		@param image The image to be operated on
		@param filterPositive Which version of the laplacian filter should the function use: the negative (detects "outward" edges), or the positive (detects "inward" edges). Default is positive (`true`).
		@return A new image, containing the gradients of the edges as whitened pixels.</haxe_doc>
		</laplacianEdgeDiffOperator>
		<cannyEdgeDetection public="1" set="method" line="1279" static="1">
			<f a="image:?sigma:?kernelSize:?lowThreshold:?highThreshold" v=":1:X5:0.05:0.2">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="vision.ds.gaussian.GaussianKernelSize"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ highThreshold : 0.2, lowThreshold : 0.05, kernelSize : X5, sigma : 1 }</e></m></meta>
			<haxe_doc>Uses Canny's edge multi stage edge detection algorithm to detect edges in an image,
		while reducing noise.

		This algorithm works by first applying a gaussian blur to the image, and then
		applying more filters to differentiate between strong edges, weak edges and non-edges.

		Example:

		| Original | Edge Detected (default settings) |
		|---|:---:|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-cannyEdgeDetection.png)|

		@param image The image to be edge detected.
		@param sigma The sigma value to be used in the gaussian blur.
		@param kernelSize This is used for the second step of the canny edge detection - gaussian blur. Unless you want to improve performance, this should remain unchanged.
		@param lowThreshold The low threshold value to be used in the hysteresis thresholding.
		@param highThreshold The high threshold value to be used in the hysteresis thresholding.

		@throws InvalidGaussianKernelSize thrown if the `kernelSize` is negative/divisible by `2`.
		@return The edge detected image.</haxe_doc>
		</cannyEdgeDetection>
		<sobelEdgeDetection public="1" set="method" line="1309" static="1">
			<f a="image:?threshold" v=":500">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ threshold : 500 }</e></m></meta>
			<haxe_doc>Detects edges within an image.

		Edges are detected using the Sobel operator, going from left to right and top to bottom.

		To improve angle related errors with the sobel operator, Scharr's optimized version is used.

		There's no need to pre-process the image, just throw it on it and it will do the rest
		(ie. it doesn't need to be grayscaled/black and white):

		| Before | After |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-sobelEdgeDetection.png)|

		@param image The image to be processed.
		@param threshold The threshold for detecting edges. The lower the value, 
		the more pixels will be considered edges. Default is `500`

		@return The image with edges detected. This image is returned as a new, black and white image.</haxe_doc>
		</sobelEdgeDetection>
		<perwittEdgeDetection public="1" set="method" line="1331" static="1">
			<f a="image:?threshold" v=":100">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ threshold : 100 }</e></m></meta>
			<haxe_doc>Detects edges within an image.

		Edges are detected using the Perwitt operator, going from left to right and top to bottom.

		There's no need to pre-process the image, just throw it on it and it will do the rest
		(ie. it doesn't need to be grayscaled/black and white):

		| Before | After |
		|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-perwittEdgeDetection.png)|

		@param image The image to be processed.
		@param threshold The threshold for detecting edges. The lower the value, 
		the more pixels will be considered edges. Default is `100`

		@return The image with edges detected. This image is returned as a new, black and white image.</haxe_doc>
		</perwittEdgeDetection>
		<laplacianOfGaussianEdgeDetection public="1" set="method" line="1355" static="1">
			<f a="image:?threshold:?filterPositive:?sigma:?kernelSize" v=":2:true:1:X3">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="vision.ds.gaussian.GaussianKernelSize"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ kernelSize : X3, sigma : 1, filterPositive : true, threshold : 2 }</e></m></meta>
			<haxe_doc><![CDATA[Detects edges within an image, using a gaussian blur & the laplacian filter.

		This algorithm works a bit like a combination of canny & perwitt edge detection, by blurring the image first to remove noise, and then
		going over the image with a kernel. With the default settings. This algorithm is the fastest when working with smaller images.

		There's no need to pre-process the image, just throw it into the function it will do the rest
		(ie. the image doesn't need to be grayscale/black and white):

		| Original | After Filtering (Positive) | After Filtering (Negative) |
		|---|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-laplacianOfGaussianEdgeDetection%28filterPositive%20=%20true%29.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-laplacianOfGaussianEdgeDetection%28filterPositive%20=%20true%29.png)|

		@param image The image to be processed.
		@param threshold The threshold for detecting edges. The lower the value, the more pixels will be considered edges. Default is `5`.
		@param filterPositive Which version of the laplacian filter should the function use: the negative (detects "outward" edges), or the positive (detects "inward" edges). Default is positive (`true`).
		@param sigma The sigma value to use for the gaussian blur. A lower value will focus the kernel more on the center pixel, while a higher value will shift focus to the surrounding pixels more. **The higher the value, the blurrier the image.** Default is `1`.
		@param kernelSize The size of the kernel (`width` & `height`) - a kernel size of `7`/ will produce a `7x7` kernel. Default is `GaussianKernelSize.X3`.
		@return A new, black and white image, with white pixels being the detected edges.]]></haxe_doc>
		</laplacianOfGaussianEdgeDetection>
		<convolutionRidgeDetection public="1" set="method" line="1385" static="1">
			<f a="image:?normalizationRangeStart:?normalizationRangeEnd:?refine" v=":0xFF444444:0xFFBBBBBB:false">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ refine : false, normalizationRangeEnd : 0xFFBBBBBB, normalizationRangeStart : 0xFF444444 }</e></m></meta>
			<haxe_doc><![CDATA[Uses a fast, convolution-based method to detect ridges within an image.
		
		It does the detection by grayscaling & normalizing the image, and then
		convolving it with a ridge detection kernel.

		Useful as a fast alternative to other **edge** detection algorithms, since it usually
		produces the most accurate edge representation while being the fastest (`1.5x` faster than sobel & perwitt, 
		exponentially faster than canny (image size dependent)).  

		**Comparison:**
		  
		| Algorithm | Output | Time Complexity |
		|:---:|---|:---:|
		|None|![Perwitt Edge Detection](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)| - |
		|**`perwittEdgeDetection`**|![Perwitt Edge Detection](https://spacebubble-io.pages.dev/vision/docs/valve-perwittEdgeDetection.png)| `O(width*height)` |
		|**`sobelEdgeDetection`**|![Sobel Edge Detection](https://spacebubble-io.pages.dev/vision/docs/valve-sobelEdgeDetection.png)| `O(width*height)` |
		|**`cannyEdgeDetection`**|![Perwitt Edge Detection](https://spacebubble-io.pages.dev/vision/docs/valve-cannyEdgeDetection.png)| `O(width*height log(width* height))` |
		|**`convolutionRidgeDetection`**|![Perwitt Edge Detection](https://spacebubble-io.pages.dev/vision/docs/valve-convolutionRidgeDetection.png)| `O(width*height)` |

		@param image the image to be ridge detected on.
		@param normalizationRangeStart Optional, if you want to change the normalization range's start color. `0x44444444` by default.
		@param normalizationRangeEnd Optional, if you want to change the normalization range's end color `0xBBBBBBBB` by default.
		@param refine Appends an iterative pixel check to the algorithm, which removes isolated ridge pixels. `false` by default for performance reasons.
		@return The ridge-highlighted version of the image. **The original copy is preserved**.]]></haxe_doc>
		</convolutionRidgeDetection>
		<bilateralDenoise public="1" set="method" line="1419" static="1">
			<f a="image:?gaussianSigma:?intensitySigma" v=":0.8:50">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ intensitySigma : 50, gaussianSigma : 0.8 }</e></m></meta>
			<haxe_doc><![CDATA[Applies the Bilateral Filter to the given image.  
		The bilateral filter denoises an image by using a "blur", 
		similar to the gaussian blur, but it differs from the gaussian blur 
		by assigning different weights & intensities to different pixels, 
		depending on their color differences, and not only their positions.
	    

		| Original | Sharpened | Sharpened (Denoised) |
		|---|---|---|
		|![Before](https://spacebubble-io.pages.dev/vision/docs/valve-original.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-sharpen.png)|![After](https://spacebubble-io.pages.dev/vision/docs/valve-bilateralDenoise.png)|

		@param image The image to operate on.
		@param gaussianSigma The sigma to use when generating the gaussian kernel. This also decides the size of the kernel (The size of the kernel is always `Math.round(6 * gaussianSigma)`, and gets incremented if the resulting size is even)
		@param intensitySigma The intensity sigma decides how hard should the algorithm "try" to reduce the noise inside the image. A higher value causes a pixel that has vastly different color than it's surrounding to weigh much less, and pretty much get "ignored and overwritten". **tl;dr - a higher value reduces more noise, but may blur the image if too high.**]]></haxe_doc>
		</bilateralDenoise>
		<haxe_doc><![CDATA[The class where all image manipulation & computer vision functions are stored.

	If you're going to make extensive use of this class, it is recommended to use this as a static extension:

	```haxe
	using vision.Vision;
	```]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.algorithms.BilateralFilter" params="" file="src/vision/algorithms/BilateralFilter.hx">
		<filter public="1" set="method" line="17" static="1">
			<f a="image:distanceSigma:intensitySigma">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Applies bilateral filtering.

		@param image The image to work with
		@param distanceSigma The sigma values used to generate the gaussian kernel. the kernel's size is 6`distanceSigma`, since 3`distanceSigma` is the radius
		@param intensitySigma The sigma used to calculate the intensity vector
		@return Image</haxe_doc>
		</filter>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.algorithms.BilinearInterpolation" params="" file="src/vision/algorithms/BilinearInterpolation.hx">
		<interpolate public="1" set="method" line="10" static="1"><f a="image:width:height">
	<x path="vision.ds.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="vision.ds.Image"/>
</f></interpolate>
		<interpolateMissingPixels public="1" set="method" line="22" static="1"><f a="image:kernelRadiusX:kernelRadiusY:minX:minY">
	<x path="vision.ds.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="vision.ds.Image"/>
</f></interpolateMissingPixels>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.algorithms.Canny" params="" file="src/vision/algorithms/Canny.hx">
		<grayscale public="1" set="method" line="28" static="1"><f a="image">
	<x path="vision.ds.canny.CannyObject"/>
	<x path="vision.ds.canny.CannyObject"/>
</f></grayscale>
		<applyGaussian public="1" set="method" line="32" static="1"><f a="image:size:sigma">
	<x path="vision.ds.canny.CannyObject"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="vision.ds.canny.CannyObject"/>
</f></applyGaussian>
		<applySobelFilters public="1" set="method" line="36" static="1"><f a="image">
	<x path="vision.ds.canny.CannyObject"/>
	<x path="vision.ds.canny.CannyObject"/>
</f></applySobelFilters>
		<nonMaxSuppression public="1" set="method" line="40" static="1"><f a="image">
	<x path="vision.ds.canny.CannyObject"/>
	<x path="vision.ds.canny.CannyObject"/>
</f></nonMaxSuppression>
		<applyHysteresis public="1" set="method" line="71" static="1"><f a="image:highThreshold:lowThreshold">
	<x path="vision.ds.canny.CannyObject"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="vision.ds.canny.CannyObject"/>
</f></applyHysteresis>
		<getNeighbors set="method" line="108" static="1"><f a="kernelSize:x:y:image">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="vision.ds.Image"/>
	<c path="Array"><c path="Array"><x path="vision.ds.Color"/></c></c>
</f></getNeighbors>
		<haxe_doc>An implementation of the canny edge detection algorithm, 
	by [ShaharMS](https://www.github.com/ShaharMS).
	
	The Canny Edge Detection is a multi-stage edge 
	detection algorithm, utilizing blurring filters 
	and multi-level thresholding.
	
	This class contains function for all 5 stages:
	 
	- `grayscale()`
	- `applyGaussian()`
	- `applySobelFilters()`
	- `nonMaxSuppression()`
	- `applyHysteresis()`</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.algorithms.Cramer" params="" file="src/vision/algorithms/Cramer.hx">
		<solveVariablesFor public="1" set="method" line="56" static="1"><f a="coefficients:solutions">
	<x path="vision.ds.Matrix2D"/>
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
</f></solveVariablesFor>
		<haxe_doc>Solve a system of linear equations using Cramer's rule.

    A solution can be provided, as long as there as many variables as there are equations.  
    Variables are solved as such:

    given a system of `n` equations and `n` variables:
    ```txt
    Ax + By + Cz = D
    Ex + Fy + Gz = H
    Ix + Jy + Kz = L
    ```

    A matrix and a vector are constructed: 
     - A matrix for the coefficients of the variables across the equations:
    ```
    â”Œ           â”
    â”‚ A   B   C â”‚
    â”‚ E   F   G â”‚
    â”‚ I   J   K â”‚
    â””           â”˜
    ```
     - And a vector for their solutions:
    ```
    â”Œ   â”
    â”‚ D â”‚
    â”‚ H â”‚
    â”‚ L â”‚
    â””   â”˜
    ```

    According to Cramer's rule, given these components, 
    you can extract the values of the variables using the formula:
    
    ```txt
         det(Aâ‚™) 
    xâ‚™ = --------
         det(A)
    ```

     - xâ‚™ - the solution of the `n`th variable, from left to right
     - Aâ‚™ - the coefficients matrix, with it's `n`th column replaced with the solution vector 
     - A - the unchanged coefficients matrix.

    Made by [Shahar Marcus](https://www.github.com/ShaharMS)</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.algorithms.Gauss" params="" file="src/vision/algorithms/Gauss.hx">
		<create1x1Kernel public="1" set="method" line="14" static="1">
			<f a="sigma">
				<x path="Float"/>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<meta><m n=":deprecated"><e>"Gaussian.create1x1Kernel() is deprecated, use Gaussian.create2DKernelOfSize() instead"</e></m></meta>
		</create1x1Kernel>
		<create3x3Kernel public="1" set="method" line="19" static="1">
			<f a="sigma">
				<x path="Float"/>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<meta><m n=":deprecated"><e>"Gaussian.create3x3Kernel() is deprecated, use Gaussian.create2DKernelOfSize() instead"</e></m></meta>
		</create3x3Kernel>
		<create5x5Kernel public="1" set="method" line="44" static="1">
			<f a="sigma">
				<x path="Float"/>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<meta><m n=":deprecated"><e>"Gaussian.create5x5Kernel() is deprecated, use Gaussian.create2DKernelOfSize() instead"</e></m></meta>
		</create5x5Kernel>
		<create7x7Kernel public="1" set="method" line="69" static="1">
			<f a="sigma">
				<x path="Float"/>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<meta><m n=":deprecated"><e>"Gaussian.create7x7Kernel() is deprecated, use Gaussian.create2DKernelOfSize() instead"</e></m></meta>
		</create7x7Kernel>
		<create9x9Kernel public="1" set="method" line="94" static="1">
			<f a="sigma">
				<x path="Float"/>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<meta><m n=":deprecated"><e>"Gaussian.create9x9Kernel() is deprecated, use Gaussian.create2DKernelOfSize() instead"</e></m></meta>
		</create9x9Kernel>
		<createKernelOfSize public="1" set="method" line="118" static="1">
			<f a="size:sigma">
				<x path="Int"/>
				<x path="Int"/>
				<c path="vision.ds.Array2D"><x path="Float"/></c>
			</f>
			<meta><m n=":deprecated"><e>"Gaussian.createKernelOfSize() is deprecated. use Gaussian.create2DKernelOfSize() instead"</e></m></meta>
		</createKernelOfSize>
		<create2DKernelOfSize public="1" set="method" line="122" static="1"><f a="size:sigma">
	<x path="Int"/>
	<x path="Float"/>
	<c path="vision.ds.Array2D"><x path="Float"/></c>
</f></create2DKernelOfSize>
		<create1DKernelOfSize public="1" set="method" line="153" static="1"><f a="size:sigma">
	<x path="Int"/>
	<x path="Float"/>
	<c path="Array"><x path="Float"/></c>
</f></create1DKernelOfSize>
		<fastBlur public="1" set="method" line="175" static="1"><f a="image:size:sigma">
	<x path="vision.ds.Image"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="vision.ds.Image"/>
</f></fastBlur>
		<haxe_doc>* Gaussian kernel creation implementation, ported to Haxe by [Shahar Marcus](https://www.github.com/ShaharMS).</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.algorithms.GaussJordan" params="" file="src/vision/algorithms/GaussJordan.hx">
		<invert public="1" set="method" line="12" static="1">
			<f a="matrix">
				<x path="vision.ds.Matrix2D"/>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<haxe_doc>Finds the inverse of a matrix, or, in other words, find another matrix for which `matrix * inverse = IDENTITY_MATRIX`
	    @param matrix 
	    @return Matrix2D</haxe_doc>
		</invert>
		<createIdentityMatrix set="method" line="64" static="1"><f a="size">
	<x path="Int"/>
	<x path="vision.ds.Matrix2D"/>
</f></createIdentityMatrix>
		<augmentMatrix set="method" line="82" static="1"><f a="matrix:augmentation">
	<c path="Array"><c path="Array"><x path="Float"/></c></c>
	<c path="Array"><c path="Array"><x path="Float"/></c></c>
	<x path="vision.ds.Matrix2D"/>
</f></augmentMatrix>
		<swapRows set="method" line="92" static="1"><f a="matrix:row1:row2">
	<c path="Array"><c path="Array"><x path="Float"/></c></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapRows>
		<extractMatrix set="method" line="98" static="1"><f a="matrix:rows:columns">
	<x path="vision.ds.Matrix2D"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="vision.ds.Matrix2D"/>
</f></extractMatrix>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.algorithms.Harris" params="" file="src/vision/algorithms/Harris.hx">
		<generateHarrisCorners public="1" set="method" line="18" static="1"><f a="image:initialEdgeFilterType:k:windowSize:sigma">
	<x path="vision.ds.Image"/>
	<x path="vision.ds.specifics.EdgeFilterType"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<a>
		<responses><c path="vision.ds.Heatmap"/></responses>
		<corners><c path="vision.ds.Heatmap"/></corners>
	</a>
</f></generateHarrisCorners>
		<harrisResponseFunction public="1" set="method" line="71" static="1"><f a="matrix:k">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></harrisResponseFunction>
		<applyFilter public="1" set="method" line="75" static="1"><f a="image:type">
	<x path="vision.ds.Image"/>
	<x path="vision.ds.specifics.EdgeFilterType"/>
	<x path="vision.ds.Image"/>
</f></applyFilter>
		<getValueOfImageDerivativeAt public="1" set="method" line="94" static="1">
			<f a="image:x:y:?xDirection" v=":::true">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ xDirection : true }</e></m></meta>
			<haxe_doc>An integral part of the harris response function is the image's color change rate at a specific coordinate + some small value (in our case, `delta`).
		The rate of color change is the same thing as the slope of a function, hence the name of this function. The two match up well, since we only
		need the rate of change in either the `x` or `y` direction.

		
		@param image A gray scale image
		@param coordinate The coordinate of the pixel
		@param delta The small value to add to the coordinate. This can be optimized for more/less aggressive corner detection.
		@param xDirection Whether to use the x direction or the y direction, since we need both slopes represented (on the `x` and `y` axis)</haxe_doc>
		</getValueOfImageDerivativeAt>
		<averageUsingGaussianDistribution public="1" set="method" line="100" static="1">
			<f a="image:x:y:?kernelSize:?sigma" v=":::X3:1">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.gaussian.GaussianKernelSize"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ sigma : 1, kernelSize : X3 }</e></m></meta>
		</averageUsingGaussianDistribution>
	</class>
	<class path="vision.algorithms.Hough" params="" file="src/vision/algorithms/Hough.hx">
		<maxRho static="1"><x path="Int"/></maxRho>
		<generateHoughSpace public="1" set="method" line="17" static="1"><f a="image">
	<x path="vision.ds.Image"/>
	<x path="vision.ds.Image"/>
</f></generateHoughSpace>
		<extractLocalMaximas public="1" set="method" line="39" static="1"><f a="space">
	<x path="vision.ds.Image"/>
	<x path="vision.ds.Image"/>
</f></extractLocalMaximas>
		<threshold public="1" set="method" line="64" static="1"><f a="space:value">
	<x path="vision.ds.Image"/>
	<x path="Int"/>
	<x path="vision.ds.Image"/>
</f></threshold>
		<mapLines public="1" set="method" line="71" static="1"><f a="image:space">
	<x path="vision.ds.Image"/>
	<x path="vision.ds.Image"/>
	<x path="vision.ds.Image"/>
</f></mapLines>
	</class>
	<class path="vision.algorithms.Laplacian" params="" file="src/vision/algorithms/Laplacian.hx">
		<convolveWithLaplacianOperator public="1" set="method" line="10" static="1"><f a="image:positive">
	<x path="vision.ds.Image"/>
	<x path="Bool"/>
	<x path="vision.ds.Image"/>
</f></convolveWithLaplacianOperator>
		<laplacianOfGaussian public="1" set="method" line="31" static="1"><f a="image:kernelSize:sigma:threshold:positive">
	<x path="vision.ds.Image"/>
	<x path="vision.ds.gaussian.GaussianKernelSize"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="vision.ds.Image"/>
</f></laplacianOfGaussian>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.algorithms.PerspectiveWarp" params="" file="src/vision/algorithms/PerspectiveWarp.hx">
		<generateMatrix public="1" set="method" line="18" static="1"><f a="destinationPoints:sourcePoints">
	<c path="Array"><c path="vision.ds.Point2D"/></c>
	<c path="Array"><c path="vision.ds.Point2D"/></c>
	<x path="vision.ds.Matrix2D"/>
</f></generateMatrix>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.algorithms.Perwitt" params="" file="src/vision/algorithms/Perwitt.hx">
		<convolveWithPerwittOperator public="1" set="method" line="14" static="1"><f a="image">
	<x path="vision.ds.Image"/>
	<x path="vision.ds.Image"/>
</f></convolveWithPerwittOperator>
		<getNeighbors set="method" line="50" static="1"><f a="kernelSize:x:y:image">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="vision.ds.Image"/>
	<c path="Array"><c path="Array"><x path="vision.ds.Color"/></c></c>
</f></getNeighbors>
		<detectEdges public="1" set="method" line="85" static="1">
			<f a="image:threshold">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>What does this algorithm do?
		Basically, it takes 9 pixels chunks each time it performs a calculation, and tries to see how different the
		colors of the pixels from the left are from the right. for example, lets say this is the chunk:

			 0 ,  0 , 112
			 0 , 112, 112
			121, 112, 112

		With the naked eye, we can see that the pixels are very different from each other, and therefore, are edges.
		The way the algorithm knows it, is: its multiplying the left side by -1, the middle by 0 and the right by 1, 
		and then adding them together:

			 0  *-1 +  0  *-1 + 121 *-1 = -121 |
			 0  * 0 + 112 * 0 + 112 * 0 =   0  | + = 215
			112 * 1 + 112 * 1 + 112 * 1 =  336 |

		Now, if this value is greater than the threshold, then we declare it an edge. now, were gonna do the same thing
		for all chunks of the image, and from top to bottom too if needed.</haxe_doc>
		</detectEdges>
		<haxe_doc><![CDATA[* An implementation of both the perwitt operator & edge detection algorithms
 * by [Shahar Marcus](https://www.github.com/ShaharMS)]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.algorithms.Radix" params="" file="src/vision/algorithms/Radix.hx">
		<getMax params="T:Uint:Int64" set="method" line="34" static="1">
			<f a="array:?endIndex">
				<c path="Array"><c path="getMax.T"/></c>
				<x path="Int"/>
				<c path="getMax.T"/>
			</f>
			<haxe_doc>* Gets the maximum in array `array`.
	 * @param array an array of type `Int`, `Int64` or `UInt`
	 * @param endIndex optional, an index after which we stop checking for a maximum 
	 * (useful if the range in which the maximum value is present is known)</haxe_doc>
		</getMax>
		<countingSort params="T:Uint:Int64" set="method" line="52" static="1">
			<f a="array:exp:?endIndex">
				<c path="Array"><c path="countingSort.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="countingSort.T"/></c>
			</f>
			<haxe_doc>* Does a counting sort on `array` according to the digit's placement represented by `exp`
	 * @param array an array of type `Int`, `Int64` or `UInt`
	 * @param exp Represents the digit's "place" on which were going to count - `10` will count on the last digit, `100` will count on the second-to-last, etc.
	 * @param endIndex optional, an index after which we stop sorting</haxe_doc>
		</countingSort>
		<sort public="1" params="T:Uint:Int64" set="method" line="91" static="1">
			<f a="main">
				<c path="Array"><c path="sort.T"/></c>
				<c path="Array"><c path="sort.T"/></c>
			</f>
			<haxe_doc>Sorts an array of `Int`s / `UInt`s / `Int64` using **Radix Sort**.</haxe_doc>
		</sort>
		<haxe_doc>An implementation of radix sort in Haxe, by [Shahar Marcus](https://www.github.com/ShaharMS).

	Radix vs. ArraySort.sort:

	|Radix                                 | ArraySort.sort                |
	|:------------------------------------:|:-----------------------------:|
	|length: 38, time: 0.000s              | length: 38, time: 0.000s      |
	|length: 74, time: 0.000s              | length: 74, time: 0.000s      |
	|length: 146, time: 0.001s             | length: 146, time: 0.001s     |
	|length: 290, time: 0.001s             | length: 290, time: 0.002s     |
	|length: 578, time: 0.003s             | length: 578, time: 0.003s     |
	|length: 1154, time: 0.005s            | length: 1154, time: 0.006s    |
	|length: 2306, time: 0.01s             | length: 2306, time: 0.012s    |
	|length: 4610, time: 0.02s             | length: 4610, time: 0.022s    |
	|length: 9218, time: 0.0591s           | length: 9218, time: 0.048s    |
	|length: 18434, time: 0.0701s          | length: 18434, time: 0.0961s  |
	|length: 36866, time: 0.1614s          | length: 36866, time: 0.1882s  |
	|length: 73730, time: 0.3123s          | length: 73730, time: 0.3856s  |
	|length: 147458, time: 0.5837s         | length: 147458, time: 0.7417s |
	|length: 294914, time: 1.1621s         | length: 294914, time: 1.6143s |
	|length: 589826, time: 2.3471s         | length: 589826, time: 3.0588s |
	|length: 1179650, time: 4.7839s        | length: 1179650, time: 6.1441s|</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.algorithms.RobertsCross" params="" file="src/vision/algorithms/RobertsCross.hx">
		<convolveWithRobertsCross public="1" set="method" line="16" static="1"><f a="image">
	<x path="vision.ds.Image"/>
	<x path="vision.ds.Image"/>
</f></convolveWithRobertsCross>
		<haxe_doc>An Implementation of the `Robert's Cross` operator, by [Shahar Marcus](https://www.github.com/ShaharMS).

    `Robert's Cross` is one of the first edge detection operators, first proposed in 1963 by Lawrence Roberts.

    The idea behind the Roberts cross operator is to approximate the gradient of an edge inside an image by
    computing the sum of the squares of the differences between diagonally adjacent pixels.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.algorithms.SimpleHough" params="" file="src/vision/algorithms/SimpleHough.hx">
		<detectLines public="1" set="method" line="9" static="1"><f a="image:threshold">
	<x path="vision.ds.Image"/>
	<x path="Int"/>
	<c path="Array"><c path="vision.ds.Ray2D"/></c>
</f></detectLines>
		<mapLines public="1" set="method" line="37" static="1"><f a="image:rays">
	<x path="vision.ds.Image"/>
	<c path="Array"><c path="vision.ds.Ray2D"/></c>
	<x path="vision.ds.Image"/>
</f></mapLines>
	</class>
	<class path="vision.algorithms.SimpleLineDetector" params="" file="src/vision/algorithms/SimpleLineDetector.hx">
		<image public="1" static="1"><x path="vision.ds.Image"/></image>
		<findLineFromPoint public="1" set="method" line="16" static="1">
			<f a="image:point:minLineLength:?preferTTB:?preferRTL" v=":::false:false">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Int16Point2D"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="vision.ds.Line2D"/>
			</f>
			<meta><m n=":value"><e>{ preferRTL : false, preferTTB : false }</e></m></meta>
		</findLineFromPoint>
		<lineCoveragePercentage public="1" set="method" line="63" static="1">
			<f a="image:line">
				<x path="vision.ds.Image"/>
				<c path="vision.ds.Line2D"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the percentage of the line that covers an actual line in the given,
		**Black And White** image.</haxe_doc>
		</lineCoveragePercentage>
		<correctLines public="1" set="method" line="105" static="1">
			<f a="lines:?distanceThreshold:?degError" v=":3:7">
				<c path="Array"><c path="vision.ds.Line2D"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><c path="vision.ds.Line2D"/></c>
			</f>
			<meta><m n=":value"><e>{ degError : 7, distanceThreshold : 3 }</e></m></meta>
		</correctLines>
		<p get="inline" set="null" line="181" static="1">
			<f a="?x:?y" v="0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Int16Point2D"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</p>
		<new public="1" set="method" line="185"><f a="image">
	<x path="vision.ds.Image"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* An iterative, partially recursive line detection implementation by [Shahar Marcus](https://www.github.com/ShaharMS).</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.algorithms.Sobel" params="" file="src/vision/algorithms/Sobel.hx">
		<convolveWithSobelOperator public="1" set="method" line="14" static="1"><f a="image">
	<x path="vision.ds.Image"/>
	<x path="vision.ds.Image"/>
</f></convolveWithSobelOperator>
		<detectEdges public="1" set="method" line="71" static="1">
			<f a="image:threshold">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>What does this algorithm do?
		Basically, it takes 9 pixels chunks each time it performs a calculation, and tries to see how different the
		colors of the pixels from the left are from the right. for example, lets say this is the chunk:

			 0 ,  0 , 112
			 0 , 112, 112
			121, 112, 112

		With the naked eye, we can see that the pixels are very different from each other, and therefore, are edges.
		The way the algorithm knows it, is: its multiplying the left side by -1, the middle by 0 and the right by 1.
		Then, it multiplies each edge by 10 and each corner by 3, 
		and then adding them together:

			 0  *-3 +  0  *-10 + 121 *-3 = -363  |
			 0  * 0 + 112 * 0 + 112 * 0 =   0    | + = 1483
			112 * 3 + 112 * 10 + 112 * 3 =  1846 |

		If this value is greater than the threshold, then we declare it an edge. now, were gonna do the same thing
		for all chunks of the image, and from top to bottom too if needed.</haxe_doc>
		</detectEdges>
		<haxe_doc><![CDATA[An implementation of both the sobel operator & edge detection algorithms
	by [Shahar Marcus](https://www.github.com/ShaharMS)]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.ds.Array2D" params="T" file="src/vision/ds/Array2D.hx">
		<inner public="1">
			<c path="Array"><c path="vision.ds.Array2D.T"/></c>
			<haxe_doc><![CDATA[The underlying `Array<T>` instance that holds the data.]]></haxe_doc>
		</inner>
		<width public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>The 2D array's width.</haxe_doc>
		</width>
		<height public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>The 2D array's height.</haxe_doc>
		</height>
		<length public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>The amount of elements in this `Array2D`.</haxe_doc>
		</length>
		<get public="1" get="inline" set="null" line="66">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<c path="vision.ds.Array2D.T"/>
			</f>
			<haxe_doc>Gets the element at column `x`, row `y`</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="73">
			<f a="x:y:val">
				<x path="Int"/>
				<x path="Int"/>
				<c path="vision.ds.Array2D.T"/>
				<c path="vision.ds.Array2D.T"/>
			</f>
			<haxe_doc>Sets the element at column `x`, row `y`</haxe_doc>
		</set>
		<setMultiple public="1" get="inline" set="null" line="82">
			<f a="points:val">
				<c path="Array"><x path="vision.ds.IntPoint2D"/></c>
				<c path="vision.ds.Array2D.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets multiple elements at multiple positions, at the same time
		@param points the indices at which to set
		@param val the value to set</haxe_doc>
		</setMultiple>
		<row public="1" get="inline" set="null" line="91">
			<f a="y">
				<x path="Int"/>
				<c path="Array"><c path="vision.ds.Array2D.T"/></c>
			</f>
			<haxe_doc>returns the entire row at position `y`</haxe_doc>
		</row>
		<column public="1" get="inline" set="null" line="98">
			<f a="x">
				<x path="Int"/>
				<c path="Array"><c path="vision.ds.Array2D.T"/></c>
			</f>
			<haxe_doc>returns the entire coluumn at position `x`</haxe_doc>
		</column>
		<iterator public="1" get="inline" set="null" line="109">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="vision.ds.Array2D.T"/></c></f>
			<haxe_doc><![CDATA[Returns an array iterator for this `Array2D`.

		Values are iterated on from left to right, top to bottom, for example (array of width 5, height 5):

		`(x, y)...(x + 5, y) -> (x, y + 1)...(x + 5, y + 1) -> (x, y + 2)...`]]></haxe_doc>
		</iterator>
		<fill public="1" get="inline" set="null" line="118">
			<f a="value">
				<c path="vision.ds.Array2D.T"/>
				<c path="vision.ds.Array2D"><c path="vision.ds.Array2D.T"/></c>
			</f>
			<haxe_doc>Fills the entire array with the provided value
		@param value the value to fill the array with
		@return this, filled `Array2D`</haxe_doc>
		</fill>
		<clone public="1" get="inline" set="null" line="128">
			<f a=""><c path="vision.ds.Array2D"><c path="vision.ds.Array2D.T"/></c></f>
			<haxe_doc>Clones this `Array2D`
		@return A new `Array2D`, similar to this one.</haxe_doc>
		</clone>
		<toString public="1" get="inline" set="null" line="137">
			<f a=""><c path="String"/></f>
			<haxe_doc>Gets a string representation of this `Array2D`@:noCompletion</haxe_doc>
		</toString>
		<get_length get="inline" set="null" line="158">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_length>
		<set_length get="inline" set="null" line="162">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_length>
		<set_width get="inline" set="null" line="167">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_width>
		<set_height get="inline" set="null" line="172">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_height>
		<get_item get="inline" set="null" line="177">
			<f a="index">
				<c path="Array"><x path="Int"/></c>
				<c path="vision.ds.Array2D.T"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>[]</e></m>
			</meta>
		</get_item>
		<set_item get="inline" set="null" line="181">
			<f a="index:value">
				<c path="Array"><x path="Int"/></c>
				<c path="vision.ds.Array2D.T"/>
				<c path="vision.ds.Array2D.T"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>[]</e></m>
			</meta>
		</set_item>
		<to2DArray public="1" set="method" line="185">
			<f a=""><c path="Array"><c path="Array"><c path="vision.ds.Array2D.T"/></c></c></f>
			<meta><m n=":to"/></meta>
		</to2DArray>
		<new public="1" get="inline" set="null" line="51">
			<f a="width:height:?fillWith">
				<x path="Int"/>
				<x path="Int"/>
				<c path="vision.ds.Array2D.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new `Array2D` instance. The created array can be filled in with non-null values. 
		if null is given, or no value is provided, the behavior is target-dependent:    

		 - on dynamic targets, values are always `null`
		 - on static targets, `0`, `0.0` or `false` are filled in for `Int`, `Float` and `Bool` respectively. Other types are filled in with `null`

		@param width The array's width
		@param height The array's height
		@param fillWith Optional, A custom value of type `T` to fill the created array with. If `fillWith` is not provided, the created array will contain the default values specified above.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[A 2D array, faster than an `Array<Array<T>>`.]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="vision.ds.ByteArray" params="" file="src/vision/ds/ByteArray.hx">
		<from><icast><c path="haxe.io.Bytes"/></icast></from>
		<this><c path="haxe.io.Bytes"/></this>
		<to><icast><c path="haxe.io.Bytes"/></icast></to>
		<haxe_doc>An abstract over `haxe.io.Bytes`, allows array access, and adds a bunch of utility functions.</haxe_doc>
		<meta><m n=":forward"/></meta>
		<impl><class path="vision.ds._ByteArray.ByteArray_Impl_" params="" file="src/vision/ds/ByteArray.hx" private="1" module="vision.ds.ByteArray" final="1">
	<from public="1" get="inline" set="null" line="20" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="vision.ds.ByteArray"/>
		</f>
		<haxe_doc>Generates a byte array of length 4, containing `value`.  
        The value is stored in little-endian format.
        @param value The given integer
        @return The resulting `ByteArray`</haxe_doc>
		<overloads>
			<from public="1" get="inline" set="null" line="62">
				<f a="value">
					<d/>
					<x path="vision.ds.ByteArray"/>
				</f>
				<haxe_doc>Uses `haxe.io.Serializer` to stringify the given value, then encodes it into a byte array
        using `UTF-8` encoding.
        @param value The given object
        @return The resulting `ByteArray`</haxe_doc>
			</from>
			<from public="1" get="inline" set="null" line="52">
				<f a="value:?encoding">
					<c path="String"/>
					<e path="haxe.io.Encoding"/>
					<x path="vision.ds.ByteArray"/>
				</f>
				<haxe_doc>Encodes the given string into a byte array. `UTF-8` encoding is used by default.
        If you want to use another type of encoding, provide the second parameter.
        @param value The given string
        @return The resulting `ByteArray`</haxe_doc>
			</from>
			<from public="1" get="inline" set="null" line="42">
				<f a="value">
					<x path="Bool"/>
					<x path="vision.ds.ByteArray"/>
				</f>
				<haxe_doc>If `value` is `true`, generates a byte array of length 1, containing 1.  
        If `value` is `false`, generates a byte array of length 1, containing 0.</haxe_doc>
			</from>
			<from public="1" get="inline" set="null" line="32">
				<f a="value">
					<x path="Float"/>
					<x path="vision.ds.ByteArray"/>
				</f>
				<haxe_doc>Generates a byte array of length 8, containing `value`.
        The value is stored in little-endian format.
        @param value The given float
        @return The resulting `ByteArray`</haxe_doc>
			</from>
		</overloads>
	</from>
	<read get="inline" set="null" line="69" static="1">
		<f a="this:index">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
		<haxe_doc>Reads a byte at the specified index</haxe_doc>
	</read>
	<write get="inline" set="null" line="76" static="1">
		<f a="this:index:value">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
		<haxe_doc>Writes a byte at the specified index</haxe_doc>
	</write>
	<setUInt8 public="1" get="inline" set="null" line="83" static="1">
		<f a="this:pos:v">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Writes an unsigned, 8-bit integer at the specified index</haxe_doc>
	</setUInt8>
	<getUInt8 public="1" get="inline" set="null" line="90" static="1">
		<f a="this:pos">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<haxe_doc>Reads an unsigned, 8-bit integer at the specified index</haxe_doc>
	</getUInt8>
	<setUInt32 public="1" get="inline" set="null" line="97" static="1">
		<f a="this:pos:value">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Writes an unsigned, 32-bit integer at the specified index</haxe_doc>
	</setUInt32>
	<getUInt32 public="1" get="inline" set="null" line="101" static="1"><f a="this:pos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getUInt32>
	<setInt8 public="1" get="inline" set="null" line="108" static="1">
		<f a="this:pos:v">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Writes a signed, 8-bit integer at the specified index</haxe_doc>
	</setInt8>
	<getInt8 public="1" get="inline" set="null" line="115" static="1">
		<f a="this:pos">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<haxe_doc>Reads a signed, 8-bit integer at the specified index</haxe_doc>
	</getInt8>
	<setBytes public="1" get="inline" set="null" line="123" static="1">
		<f a="this:pos:array">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="vision.ds.ByteArray"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Writes an array of bytes at the specified index</haxe_doc>
	</setBytes>
	<getBytes public="1" get="inline" set="null" line="130" static="1">
		<f a="this:pos:length">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.ByteArray"/>
		</f>
		<haxe_doc>Reads an array of bytes at the specified index</haxe_doc>
	</getBytes>
	<_new public="1" get="inline" set="null" line="139" static="1">
		<f a="length:?fillWith" v=":0">
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.ByteArray"/>
		</f>
		<meta>
			<m n=":value"><e>{ fillWith : 0 }</e></m>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new `ByteArray`. Values are set to `fillWith`, which defaults to `0`.</haxe_doc>
	</_new>
	<resize public="1" get="inline" set="null" line="149" static="1">
		<f a="this:length">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Resizes the array
        
        @param length the new length</haxe_doc>
	</resize>
	<concat public="1" get="inline" set="null" line="161" static="1">
		<f a="this:array">
			<c path="haxe.io.Bytes"/>
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.ByteArray"/>
		</f>
		<haxe_doc>Concatenates a byte array to this one. **Pay Attention** - 
	    
        @param array the array to concatenate.
	    @return a new `ByteArray`.</haxe_doc>
	</concat>
	<isEmpty public="1" set="method" line="173" static="1">
		<f a="this">
			<c path="haxe.io.Bytes"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Checks if this `ByteArray` is empty, i.e. all bytes are 0.

        @return true if empty, false otherwise</haxe_doc>
	</isEmpty>
	<toArray public="1" get="inline" set="null" line="183" static="1">
		<f a="this">
			<c path="haxe.io.Bytes"/>
			<c path="Array"><x path="Int"/></c>
		</f>
		<haxe_doc>Turns this `ByteArray` into an array of ints, from -255 to 255</haxe_doc>
	</toArray>
</class></impl>
	</abstract>
	<class path="vision.ds._ByteArray.ByteArray_Impl_" params="" file="src/vision/ds/ByteArray.hx" private="1" module="vision.ds.ByteArray" final="1">
		<from public="1" get="inline" set="null" line="20" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="vision.ds.ByteArray"/>
			</f>
			<haxe_doc>Generates a byte array of length 4, containing `value`.  
        The value is stored in little-endian format.
        @param value The given integer
        @return The resulting `ByteArray`</haxe_doc>
			<overloads>
				<from public="1" get="inline" set="null" line="62">
					<f a="value">
						<d/>
						<x path="vision.ds.ByteArray"/>
					</f>
					<haxe_doc>Uses `haxe.io.Serializer` to stringify the given value, then encodes it into a byte array
        using `UTF-8` encoding.
        @param value The given object
        @return The resulting `ByteArray`</haxe_doc>
				</from>
				<from public="1" get="inline" set="null" line="52">
					<f a="value:?encoding">
						<c path="String"/>
						<e path="haxe.io.Encoding"/>
						<x path="vision.ds.ByteArray"/>
					</f>
					<haxe_doc>Encodes the given string into a byte array. `UTF-8` encoding is used by default.
        If you want to use another type of encoding, provide the second parameter.
        @param value The given string
        @return The resulting `ByteArray`</haxe_doc>
				</from>
				<from public="1" get="inline" set="null" line="42">
					<f a="value">
						<x path="Bool"/>
						<x path="vision.ds.ByteArray"/>
					</f>
					<haxe_doc>If `value` is `true`, generates a byte array of length 1, containing 1.  
        If `value` is `false`, generates a byte array of length 1, containing 0.</haxe_doc>
				</from>
				<from public="1" get="inline" set="null" line="32">
					<f a="value">
						<x path="Float"/>
						<x path="vision.ds.ByteArray"/>
					</f>
					<haxe_doc>Generates a byte array of length 8, containing `value`.
        The value is stored in little-endian format.
        @param value The given float
        @return The resulting `ByteArray`</haxe_doc>
				</from>
			</overloads>
		</from>
		<read get="inline" set="null" line="69" static="1">
			<f a="this:index">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
			<haxe_doc>Reads a byte at the specified index</haxe_doc>
		</read>
		<write get="inline" set="null" line="76" static="1">
			<f a="this:index:value">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
			<haxe_doc>Writes a byte at the specified index</haxe_doc>
		</write>
		<setUInt8 public="1" get="inline" set="null" line="83" static="1">
			<f a="this:pos:v">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes an unsigned, 8-bit integer at the specified index</haxe_doc>
		</setUInt8>
		<getUInt8 public="1" get="inline" set="null" line="90" static="1">
			<f a="this:pos">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads an unsigned, 8-bit integer at the specified index</haxe_doc>
		</getUInt8>
		<setUInt32 public="1" get="inline" set="null" line="97" static="1">
			<f a="this:pos:value">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes an unsigned, 32-bit integer at the specified index</haxe_doc>
		</setUInt32>
		<getUInt32 public="1" get="inline" set="null" line="101" static="1"><f a="this:pos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getUInt32>
		<setInt8 public="1" get="inline" set="null" line="108" static="1">
			<f a="this:pos:v">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes a signed, 8-bit integer at the specified index</haxe_doc>
		</setInt8>
		<getInt8 public="1" get="inline" set="null" line="115" static="1">
			<f a="this:pos">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads a signed, 8-bit integer at the specified index</haxe_doc>
		</getInt8>
		<setBytes public="1" get="inline" set="null" line="123" static="1">
			<f a="this:pos:array">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="vision.ds.ByteArray"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes an array of bytes at the specified index</haxe_doc>
		</setBytes>
		<getBytes public="1" get="inline" set="null" line="130" static="1">
			<f a="this:pos:length">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.ByteArray"/>
			</f>
			<haxe_doc>Reads an array of bytes at the specified index</haxe_doc>
		</getBytes>
		<_new public="1" get="inline" set="null" line="139" static="1">
			<f a="length:?fillWith" v=":0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.ByteArray"/>
			</f>
			<meta>
				<m n=":value"><e>{ fillWith : 0 }</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new `ByteArray`. Values are set to `fillWith`, which defaults to `0`.</haxe_doc>
		</_new>
		<resize public="1" get="inline" set="null" line="149" static="1">
			<f a="this:length">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Resizes the array
        
        @param length the new length</haxe_doc>
		</resize>
		<concat public="1" get="inline" set="null" line="161" static="1">
			<f a="this:array">
				<c path="haxe.io.Bytes"/>
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.ByteArray"/>
			</f>
			<haxe_doc>Concatenates a byte array to this one. **Pay Attention** - 
	    
        @param array the array to concatenate.
	    @return a new `ByteArray`.</haxe_doc>
		</concat>
		<isEmpty public="1" set="method" line="173" static="1">
			<f a="this">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks if this `ByteArray` is empty, i.e. all bytes are 0.

        @return true if empty, false otherwise</haxe_doc>
		</isEmpty>
		<toArray public="1" get="inline" set="null" line="183" static="1">
			<f a="this">
				<c path="haxe.io.Bytes"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>Turns this `ByteArray` into an array of ints, from -255 to 255</haxe_doc>
		</toArray>
	</class>
	<abstract path="vision.ds.Color" params="" file="src/vision/ds/Color.hx">
		<from>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
		</to>
		<impl><class path="vision.ds._Color.Color_Impl_" params="" file="src/vision/ds/Color.hx" private="1" module="vision.ds.Color" final="1">
	<TRANSPARENT public="1" get="inline" set="null" expr="0x00000000" line="29" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0x00000000</e></m></meta>
		<haxe_doc><![CDATA[&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;]]></haxe_doc>
	</TRANSPARENT>
	<TRANSPARENT_COLOR public="1" get="inline" set="null" expr="0x00000000" line="45" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0x00000000</e></m></meta>
		<haxe_doc><![CDATA[&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;]]></haxe_doc>
	</TRANSPARENT_COLOR>
	<WHITE public="1" get="inline" set="null" expr="0xFFFFFFFF" line="50" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFFFFF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/ffffff.png)![color](https://www.colorhexa.com/ffffff.png)</haxe_doc>
	</WHITE>
	<OFFWHITE public="1" get="inline" set="null" expr="0xFFFFFFE4" line="55" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFFFE4</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/ffffe4.png)![color](https://www.colorhexa.com/ffffe4.png)</haxe_doc>
	</OFFWHITE>
	<GRAY public="1" get="inline" set="null" expr="0xFF808080" line="60" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF808080</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/808080.png)![color](https://www.colorhexa.com/808080.png)</haxe_doc>
	</GRAY>
	<BLACK public="1" get="inline" set="null" expr="0xFF000000" line="65" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF000000</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/000000.png)![color](https://www.colorhexa.com/000000.png)</haxe_doc>
	</BLACK>
	<GREEN public="1" get="inline" set="null" expr="0xFF00FF00" line="70" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF00FF00</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/00ff00.png)![color](https://www.colorhexa.com/00ff00.png)</haxe_doc>
	</GREEN>
	<YELLOW public="1" get="inline" set="null" expr="0xFFFFFF00" line="75" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFFF00</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FFFF00.png)![color](https://www.colorhexa.com/FFFF00.png)</haxe_doc>
	</YELLOW>
	<ORANGE public="1" get="inline" set="null" expr="0xFFFFA500" line="80" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFA500</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FFA500.png)![color](https://www.colorhexa.com/FFA500.png)</haxe_doc>
	</ORANGE>
	<RED public="1" get="inline" set="null" expr="0xFFFF0000" line="85" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFF0000</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FF0000.png)![color](https://www.colorhexa.com/FF0000.png)</haxe_doc>
	</RED>
	<PURPLE public="1" get="inline" set="null" expr="0xFF800080" line="90" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF800080</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/800080.png)![color](https://www.colorhexa.com/800080.png)</haxe_doc>
	</PURPLE>
	<BLUE public="1" get="inline" set="null" expr="0xFF0000FF" line="95" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF0000FF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/0000ff.png)![color](https://www.colorhexa.com/0000ff.png)</haxe_doc>
	</BLUE>
	<BROWN public="1" get="inline" set="null" expr="0xFF8B4513" line="100" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF8B4513</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/8B4513.png)![color](https://www.colorhexa.com/8B4513.png)</haxe_doc>
	</BROWN>
	<SEPIA public="1" get="inline" set="null" expr="0xFF704214" line="105" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF704214</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/704214.png)![color](https://www.colorhexa.com/704214.png)</haxe_doc>
	</SEPIA>
	<PINK public="1" get="inline" set="null" expr="0xFFFFC0CB" line="110" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFC0CB</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FFC0CB.png)![color](https://www.colorhexa.com/FFC0CB.png)</haxe_doc>
	</PINK>
	<MAGENTA public="1" get="inline" set="null" expr="0xFFFF00FF" line="115" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FF00FF.png)![color](https://www.colorhexa.com/FF00FF.png)</haxe_doc>
	</MAGENTA>
	<CYAN public="1" get="inline" set="null" expr="0xFF00FFFF" line="120" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF00FFFF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/00FFFF.png)![color](https://www.colorhexa.com/00FFFF.png)</haxe_doc>
	</CYAN>
	<SILVER public="1" get="inline" set="null" expr="0xC0C0C0" line="125" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xC0C0C0</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/C0C0C0.png)![color](https://www.colorhexa.com/C0C0C0.png)</haxe_doc>
	</SILVER>
	<GOLD public="1" get="inline" set="null" expr="0xFFFFD700" line="130" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFD700</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FFD700.png)![color](https://www.colorhexa.com/FFD700.png)</haxe_doc>
	</GOLD>
	<OLIVE public="1" get="inline" set="null" expr="0xFF808000" line="135" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF808000</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/808000.png)![color](https://www.colorhexa.com/808000.png)</haxe_doc>
	</OLIVE>
	<MAROON public="1" get="inline" set="null" expr="0xFF800000" line="140" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF800000</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/800000.png)![color](https://www.colorhexa.com/800000.png)</haxe_doc>
	</MAROON>
	<BORDEAUX public="1" get="inline" set="null" expr="0xFF722F37" line="145" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF722F37</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/722F37.png)![color](https://www.colorhexa.com/722F37.png)</haxe_doc>
	</BORDEAUX>
	<NAVY public="1" get="inline" set="null" expr="0xFF000080" line="150" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF000080</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/000080.png)![color](https://www.colorhexa.com/000080.png)</haxe_doc>
	</NAVY>
	<TEAL public="1" get="inline" set="null" expr="0xFF008080" line="155" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF008080</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/008080.png)![color](https://www.colorhexa.com/008080.png)</haxe_doc>
	</TEAL>
	<FUCHSIA public="1" get="inline" set="null" expr="0xFFFF00FF" line="160" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FF00FF.png)![color](https://www.colorhexa.com/FF00FF.png)</haxe_doc>
	</FUCHSIA>
	<AQUA public="1" get="inline" set="null" expr="0xFF00FFFF" line="165" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF00FFFF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/00FFFF.png)![color](https://www.colorhexa.com/00FFFF.png)</haxe_doc>
	</AQUA>
	<LIME public="1" get="inline" set="null" expr="0xFF32CD32" line="170" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF32CD32</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/32CD32.png)![color](https://www.colorhexa.com/32CD32.png)</haxe_doc>
	</LIME>
	<CHARCOAL public="1" get="inline" set="null" expr="0xFF36454F" line="175" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF36454F</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/36454F.png)![color](https://www.colorhexa.com/36454F.png)</haxe_doc>
	</CHARCOAL>
	<ONYX public="1" get="inline" set="null" expr="0xFF353839" line="180" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF353839</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/353839.png)![color](https://www.colorhexa.com/353839.png)</haxe_doc>
	</ONYX>
	<JET public="1" get="inline" set="null" expr="0xFF343434" line="185" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF343434</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/343434.png)![color](https://www.colorhexa.com/343434.png)</haxe_doc>
	</JET>
	<JET_BLACK public="1" get="inline" set="null" expr="0xFF0E0E10" line="190" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF0E0E10</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/0E0E10.png)![color](https://www.colorhexa.com/0E0E10.png)</haxe_doc>
	</JET_BLACK>
	<ROYAL_BLUE public="1" get="inline" set="null" expr="0xFF4169E1" line="195" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF4169E1</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/4169E1.png)![color](https://www.colorhexa.com/4169E1.png)</haxe_doc>
	</ROYAL_BLUE>
	<CHARTREUSE public="1" get="inline" set="null" expr="0xFF7FFF00" line="200" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF7FFF00</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/7FFF00.png)![color](https://www.colorhexa.com/7FFF00.png)</haxe_doc>
	</CHARTREUSE>
	<CERULEAN public="1" get="inline" set="null" expr="0xFF007BA7" line="205" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF007BA7</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/007BA7.png)![color](https://www.colorhexa.com/007BA7.png)</haxe_doc>
	</CERULEAN>
	<PERIWINKLE public="1" get="inline" set="null" expr="0xFFCCCCFF" line="210" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFCCCCFF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/CCCCFF.png)![color](https://www.colorhexa.com/CCCCFF.png)</haxe_doc>
	</PERIWINKLE>
	<VERMILION public="1" get="inline" set="null" expr="0xFFE34234" line="215" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFE34234</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/E34234.png)![color](https://www.colorhexa.com/E34234.png)</haxe_doc>
	</VERMILION>
	<MAUVE public="1" get="inline" set="null" expr="0xFFE0B0FF" line="220" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFE0B0FF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/E0B0FF.png)![color](https://www.colorhexa.com/E0B0FF.png)</haxe_doc>
	</MAUVE>
	<AZURE public="1" get="inline" set="null" expr="0xFF007FFF" line="225" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF007FFF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/007FFF.png)![color](https://www.colorhexa.com/007FFF.png)</haxe_doc>
	</AZURE>
	<TANGERINE public="1" get="inline" set="null" expr="0xFFF28500" line="230" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFF28500</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/F28500.png)![color](https://www.colorhexa.com/F28500.png)</haxe_doc>
	</TANGERINE>
	<INDIGO public="1" get="inline" set="null" expr="0xFF4B0082" line="235" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF4B0082</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/4B0082.png)![color](https://www.colorhexa.com/4B0082.png)</haxe_doc>
	</INDIGO>
	<MARIGOLD public="1" get="inline" set="null" expr="0xFFEAA221" line="240" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFEAA221</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/EAA221.png)![color](https://www.colorhexa.com/EAA221.png)</haxe_doc>
	</MARIGOLD>
	<COBALT public="1" get="inline" set="null" expr="0xFF0047AB" line="245" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF0047AB</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/0047AB.png)![color](https://www.colorhexa.com/0047AB.png)</haxe_doc>
	</COBALT>
	<LAVENDER public="1" get="inline" set="null" expr="0xFFE6E6FA" line="250" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFE6E6FA</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/E6E6FA.png)![color](https://www.colorhexa.com/E6E6FA.png)</haxe_doc>
	</LAVENDER>
	<TURQUOISE public="1" get="inline" set="null" expr="0xFF40E0D0" line="255" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF40E0D0</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/40E0D0.png)![color](https://www.colorhexa.com/40E0D0.png)</haxe_doc>
	</TURQUOISE>
	<OCHRE public="1" get="inline" set="null" expr="0xFFCC7722" line="260" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFCC7722</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/CC7722.png)![color](https://www.colorhexa.com/CC7722.png)</haxe_doc>
	</OCHRE>
	<AQUAMARINE public="1" get="inline" set="null" expr="0xFF7FFFD4" line="265" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF7FFFD4</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/7FFFD4.png)![color](https://www.colorhexa.com/7FFFD4.png)</haxe_doc>
	</AQUAMARINE>
	<RUSSET public="1" get="inline" set="null" expr="0xFF80461B" line="270" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF80461B</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/80461B.png)![color](https://www.colorhexa.com/80461B.png)</haxe_doc>
	</RUSSET>
	<TOPAZ public="1" get="inline" set="null" expr="0xFFFFC87C" line="275" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFC87C</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FFC87C.png)![color](https://www.colorhexa.com/FFC87C.png)</haxe_doc>
	</TOPAZ>
	<APRICOT public="1" get="inline" set="null" expr="0xFFFBCEB1" line="280" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFBCEB1</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FBCEB1.png)![color](https://www.colorhexa.com/FBCEB1.png)</haxe_doc>
	</APRICOT>
	<AMETHYST public="1" get="inline" set="null" expr="0xFF9966CC" line="285" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF9966CC</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/9966CC.png)![color](https://www.colorhexa.com/9966CC.png)</haxe_doc>
	</AMETHYST>
	<SAFFRON public="1" get="inline" set="null" expr="0xFFF4C430" line="290" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFF4C430</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/F4C430.png)![color](https://www.colorhexa.com/F4C430.png)</haxe_doc>
	</SAFFRON>
	<LILAC public="1" get="inline" set="null" expr="0xFFC8A2C8" line="295" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFC8A2C8</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/C8A2C8.png)![color](https://www.colorhexa.com/C8A2C8.png)</haxe_doc>
	</LILAC>
	<CRIMSON public="1" get="inline" set="null" expr="0xFFDC143C" line="300" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFDC143C</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/DC143C.png)![color](https://www.colorhexa.com/DC143C.png)</haxe_doc>
	</CRIMSON>
	<SLATE public="1" get="inline" set="null" expr="0xFF708090" line="305" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF708090</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/708090.png)![color](https://www.colorhexa.com/708090.png)</haxe_doc>
	</SLATE>
	<JADE public="1" get="inline" set="null" expr="0xFF00A86B" line="310" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF00A86B</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/00A86B.png)![color](https://www.colorhexa.com/00A86B.png)</haxe_doc>
	</JADE>
	<CORAL public="1" get="inline" set="null" expr="0xFFFF7F50" line="315" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFF7F50</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FF7F50.png)![color](https://www.colorhexa.com/FF7F50.png)</haxe_doc>
	</CORAL>
	<BURGUNDY public="1" get="inline" set="null" expr="0xFF800020" line="320" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF800020</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/800020.png)![color](https://www.colorhexa.com/800020.png)</haxe_doc>
	</BURGUNDY>
	<SIENNA public="1" get="inline" set="null" expr="0xFF882D17" line="325" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF882D17</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/882D17.png)![color](https://www.colorhexa.com/882D17.png)</haxe_doc>
	</SIENNA>
	<IVORY public="1" get="inline" set="null" expr="0xFFFFFFF0" line="330" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFFFF0</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FFFFF0.png)![color](https://www.colorhexa.com/FFFFF0.png)</haxe_doc>
	</IVORY>
	<MULBERRY public="1" get="inline" set="null" expr="0xFFC54B8C" line="335" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFC54B8C</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/C54B8C.png)![color](https://www.colorhexa.com/C54B8C.png)</haxe_doc>
	</MULBERRY>
	<SANDALWOOD public="1" get="inline" set="null" expr="0xFFAA8D6F" line="340" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFAA8D6F</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/AA8D6F.png)![color](https://www.colorhexa.com/AA8D6F.png)</haxe_doc>
	</SANDALWOOD>
	<GARNET public="1" get="inline" set="null" expr="0xFF733635" line="345" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF733635</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/733635.png)![color](https://www.colorhexa.com/733635.png)</haxe_doc>
	</GARNET>
	<PEWTER public="1" get="inline" set="null" expr="0xFF8BA8B7" line="350" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF8BA8B7</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/8BA8B7.png)![color](https://www.colorhexa.com/8BA8B7.png)</haxe_doc>
	</PEWTER>
	<CARNATION public="1" get="inline" set="null" expr="0xFFFFA6C9" line="355" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFA6C9</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FFA6C9.png)![color](https://www.colorhexa.com/FFA6C9.png)</haxe_doc>
	</CARNATION>
	<CITRINE public="1" get="inline" set="null" expr="0xFFE4D00A" line="360" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFE4D00A</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/E4D00A.png)![color](https://www.colorhexa.com/E4D00A.png)</haxe_doc>
	</CITRINE>
	<CELADON public="1" get="inline" set="null" expr="0xFFACE1AF" line="365" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFACE1AF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/ACE1AF.png)![color](https://www.colorhexa.com/ACE1AF.png)</haxe_doc>
	</CELADON>
	<HELIOTROPE public="1" get="inline" set="null" expr="0xFFDF73FF" line="370" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFDF73FF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/DF73FF.png)![color](https://www.colorhexa.com/DF73FF.png)</haxe_doc>
	</HELIOTROPE>
	<PUCE public="1" get="inline" set="null" expr="0xFFCC8899" line="375" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFCC8899</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/CC8899.png)![color](https://www.colorhexa.com/CC8899.png)</haxe_doc>
	</PUCE>
	<CINNABAR public="1" get="inline" set="null" expr="0xFFE34234" line="380" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFE34234</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/E34234.png)![color](https://www.colorhexa.com/E34234.png)</haxe_doc>
	</CINNABAR>
	<VIRIDIAN public="1" get="inline" set="null" expr="0xFF40826D" line="385" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF40826D</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/40826D.png)![color](https://www.colorhexa.com/40826D.png)</haxe_doc>
	</VIRIDIAN>
	<ECRU public="1" get="inline" set="null" expr="0xFFC2B280" line="390" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFC2B280</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/C2B280.png)![color](https://www.colorhexa.com/C2B280.png)</haxe_doc>
	</ECRU>
	<ALABASTER public="1" get="inline" set="null" expr="0xFFEDEAE0" line="395" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFEDEAE0</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/EDEAE0.png)![color](https://www.colorhexa.com/EDEAE0.png)</haxe_doc>
	</ALABASTER>
	<SAPPHIRE public="1" get="inline" set="null" expr="0xFF0F52BA" line="400" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF0F52BA</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/0F52BA.png)![color](https://www.colorhexa.com/0F52BA.png)</haxe_doc>
	</SAPPHIRE>
	<PEARL public="1" get="inline" set="null" expr="0xFFEAE0C8" line="405" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFEAE0C8</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/EAE0C8.png)![color](https://www.colorhexa.com/EAE0C8.png)</haxe_doc>
	</PEARL>
	<SALMON public="1" get="inline" set="null" expr="0xFFFA8072" line="410" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFA8072</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FA8072.png)![color](https://www.colorhexa.com/FA8072.png)</haxe_doc>
	</SALMON>
	<UMBER public="1" get="inline" set="null" expr="0xFF635147" line="415" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF635147</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/635147.png)![color](https://www.colorhexa.com/635147.png)</haxe_doc>
	</UMBER>
	<TURMERIC public="1" get="inline" set="null" expr="0xFFE4D00A" line="420" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFE4D00A</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/E4D00A.png)![color](https://www.colorhexa.com/E4D00A.png)</haxe_doc>
	</TURMERIC>
	<MAHOGANY public="1" get="inline" set="null" expr="0xFFC04000" line="425" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFC04000</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/C04000.png)![color](https://www.colorhexa.com/C04000.png)</haxe_doc>
	</MAHOGANY>
	<PERSIMMON public="1" get="inline" set="null" expr="0xFFFF6347" line="430" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFF6347</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FF6347.png)![color](https://www.colorhexa.com/FF6347.png)</haxe_doc>
	</PERSIMMON>
	<ROSEWOOD public="1" get="inline" set="null" expr="0xFF65000B" line="435" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF65000B</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/65000B.png)![color](https://www.colorhexa.com/65000B.png)</haxe_doc>
	</ROSEWOOD>
	<CARAMEL public="1" get="inline" set="null" expr="0xFFFFD700" line="440" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFD700</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FFD700.png)![color](https://www.colorhexa.com/FFD700.png)</haxe_doc>
	</CARAMEL>
	<DANDELION public="1" get="inline" set="null" expr="0xFFF0E130" line="445" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFF0E130</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/F0E130.png)![color](https://www.colorhexa.com/F0E130.png)</haxe_doc>
	</DANDELION>
	<FERN public="1" get="inline" set="null" expr="0xFF71BC78" line="450" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF71BC78</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/71BC78.png)![color](https://www.colorhexa.com/71BC78.png)</haxe_doc>
	</FERN>
	<LAPIS public="1" get="inline" set="null" expr="0xFF26619C" line="455" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF26619C</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/26619C.png)![color](https://www.colorhexa.com/26619C.png)</haxe_doc>
	</LAPIS>
	<DENIM public="1" get="inline" set="null" expr="0xFF1560BD" line="460" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF1560BD</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/1560BD.png)![color](https://www.colorhexa.com/1560BD.png)</haxe_doc>
	</DENIM>
	<SABLE public="1" get="inline" set="null" expr="0xFF8E6D7B" line="465" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF8E6D7B</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/8E6D7B.png)![color](https://www.colorhexa.com/8E6D7B.png)</haxe_doc>
	</SABLE>
	<ORCHID public="1" get="inline" set="null" expr="0xFFDA70D6" line="470" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFDA70D6</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/DA70D6.png)![color](https://www.colorhexa.com/DA70D6.png)</haxe_doc>
	</ORCHID>
	<TAWNY public="1" get="inline" set="null" expr="0xFFCD5700" line="475" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFCD5700</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/CD5700.png)![color](https://www.colorhexa.com/CD5700.png)</haxe_doc>
	</TAWNY>
	<PINE public="1" get="inline" set="null" expr="0xFF01796F" line="480" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF01796F</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/01796F.png)![color](https://www.colorhexa.com/01796F.png)</haxe_doc>
	</PINE>
	<LEMON public="1" get="inline" set="null" expr="0xFFFFF700" line="485" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFF700</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FFF700.png)![color](https://www.colorhexa.com/FFF700.png)</haxe_doc>
	</LEMON>
	<SCARLET public="1" get="inline" set="null" expr="0xFFFF2400" line="490" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFF2400</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FF2400.png)![color](https://www.colorhexa.com/FF2400.png)</haxe_doc>
	</SCARLET>
	<TAUPE public="1" get="inline" set="null" expr="0xFF483C32" line="495" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF483C32</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/483C32.png)![color](https://www.colorhexa.com/483C32.png)</haxe_doc>
	</TAUPE>
	<CERISE public="1" get="inline" set="null" expr="0xFFDE3163" line="500" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFDE3163</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/DE3163.png)![color](https://www.colorhexa.com/DE3163.png)</haxe_doc>
	</CERISE>
	<AMBER public="1" get="inline" set="null" expr="0xFFFFBF00" line="505" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFBF00</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FFBF00.png)![color](https://www.colorhexa.com/FFBF00.png)</haxe_doc>
	</AMBER>
	<CINNAMON public="1" get="inline" set="null" expr="0xFFD2691E" line="510" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFD2691E</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/D2691E.png)![color](https://www.colorhexa.com/D2691E.png)</haxe_doc>
	</CINNAMON>
	<SADDLE_BROWN public="1" get="inline" set="null" expr="0xFF8B4513" line="515" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF8B4513</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/8B4513.png)![color](https://www.colorhexa.com/8B4513.png)</haxe_doc>
	</SADDLE_BROWN>
	<TOMATO public="1" get="inline" set="null" expr="0xFFFF6347" line="520" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFF6347</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FF6347.png)![color](https://www.colorhexa.com/FF6347.png)</haxe_doc>
	</TOMATO>
	<CORNSILK public="1" get="inline" set="null" expr="0xFFFFDAB9" line="525" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFFFFDAB9</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/FFDAB9.png)![color](https://www.colorhexa.com/FFDAB9.png)</haxe_doc>
	</CORNSILK>
	<VIOLET public="1" get="inline" set="null" expr="0xFF7F00FF" line="530" static="1">
		<x path="vision.ds.Color"/>
		<meta><m n=":value"><e>0xFF7F00FF</e></m></meta>
		<haxe_doc>![color](https://www.colorhexa.com/7F00FF.png)![color](https://www.colorhexa.com/7F00FF.png)</haxe_doc>
	</VIOLET>
	<red public="1" get="accessor" set="accessor" static="1"><x path="Int"/></red>
	<blue public="1" get="accessor" set="accessor" static="1"><x path="Int"/></blue>
	<green public="1" get="accessor" set="accessor" static="1"><x path="Int"/></green>
	<alpha public="1" get="accessor" set="accessor" static="1"><x path="Int"/></alpha>
	<redFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></redFloat>
	<blueFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></blueFloat>
	<greenFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></greenFloat>
	<alphaFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></alphaFloat>
	<cyan public="1" get="accessor" set="accessor" static="1"><x path="Float"/></cyan>
	<magenta public="1" get="accessor" set="accessor" static="1"><x path="Float"/></magenta>
	<yellow public="1" get="accessor" set="accessor" static="1"><x path="Float"/></yellow>
	<black public="1" get="accessor" set="accessor" static="1"><x path="Float"/></black>
	<rgb public="1" get="accessor" set="accessor" static="1">
		<x path="vision.ds.Color"/>
		<haxe_doc>The red, green and blue channels of this color as a 24 bit integer (from 0 to 0xFFFFFF, does not include alpha values)</haxe_doc>
	</rgb>
	<hue public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The hue of the color in degrees (from 0 to 359)</haxe_doc>
	</hue>
	<saturation public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The saturation of the color (from 0 to 1)</haxe_doc>
	</saturation>
	<brightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
	</brightness>
	<lightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The lightness of the color (from 0 to 1)</haxe_doc>
	</lightness>
	<COLOR_REGEX expr="~/^(0x|#)(([A-F0-9]{2}){3,4})$/" line="572" static="1">
		<c path="EReg"/>
		<meta><m n=":value"><e>~/^(0x|#)(([A-F0-9]{2}){3,4})$/</e></m></meta>
	</COLOR_REGEX>
	<fromInt public="1" get="inline" set="null" line="580" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Create a color from the least significant four bytes of an `Int`

		@param value `Int` with bytes in the format 0xAARRGGBB
		@return	The color as a `Color`</haxe_doc>
	</fromInt>
	<fromRGBA public="1" get="inline" set="null" line="593" static="1">
		<f a="Red:Green:Blue:?Alpha" v=":::255">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
		<haxe_doc>Generate a color from integer RGB values (0 to 255)

		@param Red	The red value of the color from 0 to 255
		@param Green	The green value of the color from 0 to 255
		@param Blue	The green value of the color from 0 to 255
		@param Alpha	How opaque the color should be, from 0 to 255, default is 255
		@return The color as a Color</haxe_doc>
	</fromRGBA>
	<from8Bit public="1" get="inline" set="null" line="604" static="1">
		<f a="Value">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc><![CDATA[Generate a grayscale color from a single color channel value (0 to 255)

		@param Value	The channel value of the red, green & blue channels of the color
		@return The color as a Color]]></haxe_doc>
	</from8Bit>
	<fromRGBAFloat public="1" get="inline" set="null" line="618" static="1">
		<f a="Red:Green:Blue:?Alpha" v=":::1">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>Generate a color from float RGB values (0 to 1)

		@param Red	The red value of the color from 0 to 1
		@param Green	The green value of the color from 0 to 1
		@param Blue	The green value of the color from 0 to 1
		@param Alpha	How opaque the color should be, from 0 to 1, default is 1
		@return The color as a `Color`</haxe_doc>
	</fromRGBAFloat>
	<fromCMYK public="1" get="inline" set="null" line="633" static="1">
		<f a="Cyan:Magenta:Yellow:Black:?Alpha" v="::::1">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>Generate a color from CMYK values (0 to 1)

		@param Cyan		The cyan value of the color from 0 to 1
		@param Magenta	The magenta value of the color from 0 to 1
		@param Yellow	The yellow value of the color from 0 to 1
		@param Black		The black value of the color from 0 to 1
		@param Alpha		How opaque the color should be, from 0 to 1, default is 1
		@return The color as a `Color`</haxe_doc>
	</fromCMYK>
	<fromHSB public="1" set="method" line="647" static="1">
		<f a="Hue:Saturation:Brightness:?Alpha" v=":::1">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>Generate a color from HSB (aka HSV) components.

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright (default).
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255, default is 1.
		@return	The color as a `Color`</haxe_doc>
	</fromHSB>
	<fromHSL public="1" get="inline" set="null" line="661" static="1">
		<f a="Hue:Saturation:Lightness:?Alpha" v=":::1">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>Generate a color from HSL components.

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Lightness	A number between 0 and 1, indicating the lightness of the color
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255, default is 1.
		@return	The color as a `Color`</haxe_doc>
	</fromHSL>
	<fromString public="1" set="method" line="681" static="1">
		<f a="str">
			<c path="String"/>
			<x path="Null"><x path="vision.ds.Color"/></x>
		</f>
		<haxe_doc><![CDATA[Parses a `String` and returns a `Color` or `null` if the `String` couldn't be parsed.

		Examples (input -> output in hex):

		- `0x00FF00`    -> `0xFF00FF00`
		- `0xAA4578C2`  -> `0xAA4578C2`
		- `#0000FF`     -> `0xFF0000FF`
		- `#3F000011`   -> `0x3F000011`
		- `GRAY`        -> `0xFF808080`
		- `blue`        -> `0xFF0000FF`

		@param	str 	The string to be parsed
		@return	A `Color` or `null` if the `String` couldn't be parsed]]></haxe_doc>
	</fromString>
	<getHSBColorWheel public="1" set="method" line="702" static="1">
		<f a="?Alpha" v="255">
			<x path="Int"/>
			<c path="Array"><x path="vision.ds.Color"/></c>
		</f>
		<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
		<haxe_doc>Get HSB color wheel values in an array which will be 360 elements in size

		@param	Alpha Alpha value for each color of the color wheel, between 0 (transparent) and 255 (opaque) (default)
		@return	HSB color wheel as Array of Colors</haxe_doc>
	</getHSBColorWheel>
	<interpolate public="1" get="inline" set="null" line="714" static="1">
		<f a="Color1:Color2:?Factor" v="::0.5">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Factor : 0.5 }</e></m></meta>
		<haxe_doc>Get an interpolated color based on two different colors.

		@param 	Color1 The first color
		@param 	Color2 The second color
		@param 	Factor Value from 0 to 1 representing how much to shift Color1 toward Color2, default is 0.5
		@return	The interpolated color as a `Color`</haxe_doc>
	</interpolate>
	<gradient public="1" set="method" line="732" static="1">
		<f a="Color1:Color2:Steps:?Ease">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<c path="Array"><x path="vision.ds.Color"/></c>
		</f>
		<haxe_doc>Create a gradient from one color to another

		@param Color1 The color to shift from
		@param Color2 The color to shift to
		@param Steps How many colors the gradient should have
		@param Ease An optional easing function.
		@return An array of colors of length Steps, shifting from Color1 to Color2</haxe_doc>
	</gradient>
	<makeRandom public="1" get="inline" set="null" line="754" static="1">
		<f a="?alphaLock:?alphaValue" v="true:255">
			<x path="Bool"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ alphaValue : 255, alphaLock : true }</e></m></meta>
		<haxe_doc>Generate a random color, with randomized red, green, blue and optionally alpha values.

		@param alphaLock When set to `false`, the alpha channel will get a randomized value to. `true` by default, which makes a color with `alpha = 255`.
		@param alphaValue When `alphaLock` is true, you can provide this value to override the default alpha value. Since the first argument is optional, you can do `Color.makeRandom(128)` (a random color with `alpha` set to `128`)</haxe_doc>
	</makeRandom>
	<multiply public="1" get="inline" set="null" line="762" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A * B</e></m></meta>
		<haxe_doc>Multiply the RGB and alpha channels of two Colors</haxe_doc>
	</multiply>
	<add public="1" get="inline" set="null" line="771" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
		<haxe_doc>Add the RGB and alpha channels of two Colors</haxe_doc>
	</add>
	<subtract public="1" get="inline" set="null" line="779" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
		<haxe_doc>Subtract the RGB and alpha channels of one Color from another</haxe_doc>
	</subtract>
	<divide public="1" get="inline" set="null" line="789" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A / B</e></m></meta>
		<haxe_doc>* Divide the RGB and alpha channels of one Color from another.
	 * 
	 * If a color channel value on the right hand side is `0`, the left hand side's channel will get divided by `1`.</haxe_doc>
	</divide>
	<getComplementHarmony public="1" get="inline" set="null" line="800" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Returns a Complementary Color Harmony of this color.
		A complementary hue is one directly opposite the color given on the color wheel

		@return	The complimentary color</haxe_doc>
	</getComplementHarmony>
	<getAnalogousHarmony public="1" get="inline" set="null" line="811" static="1">
		<f a="this:?Threshold" v=":30">
			<x path="Int"/>
			<x path="Int"/>
			<t path="vision.ds.Harmony"/>
		</f>
		<meta><m n=":value"><e>{ Threshold : 30 }</e></m></meta>
		<haxe_doc>Returns an Analogous Color Harmony for the given color.
		An Analogous harmony are hues adjacent to each other on the color wheel

		@param	Threshold Control how adjacent the colors will be (default +- 30 degrees)
		@return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
	</getAnalogousHarmony>
	<getSplitComplementHarmony public="1" get="inline" set="null" line="825" static="1">
		<f a="this:?Threshold" v=":30">
			<x path="Int"/>
			<x path="Int"/>
			<t path="vision.ds.Harmony"/>
		</f>
		<meta><m n=":value"><e>{ Threshold : 30 }</e></m></meta>
		<haxe_doc>Returns an Split Complement Color Harmony for this color.
		A Split Complement harmony are the two hues on either side of the color's Complement

		@param	Threshold Control how adjacent the colors will be to the Complement (default +- 30 degrees)
		@return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
	</getSplitComplementHarmony>
	<getTriadicHarmony public="1" get="inline" set="null" line="839" static="1">
		<f a="this">
			<x path="Int"/>
			<t path="vision.ds.TriadicHarmony"/>
		</f>
		<haxe_doc>Returns a Triadic Color Harmony for this color. A Triadic harmony are 3 hues equidistant
		from each other on the color wheel.

		@return 	Object containing 3 properties: color1 (the original color), color2 and color3 (the equidistant colors)</haxe_doc>
	</getTriadicHarmony>
	<to24Bit public="1" get="inline" set="null" line="851" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Return a 24 bit version of this color (i.e. without an alpha value)

		@return A 24 bit version of this color</haxe_doc>
	</to24Bit>
	<toHexString public="1" get="inline" set="null" line="862" static="1">
		<f a="this:?Alpha:?Prefix" v=":true:true">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<c path="String"/>
		</f>
		<meta><m n=":value"><e>{ Prefix : true, Alpha : true }</e></m></meta>
		<haxe_doc>Return a String representation of the color in the format

		@param Alpha Whether to include the alpha value in the hes string
		@param Prefix Whether to include "0x" prefix at start of string
		@return	A string of length 10 in the format 0xAARRGGBB</haxe_doc>
	</toHexString>
	<toWebString public="1" get="inline" set="null" line="871" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<haxe_doc>Return a String representation of the color in the format #RRGGBB

		@return	A string of length 7 in the format #RRGGBB</haxe_doc>
	</toWebString>
	<darken public="1" set="method" line="881" static="1">
		<f a="this:?Factor" v=":0.2">
			<x path="Int"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Factor : 0.2 }</e></m></meta>
		<haxe_doc>Get a darkened version of this color

		@param	Factor Value from 0 to 1 of how much to progress toward black.
		@return 	A darkened version of this color</haxe_doc>
	</darken>
	<lighten public="1" get="inline" set="null" line="894" static="1">
		<f a="this:?Factor" v=":0.2">
			<x path="Int"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Factor : 0.2 }</e></m></meta>
		<haxe_doc>Get a lightened version of this color

		@param	Factor Value from 0 to 1 of how much to progress toward white.
		@return 	A lightened version of this color</haxe_doc>
	</lighten>
	<invert public="1" get="inline" set="null" line="906" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Get the inversion of this color

		@return The inversion of this color</haxe_doc>
	</invert>
	<setRGBA public="1" get="inline" set="null" line="922" static="1">
		<f a="this:Red:Green:Blue:?Alpha" v="::::255">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
		<haxe_doc>Set RGB values as integers (0 to 255)

		@param Red	The red value of the color from 0 to 255
		@param Green	The green value of the color from 0 to 255
		@param Blue	The green value of the color from 0 to 255
		@param Alpha	How opaque the color should be, from 0 to 255, default is 255
		@return This color</haxe_doc>
	</setRGBA>
	<setRGBAFloat public="1" get="inline" set="null" line="939" static="1">
		<f a="this:Red:Green:Blue:?Alpha" v="::::1">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>Set RGB values as floats (0 to 1)

		@param Red	The red value of the color from 0 to 1
		@param Green	The green value of the color from 0 to 1
		@param Blue	The green value of the color from 0 to 1
		@param Alpha	How opaque the color should be, from 0 to 1, default is 1
		@return This color</haxe_doc>
	</setRGBAFloat>
	<setCMYK public="1" get="inline" set="null" line="957" static="1">
		<f a="this:Cyan:Magenta:Yellow:Black:?Alpha" v=":::::1">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>Set CMYK values as floats (0 to 1)

		@param Cyan		The cyan value of the color from 0 to 1
		@param Magenta	The magenta value of the color from 0 to 1
		@param Yellow	The yellow value of the color from 0 to 1
		@param Black		The black value of the color from 0 to 1
		@param Alpha		How opaque the color should be, from 0 to 1, default is 1
		@return This color</haxe_doc>
	</setCMYK>
	<setHSB public="1" get="inline" set="null" line="974" static="1">
		<f a="this:Hue:Saturation:Brightness:Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Set HSB (aka HSV) components

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
		@return	This color</haxe_doc>
	</setHSB>
	<setHSL public="1" get="inline" set="null" line="989" static="1">
		<f a="this:Hue:Saturation:Lightness:Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Set HSL components.

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Lightness	A number between 0 and 1, indicating the lightness of the color
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255
		@return	This color</haxe_doc>
	</setHSL>
	<setHSChromaMatch get="inline" set="null" line="998" static="1">
		<f a="this:Hue:Saturation:Chroma:Match:Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
	</setHSChromaMatch>
	<grayscale public="1" get="inline" set="null" line="1019" static="1">
		<f a="this:?simple" v=":false">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ simple : false }</e></m></meta>
		<haxe_doc>@param simple When enabled, gets the gray by averaging this color's channel values, instead of using a special ratio for more accurate grayscaling. Defaults to `false`</haxe_doc>
	</grayscale>
	<blackOrWhite public="1" get="inline" set="null" line="1029" static="1">
		<f a="this:?threshold" v=":128">
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":value"><e>{ threshold : 128 }</e></m></meta>
		<haxe_doc>Turns this color black/white, according to the values of the color channels.

		@param threshold The threshold for converting to black and white: `threshold` is the maximum average of the three color components, that will still be considered black. `threshold` is a value between 0 and 255. The higher the value, the more "sensitive" the conversion. The default value is 128.</haxe_doc>
	</blackOrWhite>
	<_new public="1" get="inline" set="null" line="1041" static="1">
		<f a="?value" v="0">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta>
			<m n=":value"><e>{ value : 0 }</e></m>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<getThis get="inline" set="null" line="1045" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></getThis>
	<validate get="inline" set="null" line="1053" static="1"><f a="this">
	<x path="Int"/>
	<x path="Void"/>
</f></validate>
	<get_red get="inline" set="null" line="1059" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_red>
	<get_green get="inline" set="null" line="1063" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_green>
	<get_blue get="inline" set="null" line="1067" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_blue>
	<get_alpha get="inline" set="null" line="1071" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_alpha>
	<get_redFloat get="inline" set="null" line="1075" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_redFloat>
	<get_greenFloat get="inline" set="null" line="1079" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_greenFloat>
	<get_blueFloat get="inline" set="null" line="1083" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_blueFloat>
	<get_alphaFloat get="inline" set="null" line="1087" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_alphaFloat>
	<set_red get="inline" set="null" line="1091" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_red>
	<set_green get="inline" set="null" line="1098" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_green>
	<set_blue get="inline" set="null" line="1105" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_blue>
	<set_alpha get="inline" set="null" line="1112" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_alpha>
	<set_redFloat get="inline" set="null" line="1119" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_redFloat>
	<set_greenFloat get="inline" set="null" line="1124" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_greenFloat>
	<set_blueFloat get="inline" set="null" line="1129" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_blueFloat>
	<set_alphaFloat get="inline" set="null" line="1134" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_alphaFloat>
	<get_cyan get="inline" set="null" line="1139" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_cyan>
	<get_magenta get="inline" set="null" line="1143" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_magenta>
	<get_yellow get="inline" set="null" line="1147" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_yellow>
	<get_black get="inline" set="null" line="1151" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_black>
	<set_cyan get="inline" set="null" line="1155" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_cyan>
	<set_magenta get="inline" set="null" line="1160" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_magenta>
	<set_yellow get="inline" set="null" line="1165" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_yellow>
	<set_black get="inline" set="null" line="1170" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_black>
	<get_hue set="method" line="1175" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hue>
	<get_brightness get="inline" set="null" line="1185" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_brightness>
	<get_saturation get="inline" set="null" line="1189" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturation>
	<get_lightness get="inline" set="null" line="1193" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightness>
	<set_hue get="inline" set="null" line="1197" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hue>
	<set_saturation get="inline" set="null" line="1202" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturation>
	<set_brightness get="inline" set="null" line="1207" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_brightness>
	<set_lightness get="inline" set="null" line="1212" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightness>
	<set_rgb get="inline" set="null" line="1217" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="vision.ds.Color"/>
	<x path="vision.ds.Color"/>
</f></set_rgb>
	<get_rgb get="inline" set="null" line="1223" static="1"><f a="this">
	<x path="Int"/>
	<x path="vision.ds.Color"/>
</f></get_rgb>
	<maxColor get="inline" set="null" line="1227" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></maxColor>
	<minColor get="inline" set="null" line="1231" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></minColor>
	<boundChannel get="inline" set="null" line="1235" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></boundChannel>
	<toString public="1" set="method" line="1239" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<toInt public="1" set="method" line="1247" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></toInt>
	<color_greater_than_color get="inline" set="null" line="1256" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</color_greater_than_color>
	<color_greater_than_int get="inline" set="null" line="1261" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</color_greater_than_int>
	<int_greater_than_color get="inline" set="null" line="1266" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</int_greater_than_color>
	<color_greater_than_float get="inline" set="null" line="1271" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</color_greater_than_float>
	<float_greater_than_color get="inline" set="null" line="1276" static="1">
		<f a="lhs:rhs">
			<x path="Float"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</float_greater_than_color>
	<color_greater_than_equal_color get="inline" set="null" line="1281" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</color_greater_than_equal_color>
	<color_greater_than_equal_int get="inline" set="null" line="1286" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</color_greater_than_equal_int>
	<int_greater_than_equal_color get="inline" set="null" line="1291" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</int_greater_than_equal_color>
	<color_greater_than_equal_float get="inline" set="null" line="1296" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</color_greater_than_equal_float>
	<float_greater_than_equal_color get="inline" set="null" line="1301" static="1">
		<f a="lhs:rhs">
			<x path="Float"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</float_greater_than_equal_color>
	<color_less_than_color get="inline" set="null" line="1306" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</color_less_than_color>
	<color_less_than_int get="inline" set="null" line="1311" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</color_less_than_int>
	<int_less_than_color get="inline" set="null" line="1316" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</int_less_than_color>
	<color_less_than_float get="inline" set="null" line="1321" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</color_less_than_float>
	<float_less_than_color get="inline" set="null" line="1326" static="1">
		<f a="lhs:rhs">
			<x path="Float"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</float_less_than_color>
	<color_less_than_equal_color get="inline" set="null" line="1331" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</color_less_than_equal_color>
	<color_less_than_equal_int get="inline" set="null" line="1336" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</color_less_than_equal_int>
	<int_less_than_equal_color get="inline" set="null" line="1341" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</int_less_than_equal_color>
	<color_less_than_equal_float get="inline" set="null" line="1346" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</color_less_than_equal_float>
	<float_less_than_equal_color get="inline" set="null" line="1351" static="1">
		<f a="lhs:rhs">
			<x path="Float"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</float_less_than_equal_color>
	<color_equal_color get="inline" set="null" line="1356" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A == B</e></m></meta>
	</color_equal_color>
	<color_equal_int get="inline" set="null" line="1361" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A == B</e></m></meta>
	</color_equal_int>
	<int_equal_color get="inline" set="null" line="1366" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A == B</e></m></meta>
	</int_equal_color>
	<color_equal_float get="inline" set="null" line="1371" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A == B</e></m></meta>
	</color_equal_float>
	<float_equal_color get="inline" set="null" line="1376" static="1">
		<f a="lhs:rhs">
			<x path="Float"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A == B</e></m></meta>
	</float_equal_color>
	<color_not_equal_color get="inline" set="null" line="1381" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A != B</e></m></meta>
	</color_not_equal_color>
	<color_not_equal_int get="inline" set="null" line="1386" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A != B</e></m></meta>
	</color_not_equal_int>
	<int_not_equal_color get="inline" set="null" line="1391" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A != B</e></m></meta>
	</int_not_equal_color>
	<color_not_equal_float get="inline" set="null" line="1396" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A != B</e></m></meta>
	</color_not_equal_float>
	<float_not_equal_color get="inline" set="null" line="1401" static="1">
		<f a="lhs:rhs">
			<x path="Float"/>
			<x path="vision.ds.Color"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A != B</e></m></meta>
	</float_not_equal_color>
	<color_bitwise_and_color get="inline" set="null" line="1406" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
	</color_bitwise_and_color>
	<color_bitwise_and_int get="inline" set="null" line="1411" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
	</color_bitwise_and_int>
	<int_bitwise_and_color get="inline" set="null" line="1416" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
	</int_bitwise_and_color>
	<color_bitwise_or_color get="inline" set="null" line="1421" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A | B</e></m></meta>
	</color_bitwise_or_color>
	<color_bitwise_or_int get="inline" set="null" line="1426" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A | B</e></m></meta>
	</color_bitwise_or_int>
	<int_bitwise_or_color get="inline" set="null" line="1431" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A | B</e></m></meta>
	</int_bitwise_or_color>
	<color_bitwise_xor_color get="inline" set="null" line="1436" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A ^ B</e></m></meta>
	</color_bitwise_xor_color>
	<color_bitwise_xor_int get="inline" set="null" line="1441" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A ^ B</e></m></meta>
	</color_bitwise_xor_int>
	<int_bitwise_xor_color get="inline" set="null" line="1446" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e>A ^ B</e></m></meta>
	</int_bitwise_xor_color>
	<color_bitwise_left_shift_color get="inline" set="null" line="1451" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
	</color_bitwise_left_shift_color>
	<color_bitwise_left_shift_int get="inline" set="null" line="1456" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
	</color_bitwise_left_shift_int>
	<int_bitwise_left_shift_color get="inline" set="null" line="1461" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
	</int_bitwise_left_shift_color>
	<color_bitwise_right_shift_color get="inline" set="null" line="1466" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
	</color_bitwise_right_shift_color>
	<color_bitwise_right_shift_int get="inline" set="null" line="1471" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
	</color_bitwise_right_shift_int>
	<int_bitwise_right_shift_color get="inline" set="null" line="1476" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
	</int_bitwise_right_shift_color>
	<color_bitwise_unsigned_right_shift_color get="inline" set="null" line="1481" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
	</color_bitwise_unsigned_right_shift_color>
	<color_bitwise_unsigned_right_shift_int get="inline" set="null" line="1486" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Color"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
	</color_bitwise_unsigned_right_shift_int>
	<int_bitwise_unsigned_right_shift_color get="inline" set="null" line="1491" static="1">
		<f a="lhs:rhs">
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
	</int_bitwise_unsigned_right_shift_color>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds._Color.Color_Impl_" params="" file="src/vision/ds/Color.hx" private="1" module="vision.ds.Color" final="1">
		<TRANSPARENT public="1" get="inline" set="null" expr="0x00000000" line="29" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0x00000000</e></m></meta>
			<haxe_doc><![CDATA[&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;  
			&nbsp;]]></haxe_doc>
		</TRANSPARENT>
		<TRANSPARENT_COLOR public="1" get="inline" set="null" expr="0x00000000" line="45" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0x00000000</e></m></meta>
			<haxe_doc><![CDATA[&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;  
		&nbsp;]]></haxe_doc>
		</TRANSPARENT_COLOR>
		<WHITE public="1" get="inline" set="null" expr="0xFFFFFFFF" line="50" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFFFFF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/ffffff.png)![color](https://www.colorhexa.com/ffffff.png)</haxe_doc>
		</WHITE>
		<OFFWHITE public="1" get="inline" set="null" expr="0xFFFFFFE4" line="55" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFFFE4</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/ffffe4.png)![color](https://www.colorhexa.com/ffffe4.png)</haxe_doc>
		</OFFWHITE>
		<GRAY public="1" get="inline" set="null" expr="0xFF808080" line="60" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF808080</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/808080.png)![color](https://www.colorhexa.com/808080.png)</haxe_doc>
		</GRAY>
		<BLACK public="1" get="inline" set="null" expr="0xFF000000" line="65" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF000000</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/000000.png)![color](https://www.colorhexa.com/000000.png)</haxe_doc>
		</BLACK>
		<GREEN public="1" get="inline" set="null" expr="0xFF00FF00" line="70" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF00FF00</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/00ff00.png)![color](https://www.colorhexa.com/00ff00.png)</haxe_doc>
		</GREEN>
		<YELLOW public="1" get="inline" set="null" expr="0xFFFFFF00" line="75" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFFF00</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FFFF00.png)![color](https://www.colorhexa.com/FFFF00.png)</haxe_doc>
		</YELLOW>
		<ORANGE public="1" get="inline" set="null" expr="0xFFFFA500" line="80" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFA500</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FFA500.png)![color](https://www.colorhexa.com/FFA500.png)</haxe_doc>
		</ORANGE>
		<RED public="1" get="inline" set="null" expr="0xFFFF0000" line="85" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFF0000</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FF0000.png)![color](https://www.colorhexa.com/FF0000.png)</haxe_doc>
		</RED>
		<PURPLE public="1" get="inline" set="null" expr="0xFF800080" line="90" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF800080</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/800080.png)![color](https://www.colorhexa.com/800080.png)</haxe_doc>
		</PURPLE>
		<BLUE public="1" get="inline" set="null" expr="0xFF0000FF" line="95" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF0000FF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/0000ff.png)![color](https://www.colorhexa.com/0000ff.png)</haxe_doc>
		</BLUE>
		<BROWN public="1" get="inline" set="null" expr="0xFF8B4513" line="100" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF8B4513</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/8B4513.png)![color](https://www.colorhexa.com/8B4513.png)</haxe_doc>
		</BROWN>
		<SEPIA public="1" get="inline" set="null" expr="0xFF704214" line="105" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF704214</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/704214.png)![color](https://www.colorhexa.com/704214.png)</haxe_doc>
		</SEPIA>
		<PINK public="1" get="inline" set="null" expr="0xFFFFC0CB" line="110" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFC0CB</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FFC0CB.png)![color](https://www.colorhexa.com/FFC0CB.png)</haxe_doc>
		</PINK>
		<MAGENTA public="1" get="inline" set="null" expr="0xFFFF00FF" line="115" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FF00FF.png)![color](https://www.colorhexa.com/FF00FF.png)</haxe_doc>
		</MAGENTA>
		<CYAN public="1" get="inline" set="null" expr="0xFF00FFFF" line="120" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF00FFFF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/00FFFF.png)![color](https://www.colorhexa.com/00FFFF.png)</haxe_doc>
		</CYAN>
		<SILVER public="1" get="inline" set="null" expr="0xC0C0C0" line="125" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xC0C0C0</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/C0C0C0.png)![color](https://www.colorhexa.com/C0C0C0.png)</haxe_doc>
		</SILVER>
		<GOLD public="1" get="inline" set="null" expr="0xFFFFD700" line="130" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFD700</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FFD700.png)![color](https://www.colorhexa.com/FFD700.png)</haxe_doc>
		</GOLD>
		<OLIVE public="1" get="inline" set="null" expr="0xFF808000" line="135" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF808000</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/808000.png)![color](https://www.colorhexa.com/808000.png)</haxe_doc>
		</OLIVE>
		<MAROON public="1" get="inline" set="null" expr="0xFF800000" line="140" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF800000</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/800000.png)![color](https://www.colorhexa.com/800000.png)</haxe_doc>
		</MAROON>
		<BORDEAUX public="1" get="inline" set="null" expr="0xFF722F37" line="145" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF722F37</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/722F37.png)![color](https://www.colorhexa.com/722F37.png)</haxe_doc>
		</BORDEAUX>
		<NAVY public="1" get="inline" set="null" expr="0xFF000080" line="150" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF000080</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/000080.png)![color](https://www.colorhexa.com/000080.png)</haxe_doc>
		</NAVY>
		<TEAL public="1" get="inline" set="null" expr="0xFF008080" line="155" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF008080</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/008080.png)![color](https://www.colorhexa.com/008080.png)</haxe_doc>
		</TEAL>
		<FUCHSIA public="1" get="inline" set="null" expr="0xFFFF00FF" line="160" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FF00FF.png)![color](https://www.colorhexa.com/FF00FF.png)</haxe_doc>
		</FUCHSIA>
		<AQUA public="1" get="inline" set="null" expr="0xFF00FFFF" line="165" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF00FFFF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/00FFFF.png)![color](https://www.colorhexa.com/00FFFF.png)</haxe_doc>
		</AQUA>
		<LIME public="1" get="inline" set="null" expr="0xFF32CD32" line="170" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF32CD32</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/32CD32.png)![color](https://www.colorhexa.com/32CD32.png)</haxe_doc>
		</LIME>
		<CHARCOAL public="1" get="inline" set="null" expr="0xFF36454F" line="175" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF36454F</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/36454F.png)![color](https://www.colorhexa.com/36454F.png)</haxe_doc>
		</CHARCOAL>
		<ONYX public="1" get="inline" set="null" expr="0xFF353839" line="180" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF353839</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/353839.png)![color](https://www.colorhexa.com/353839.png)</haxe_doc>
		</ONYX>
		<JET public="1" get="inline" set="null" expr="0xFF343434" line="185" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF343434</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/343434.png)![color](https://www.colorhexa.com/343434.png)</haxe_doc>
		</JET>
		<JET_BLACK public="1" get="inline" set="null" expr="0xFF0E0E10" line="190" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF0E0E10</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/0E0E10.png)![color](https://www.colorhexa.com/0E0E10.png)</haxe_doc>
		</JET_BLACK>
		<ROYAL_BLUE public="1" get="inline" set="null" expr="0xFF4169E1" line="195" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF4169E1</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/4169E1.png)![color](https://www.colorhexa.com/4169E1.png)</haxe_doc>
		</ROYAL_BLUE>
		<CHARTREUSE public="1" get="inline" set="null" expr="0xFF7FFF00" line="200" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF7FFF00</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/7FFF00.png)![color](https://www.colorhexa.com/7FFF00.png)</haxe_doc>
		</CHARTREUSE>
		<CERULEAN public="1" get="inline" set="null" expr="0xFF007BA7" line="205" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF007BA7</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/007BA7.png)![color](https://www.colorhexa.com/007BA7.png)</haxe_doc>
		</CERULEAN>
		<PERIWINKLE public="1" get="inline" set="null" expr="0xFFCCCCFF" line="210" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFCCCCFF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/CCCCFF.png)![color](https://www.colorhexa.com/CCCCFF.png)</haxe_doc>
		</PERIWINKLE>
		<VERMILION public="1" get="inline" set="null" expr="0xFFE34234" line="215" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFE34234</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/E34234.png)![color](https://www.colorhexa.com/E34234.png)</haxe_doc>
		</VERMILION>
		<MAUVE public="1" get="inline" set="null" expr="0xFFE0B0FF" line="220" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFE0B0FF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/E0B0FF.png)![color](https://www.colorhexa.com/E0B0FF.png)</haxe_doc>
		</MAUVE>
		<AZURE public="1" get="inline" set="null" expr="0xFF007FFF" line="225" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF007FFF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/007FFF.png)![color](https://www.colorhexa.com/007FFF.png)</haxe_doc>
		</AZURE>
		<TANGERINE public="1" get="inline" set="null" expr="0xFFF28500" line="230" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFF28500</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/F28500.png)![color](https://www.colorhexa.com/F28500.png)</haxe_doc>
		</TANGERINE>
		<INDIGO public="1" get="inline" set="null" expr="0xFF4B0082" line="235" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF4B0082</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/4B0082.png)![color](https://www.colorhexa.com/4B0082.png)</haxe_doc>
		</INDIGO>
		<MARIGOLD public="1" get="inline" set="null" expr="0xFFEAA221" line="240" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFEAA221</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/EAA221.png)![color](https://www.colorhexa.com/EAA221.png)</haxe_doc>
		</MARIGOLD>
		<COBALT public="1" get="inline" set="null" expr="0xFF0047AB" line="245" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF0047AB</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/0047AB.png)![color](https://www.colorhexa.com/0047AB.png)</haxe_doc>
		</COBALT>
		<LAVENDER public="1" get="inline" set="null" expr="0xFFE6E6FA" line="250" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFE6E6FA</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/E6E6FA.png)![color](https://www.colorhexa.com/E6E6FA.png)</haxe_doc>
		</LAVENDER>
		<TURQUOISE public="1" get="inline" set="null" expr="0xFF40E0D0" line="255" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF40E0D0</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/40E0D0.png)![color](https://www.colorhexa.com/40E0D0.png)</haxe_doc>
		</TURQUOISE>
		<OCHRE public="1" get="inline" set="null" expr="0xFFCC7722" line="260" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFCC7722</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/CC7722.png)![color](https://www.colorhexa.com/CC7722.png)</haxe_doc>
		</OCHRE>
		<AQUAMARINE public="1" get="inline" set="null" expr="0xFF7FFFD4" line="265" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF7FFFD4</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/7FFFD4.png)![color](https://www.colorhexa.com/7FFFD4.png)</haxe_doc>
		</AQUAMARINE>
		<RUSSET public="1" get="inline" set="null" expr="0xFF80461B" line="270" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF80461B</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/80461B.png)![color](https://www.colorhexa.com/80461B.png)</haxe_doc>
		</RUSSET>
		<TOPAZ public="1" get="inline" set="null" expr="0xFFFFC87C" line="275" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFC87C</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FFC87C.png)![color](https://www.colorhexa.com/FFC87C.png)</haxe_doc>
		</TOPAZ>
		<APRICOT public="1" get="inline" set="null" expr="0xFFFBCEB1" line="280" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFBCEB1</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FBCEB1.png)![color](https://www.colorhexa.com/FBCEB1.png)</haxe_doc>
		</APRICOT>
		<AMETHYST public="1" get="inline" set="null" expr="0xFF9966CC" line="285" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF9966CC</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/9966CC.png)![color](https://www.colorhexa.com/9966CC.png)</haxe_doc>
		</AMETHYST>
		<SAFFRON public="1" get="inline" set="null" expr="0xFFF4C430" line="290" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFF4C430</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/F4C430.png)![color](https://www.colorhexa.com/F4C430.png)</haxe_doc>
		</SAFFRON>
		<LILAC public="1" get="inline" set="null" expr="0xFFC8A2C8" line="295" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFC8A2C8</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/C8A2C8.png)![color](https://www.colorhexa.com/C8A2C8.png)</haxe_doc>
		</LILAC>
		<CRIMSON public="1" get="inline" set="null" expr="0xFFDC143C" line="300" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFDC143C</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/DC143C.png)![color](https://www.colorhexa.com/DC143C.png)</haxe_doc>
		</CRIMSON>
		<SLATE public="1" get="inline" set="null" expr="0xFF708090" line="305" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF708090</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/708090.png)![color](https://www.colorhexa.com/708090.png)</haxe_doc>
		</SLATE>
		<JADE public="1" get="inline" set="null" expr="0xFF00A86B" line="310" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF00A86B</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/00A86B.png)![color](https://www.colorhexa.com/00A86B.png)</haxe_doc>
		</JADE>
		<CORAL public="1" get="inline" set="null" expr="0xFFFF7F50" line="315" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFF7F50</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FF7F50.png)![color](https://www.colorhexa.com/FF7F50.png)</haxe_doc>
		</CORAL>
		<BURGUNDY public="1" get="inline" set="null" expr="0xFF800020" line="320" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF800020</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/800020.png)![color](https://www.colorhexa.com/800020.png)</haxe_doc>
		</BURGUNDY>
		<SIENNA public="1" get="inline" set="null" expr="0xFF882D17" line="325" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF882D17</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/882D17.png)![color](https://www.colorhexa.com/882D17.png)</haxe_doc>
		</SIENNA>
		<IVORY public="1" get="inline" set="null" expr="0xFFFFFFF0" line="330" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFFFF0</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FFFFF0.png)![color](https://www.colorhexa.com/FFFFF0.png)</haxe_doc>
		</IVORY>
		<MULBERRY public="1" get="inline" set="null" expr="0xFFC54B8C" line="335" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFC54B8C</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/C54B8C.png)![color](https://www.colorhexa.com/C54B8C.png)</haxe_doc>
		</MULBERRY>
		<SANDALWOOD public="1" get="inline" set="null" expr="0xFFAA8D6F" line="340" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFAA8D6F</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/AA8D6F.png)![color](https://www.colorhexa.com/AA8D6F.png)</haxe_doc>
		</SANDALWOOD>
		<GARNET public="1" get="inline" set="null" expr="0xFF733635" line="345" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF733635</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/733635.png)![color](https://www.colorhexa.com/733635.png)</haxe_doc>
		</GARNET>
		<PEWTER public="1" get="inline" set="null" expr="0xFF8BA8B7" line="350" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF8BA8B7</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/8BA8B7.png)![color](https://www.colorhexa.com/8BA8B7.png)</haxe_doc>
		</PEWTER>
		<CARNATION public="1" get="inline" set="null" expr="0xFFFFA6C9" line="355" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFA6C9</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FFA6C9.png)![color](https://www.colorhexa.com/FFA6C9.png)</haxe_doc>
		</CARNATION>
		<CITRINE public="1" get="inline" set="null" expr="0xFFE4D00A" line="360" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFE4D00A</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/E4D00A.png)![color](https://www.colorhexa.com/E4D00A.png)</haxe_doc>
		</CITRINE>
		<CELADON public="1" get="inline" set="null" expr="0xFFACE1AF" line="365" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFACE1AF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/ACE1AF.png)![color](https://www.colorhexa.com/ACE1AF.png)</haxe_doc>
		</CELADON>
		<HELIOTROPE public="1" get="inline" set="null" expr="0xFFDF73FF" line="370" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFDF73FF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/DF73FF.png)![color](https://www.colorhexa.com/DF73FF.png)</haxe_doc>
		</HELIOTROPE>
		<PUCE public="1" get="inline" set="null" expr="0xFFCC8899" line="375" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFCC8899</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/CC8899.png)![color](https://www.colorhexa.com/CC8899.png)</haxe_doc>
		</PUCE>
		<CINNABAR public="1" get="inline" set="null" expr="0xFFE34234" line="380" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFE34234</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/E34234.png)![color](https://www.colorhexa.com/E34234.png)</haxe_doc>
		</CINNABAR>
		<VIRIDIAN public="1" get="inline" set="null" expr="0xFF40826D" line="385" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF40826D</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/40826D.png)![color](https://www.colorhexa.com/40826D.png)</haxe_doc>
		</VIRIDIAN>
		<ECRU public="1" get="inline" set="null" expr="0xFFC2B280" line="390" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFC2B280</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/C2B280.png)![color](https://www.colorhexa.com/C2B280.png)</haxe_doc>
		</ECRU>
		<ALABASTER public="1" get="inline" set="null" expr="0xFFEDEAE0" line="395" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFEDEAE0</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/EDEAE0.png)![color](https://www.colorhexa.com/EDEAE0.png)</haxe_doc>
		</ALABASTER>
		<SAPPHIRE public="1" get="inline" set="null" expr="0xFF0F52BA" line="400" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF0F52BA</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/0F52BA.png)![color](https://www.colorhexa.com/0F52BA.png)</haxe_doc>
		</SAPPHIRE>
		<PEARL public="1" get="inline" set="null" expr="0xFFEAE0C8" line="405" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFEAE0C8</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/EAE0C8.png)![color](https://www.colorhexa.com/EAE0C8.png)</haxe_doc>
		</PEARL>
		<SALMON public="1" get="inline" set="null" expr="0xFFFA8072" line="410" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFA8072</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FA8072.png)![color](https://www.colorhexa.com/FA8072.png)</haxe_doc>
		</SALMON>
		<UMBER public="1" get="inline" set="null" expr="0xFF635147" line="415" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF635147</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/635147.png)![color](https://www.colorhexa.com/635147.png)</haxe_doc>
		</UMBER>
		<TURMERIC public="1" get="inline" set="null" expr="0xFFE4D00A" line="420" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFE4D00A</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/E4D00A.png)![color](https://www.colorhexa.com/E4D00A.png)</haxe_doc>
		</TURMERIC>
		<MAHOGANY public="1" get="inline" set="null" expr="0xFFC04000" line="425" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFC04000</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/C04000.png)![color](https://www.colorhexa.com/C04000.png)</haxe_doc>
		</MAHOGANY>
		<PERSIMMON public="1" get="inline" set="null" expr="0xFFFF6347" line="430" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFF6347</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FF6347.png)![color](https://www.colorhexa.com/FF6347.png)</haxe_doc>
		</PERSIMMON>
		<ROSEWOOD public="1" get="inline" set="null" expr="0xFF65000B" line="435" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF65000B</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/65000B.png)![color](https://www.colorhexa.com/65000B.png)</haxe_doc>
		</ROSEWOOD>
		<CARAMEL public="1" get="inline" set="null" expr="0xFFFFD700" line="440" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFD700</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FFD700.png)![color](https://www.colorhexa.com/FFD700.png)</haxe_doc>
		</CARAMEL>
		<DANDELION public="1" get="inline" set="null" expr="0xFFF0E130" line="445" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFF0E130</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/F0E130.png)![color](https://www.colorhexa.com/F0E130.png)</haxe_doc>
		</DANDELION>
		<FERN public="1" get="inline" set="null" expr="0xFF71BC78" line="450" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF71BC78</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/71BC78.png)![color](https://www.colorhexa.com/71BC78.png)</haxe_doc>
		</FERN>
		<LAPIS public="1" get="inline" set="null" expr="0xFF26619C" line="455" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF26619C</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/26619C.png)![color](https://www.colorhexa.com/26619C.png)</haxe_doc>
		</LAPIS>
		<DENIM public="1" get="inline" set="null" expr="0xFF1560BD" line="460" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF1560BD</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/1560BD.png)![color](https://www.colorhexa.com/1560BD.png)</haxe_doc>
		</DENIM>
		<SABLE public="1" get="inline" set="null" expr="0xFF8E6D7B" line="465" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF8E6D7B</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/8E6D7B.png)![color](https://www.colorhexa.com/8E6D7B.png)</haxe_doc>
		</SABLE>
		<ORCHID public="1" get="inline" set="null" expr="0xFFDA70D6" line="470" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFDA70D6</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/DA70D6.png)![color](https://www.colorhexa.com/DA70D6.png)</haxe_doc>
		</ORCHID>
		<TAWNY public="1" get="inline" set="null" expr="0xFFCD5700" line="475" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFCD5700</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/CD5700.png)![color](https://www.colorhexa.com/CD5700.png)</haxe_doc>
		</TAWNY>
		<PINE public="1" get="inline" set="null" expr="0xFF01796F" line="480" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF01796F</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/01796F.png)![color](https://www.colorhexa.com/01796F.png)</haxe_doc>
		</PINE>
		<LEMON public="1" get="inline" set="null" expr="0xFFFFF700" line="485" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFF700</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FFF700.png)![color](https://www.colorhexa.com/FFF700.png)</haxe_doc>
		</LEMON>
		<SCARLET public="1" get="inline" set="null" expr="0xFFFF2400" line="490" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFF2400</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FF2400.png)![color](https://www.colorhexa.com/FF2400.png)</haxe_doc>
		</SCARLET>
		<TAUPE public="1" get="inline" set="null" expr="0xFF483C32" line="495" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF483C32</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/483C32.png)![color](https://www.colorhexa.com/483C32.png)</haxe_doc>
		</TAUPE>
		<CERISE public="1" get="inline" set="null" expr="0xFFDE3163" line="500" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFDE3163</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/DE3163.png)![color](https://www.colorhexa.com/DE3163.png)</haxe_doc>
		</CERISE>
		<AMBER public="1" get="inline" set="null" expr="0xFFFFBF00" line="505" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFBF00</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FFBF00.png)![color](https://www.colorhexa.com/FFBF00.png)</haxe_doc>
		</AMBER>
		<CINNAMON public="1" get="inline" set="null" expr="0xFFD2691E" line="510" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFD2691E</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/D2691E.png)![color](https://www.colorhexa.com/D2691E.png)</haxe_doc>
		</CINNAMON>
		<SADDLE_BROWN public="1" get="inline" set="null" expr="0xFF8B4513" line="515" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF8B4513</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/8B4513.png)![color](https://www.colorhexa.com/8B4513.png)</haxe_doc>
		</SADDLE_BROWN>
		<TOMATO public="1" get="inline" set="null" expr="0xFFFF6347" line="520" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFF6347</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FF6347.png)![color](https://www.colorhexa.com/FF6347.png)</haxe_doc>
		</TOMATO>
		<CORNSILK public="1" get="inline" set="null" expr="0xFFFFDAB9" line="525" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFFFFDAB9</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/FFDAB9.png)![color](https://www.colorhexa.com/FFDAB9.png)</haxe_doc>
		</CORNSILK>
		<VIOLET public="1" get="inline" set="null" expr="0xFF7F00FF" line="530" static="1">
			<x path="vision.ds.Color"/>
			<meta><m n=":value"><e>0xFF7F00FF</e></m></meta>
			<haxe_doc>![color](https://www.colorhexa.com/7F00FF.png)![color](https://www.colorhexa.com/7F00FF.png)</haxe_doc>
		</VIOLET>
		<red public="1" get="accessor" set="accessor" static="1"><x path="Int"/></red>
		<blue public="1" get="accessor" set="accessor" static="1"><x path="Int"/></blue>
		<green public="1" get="accessor" set="accessor" static="1"><x path="Int"/></green>
		<alpha public="1" get="accessor" set="accessor" static="1"><x path="Int"/></alpha>
		<redFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></redFloat>
		<blueFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></blueFloat>
		<greenFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></greenFloat>
		<alphaFloat public="1" get="accessor" set="accessor" static="1"><x path="Float"/></alphaFloat>
		<cyan public="1" get="accessor" set="accessor" static="1"><x path="Float"/></cyan>
		<magenta public="1" get="accessor" set="accessor" static="1"><x path="Float"/></magenta>
		<yellow public="1" get="accessor" set="accessor" static="1"><x path="Float"/></yellow>
		<black public="1" get="accessor" set="accessor" static="1"><x path="Float"/></black>
		<rgb public="1" get="accessor" set="accessor" static="1">
			<x path="vision.ds.Color"/>
			<haxe_doc>The red, green and blue channels of this color as a 24 bit integer (from 0 to 0xFFFFFF, does not include alpha values)</haxe_doc>
		</rgb>
		<hue public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The hue of the color in degrees (from 0 to 359)</haxe_doc>
		</hue>
		<saturation public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The saturation of the color (from 0 to 1)</haxe_doc>
		</saturation>
		<brightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
		</brightness>
		<lightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The lightness of the color (from 0 to 1)</haxe_doc>
		</lightness>
		<COLOR_REGEX expr="~/^(0x|#)(([A-F0-9]{2}){3,4})$/" line="572" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^(0x|#)(([A-F0-9]{2}){3,4})$/</e></m></meta>
		</COLOR_REGEX>
		<fromInt public="1" get="inline" set="null" line="580" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Create a color from the least significant four bytes of an `Int`

		@param value `Int` with bytes in the format 0xAARRGGBB
		@return	The color as a `Color`</haxe_doc>
		</fromInt>
		<fromRGBA public="1" get="inline" set="null" line="593" static="1">
			<f a="Red:Green:Blue:?Alpha" v=":::255">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
			<haxe_doc>Generate a color from integer RGB values (0 to 255)

		@param Red	The red value of the color from 0 to 255
		@param Green	The green value of the color from 0 to 255
		@param Blue	The green value of the color from 0 to 255
		@param Alpha	How opaque the color should be, from 0 to 255, default is 255
		@return The color as a Color</haxe_doc>
		</fromRGBA>
		<from8Bit public="1" get="inline" set="null" line="604" static="1">
			<f a="Value">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc><![CDATA[Generate a grayscale color from a single color channel value (0 to 255)

		@param Value	The channel value of the red, green & blue channels of the color
		@return The color as a Color]]></haxe_doc>
		</from8Bit>
		<fromRGBAFloat public="1" get="inline" set="null" line="618" static="1">
			<f a="Red:Green:Blue:?Alpha" v=":::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>Generate a color from float RGB values (0 to 1)

		@param Red	The red value of the color from 0 to 1
		@param Green	The green value of the color from 0 to 1
		@param Blue	The green value of the color from 0 to 1
		@param Alpha	How opaque the color should be, from 0 to 1, default is 1
		@return The color as a `Color`</haxe_doc>
		</fromRGBAFloat>
		<fromCMYK public="1" get="inline" set="null" line="633" static="1">
			<f a="Cyan:Magenta:Yellow:Black:?Alpha" v="::::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>Generate a color from CMYK values (0 to 1)

		@param Cyan		The cyan value of the color from 0 to 1
		@param Magenta	The magenta value of the color from 0 to 1
		@param Yellow	The yellow value of the color from 0 to 1
		@param Black		The black value of the color from 0 to 1
		@param Alpha		How opaque the color should be, from 0 to 1, default is 1
		@return The color as a `Color`</haxe_doc>
		</fromCMYK>
		<fromHSB public="1" set="method" line="647" static="1">
			<f a="Hue:Saturation:Brightness:?Alpha" v=":::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>Generate a color from HSB (aka HSV) components.

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright (default).
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255, default is 1.
		@return	The color as a `Color`</haxe_doc>
		</fromHSB>
		<fromHSL public="1" get="inline" set="null" line="661" static="1">
			<f a="Hue:Saturation:Lightness:?Alpha" v=":::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>Generate a color from HSL components.

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Lightness	A number between 0 and 1, indicating the lightness of the color
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255, default is 1.
		@return	The color as a `Color`</haxe_doc>
		</fromHSL>
		<fromString public="1" set="method" line="681" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Null"><x path="vision.ds.Color"/></x>
			</f>
			<haxe_doc><![CDATA[Parses a `String` and returns a `Color` or `null` if the `String` couldn't be parsed.

		Examples (input -> output in hex):

		- `0x00FF00`    -> `0xFF00FF00`
		- `0xAA4578C2`  -> `0xAA4578C2`
		- `#0000FF`     -> `0xFF0000FF`
		- `#3F000011`   -> `0x3F000011`
		- `GRAY`        -> `0xFF808080`
		- `blue`        -> `0xFF0000FF`

		@param	str 	The string to be parsed
		@return	A `Color` or `null` if the `String` couldn't be parsed]]></haxe_doc>
		</fromString>
		<getHSBColorWheel public="1" set="method" line="702" static="1">
			<f a="?Alpha" v="255">
				<x path="Int"/>
				<c path="Array"><x path="vision.ds.Color"/></c>
			</f>
			<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
			<haxe_doc>Get HSB color wheel values in an array which will be 360 elements in size

		@param	Alpha Alpha value for each color of the color wheel, between 0 (transparent) and 255 (opaque) (default)
		@return	HSB color wheel as Array of Colors</haxe_doc>
		</getHSBColorWheel>
		<interpolate public="1" get="inline" set="null" line="714" static="1">
			<f a="Color1:Color2:?Factor" v="::0.5">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Factor : 0.5 }</e></m></meta>
			<haxe_doc>Get an interpolated color based on two different colors.

		@param 	Color1 The first color
		@param 	Color2 The second color
		@param 	Factor Value from 0 to 1 representing how much to shift Color1 toward Color2, default is 0.5
		@return	The interpolated color as a `Color`</haxe_doc>
		</interpolate>
		<gradient public="1" set="method" line="732" static="1">
			<f a="Color1:Color2:Steps:?Ease">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
				<c path="Array"><x path="vision.ds.Color"/></c>
			</f>
			<haxe_doc>Create a gradient from one color to another

		@param Color1 The color to shift from
		@param Color2 The color to shift to
		@param Steps How many colors the gradient should have
		@param Ease An optional easing function.
		@return An array of colors of length Steps, shifting from Color1 to Color2</haxe_doc>
		</gradient>
		<makeRandom public="1" get="inline" set="null" line="754" static="1">
			<f a="?alphaLock:?alphaValue" v="true:255">
				<x path="Bool"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ alphaValue : 255, alphaLock : true }</e></m></meta>
			<haxe_doc>Generate a random color, with randomized red, green, blue and optionally alpha values.

		@param alphaLock When set to `false`, the alpha channel will get a randomized value to. `true` by default, which makes a color with `alpha = 255`.
		@param alphaValue When `alphaLock` is true, you can provide this value to override the default alpha value. Since the first argument is optional, you can do `Color.makeRandom(128)` (a random color with `alpha` set to `128`)</haxe_doc>
		</makeRandom>
		<multiply public="1" get="inline" set="null" line="762" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A * B</e></m></meta>
			<haxe_doc>Multiply the RGB and alpha channels of two Colors</haxe_doc>
		</multiply>
		<add public="1" get="inline" set="null" line="771" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
			<haxe_doc>Add the RGB and alpha channels of two Colors</haxe_doc>
		</add>
		<subtract public="1" get="inline" set="null" line="779" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
			<haxe_doc>Subtract the RGB and alpha channels of one Color from another</haxe_doc>
		</subtract>
		<divide public="1" get="inline" set="null" line="789" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A / B</e></m></meta>
			<haxe_doc>* Divide the RGB and alpha channels of one Color from another.
	 * 
	 * If a color channel value on the right hand side is `0`, the left hand side's channel will get divided by `1`.</haxe_doc>
		</divide>
		<getComplementHarmony public="1" get="inline" set="null" line="800" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Returns a Complementary Color Harmony of this color.
		A complementary hue is one directly opposite the color given on the color wheel

		@return	The complimentary color</haxe_doc>
		</getComplementHarmony>
		<getAnalogousHarmony public="1" get="inline" set="null" line="811" static="1">
			<f a="this:?Threshold" v=":30">
				<x path="Int"/>
				<x path="Int"/>
				<t path="vision.ds.Harmony"/>
			</f>
			<meta><m n=":value"><e>{ Threshold : 30 }</e></m></meta>
			<haxe_doc>Returns an Analogous Color Harmony for the given color.
		An Analogous harmony are hues adjacent to each other on the color wheel

		@param	Threshold Control how adjacent the colors will be (default +- 30 degrees)
		@return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
		</getAnalogousHarmony>
		<getSplitComplementHarmony public="1" get="inline" set="null" line="825" static="1">
			<f a="this:?Threshold" v=":30">
				<x path="Int"/>
				<x path="Int"/>
				<t path="vision.ds.Harmony"/>
			</f>
			<meta><m n=":value"><e>{ Threshold : 30 }</e></m></meta>
			<haxe_doc>Returns an Split Complement Color Harmony for this color.
		A Split Complement harmony are the two hues on either side of the color's Complement

		@param	Threshold Control how adjacent the colors will be to the Complement (default +- 30 degrees)
		@return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
		</getSplitComplementHarmony>
		<getTriadicHarmony public="1" get="inline" set="null" line="839" static="1">
			<f a="this">
				<x path="Int"/>
				<t path="vision.ds.TriadicHarmony"/>
			</f>
			<haxe_doc>Returns a Triadic Color Harmony for this color. A Triadic harmony are 3 hues equidistant
		from each other on the color wheel.

		@return 	Object containing 3 properties: color1 (the original color), color2 and color3 (the equidistant colors)</haxe_doc>
		</getTriadicHarmony>
		<to24Bit public="1" get="inline" set="null" line="851" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Return a 24 bit version of this color (i.e. without an alpha value)

		@return A 24 bit version of this color</haxe_doc>
		</to24Bit>
		<toHexString public="1" get="inline" set="null" line="862" static="1">
			<f a="this:?Alpha:?Prefix" v=":true:true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ Prefix : true, Alpha : true }</e></m></meta>
			<haxe_doc>Return a String representation of the color in the format

		@param Alpha Whether to include the alpha value in the hes string
		@param Prefix Whether to include "0x" prefix at start of string
		@return	A string of length 10 in the format 0xAARRGGBB</haxe_doc>
		</toHexString>
		<toWebString public="1" get="inline" set="null" line="871" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Return a String representation of the color in the format #RRGGBB

		@return	A string of length 7 in the format #RRGGBB</haxe_doc>
		</toWebString>
		<darken public="1" set="method" line="881" static="1">
			<f a="this:?Factor" v=":0.2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Factor : 0.2 }</e></m></meta>
			<haxe_doc>Get a darkened version of this color

		@param	Factor Value from 0 to 1 of how much to progress toward black.
		@return 	A darkened version of this color</haxe_doc>
		</darken>
		<lighten public="1" get="inline" set="null" line="894" static="1">
			<f a="this:?Factor" v=":0.2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Factor : 0.2 }</e></m></meta>
			<haxe_doc>Get a lightened version of this color

		@param	Factor Value from 0 to 1 of how much to progress toward white.
		@return 	A lightened version of this color</haxe_doc>
		</lighten>
		<invert public="1" get="inline" set="null" line="906" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Get the inversion of this color

		@return The inversion of this color</haxe_doc>
		</invert>
		<setRGBA public="1" get="inline" set="null" line="922" static="1">
			<f a="this:Red:Green:Blue:?Alpha" v="::::255">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
			<haxe_doc>Set RGB values as integers (0 to 255)

		@param Red	The red value of the color from 0 to 255
		@param Green	The green value of the color from 0 to 255
		@param Blue	The green value of the color from 0 to 255
		@param Alpha	How opaque the color should be, from 0 to 255, default is 255
		@return This color</haxe_doc>
		</setRGBA>
		<setRGBAFloat public="1" get="inline" set="null" line="939" static="1">
			<f a="this:Red:Green:Blue:?Alpha" v="::::1">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>Set RGB values as floats (0 to 1)

		@param Red	The red value of the color from 0 to 1
		@param Green	The green value of the color from 0 to 1
		@param Blue	The green value of the color from 0 to 1
		@param Alpha	How opaque the color should be, from 0 to 1, default is 1
		@return This color</haxe_doc>
		</setRGBAFloat>
		<setCMYK public="1" get="inline" set="null" line="957" static="1">
			<f a="this:Cyan:Magenta:Yellow:Black:?Alpha" v=":::::1">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>Set CMYK values as floats (0 to 1)

		@param Cyan		The cyan value of the color from 0 to 1
		@param Magenta	The magenta value of the color from 0 to 1
		@param Yellow	The yellow value of the color from 0 to 1
		@param Black		The black value of the color from 0 to 1
		@param Alpha		How opaque the color should be, from 0 to 1, default is 1
		@return This color</haxe_doc>
		</setCMYK>
		<setHSB public="1" get="inline" set="null" line="974" static="1">
			<f a="this:Hue:Saturation:Brightness:Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Set HSB (aka HSV) components

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
		@return	This color</haxe_doc>
		</setHSB>
		<setHSL public="1" get="inline" set="null" line="989" static="1">
			<f a="this:Hue:Saturation:Lightness:Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Set HSL components.

		@param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
		@param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
		@param	Lightness	A number between 0 and 1, indicating the lightness of the color
		@param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255
		@return	This color</haxe_doc>
		</setHSL>
		<setHSChromaMatch get="inline" set="null" line="998" static="1">
			<f a="this:Hue:Saturation:Chroma:Match:Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
		</setHSChromaMatch>
		<grayscale public="1" get="inline" set="null" line="1019" static="1">
			<f a="this:?simple" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ simple : false }</e></m></meta>
			<haxe_doc>@param simple When enabled, gets the gray by averaging this color's channel values, instead of using a special ratio for more accurate grayscaling. Defaults to `false`</haxe_doc>
		</grayscale>
		<blackOrWhite public="1" get="inline" set="null" line="1029" static="1">
			<f a="this:?threshold" v=":128">
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":value"><e>{ threshold : 128 }</e></m></meta>
			<haxe_doc>Turns this color black/white, according to the values of the color channels.

		@param threshold The threshold for converting to black and white: `threshold` is the maximum average of the three color components, that will still be considered black. `threshold` is a value between 0 and 255. The higher the value, the more "sensitive" the conversion. The default value is 128.</haxe_doc>
		</blackOrWhite>
		<_new public="1" get="inline" set="null" line="1041" static="1">
			<f a="?value" v="0">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta>
				<m n=":value"><e>{ value : 0 }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<getThis get="inline" set="null" line="1045" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></getThis>
		<validate get="inline" set="null" line="1053" static="1"><f a="this">
	<x path="Int"/>
	<x path="Void"/>
</f></validate>
		<get_red get="inline" set="null" line="1059" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_red>
		<get_green get="inline" set="null" line="1063" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_green>
		<get_blue get="inline" set="null" line="1067" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_blue>
		<get_alpha get="inline" set="null" line="1071" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_alpha>
		<get_redFloat get="inline" set="null" line="1075" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_redFloat>
		<get_greenFloat get="inline" set="null" line="1079" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_greenFloat>
		<get_blueFloat get="inline" set="null" line="1083" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_blueFloat>
		<get_alphaFloat get="inline" set="null" line="1087" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_alphaFloat>
		<set_red get="inline" set="null" line="1091" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_red>
		<set_green get="inline" set="null" line="1098" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_green>
		<set_blue get="inline" set="null" line="1105" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_blue>
		<set_alpha get="inline" set="null" line="1112" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_alpha>
		<set_redFloat get="inline" set="null" line="1119" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_redFloat>
		<set_greenFloat get="inline" set="null" line="1124" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_greenFloat>
		<set_blueFloat get="inline" set="null" line="1129" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_blueFloat>
		<set_alphaFloat get="inline" set="null" line="1134" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_alphaFloat>
		<get_cyan get="inline" set="null" line="1139" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_cyan>
		<get_magenta get="inline" set="null" line="1143" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_magenta>
		<get_yellow get="inline" set="null" line="1147" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_yellow>
		<get_black get="inline" set="null" line="1151" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_black>
		<set_cyan get="inline" set="null" line="1155" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_cyan>
		<set_magenta get="inline" set="null" line="1160" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_magenta>
		<set_yellow get="inline" set="null" line="1165" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_yellow>
		<set_black get="inline" set="null" line="1170" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_black>
		<get_hue set="method" line="1175" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_hue>
		<get_brightness get="inline" set="null" line="1185" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_brightness>
		<get_saturation get="inline" set="null" line="1189" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_saturation>
		<get_lightness get="inline" set="null" line="1193" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></get_lightness>
		<set_hue get="inline" set="null" line="1197" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_hue>
		<set_saturation get="inline" set="null" line="1202" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_saturation>
		<set_brightness get="inline" set="null" line="1207" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_brightness>
		<set_lightness get="inline" set="null" line="1212" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_lightness>
		<set_rgb get="inline" set="null" line="1217" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="vision.ds.Color"/>
	<x path="vision.ds.Color"/>
</f></set_rgb>
		<get_rgb get="inline" set="null" line="1223" static="1"><f a="this">
	<x path="Int"/>
	<x path="vision.ds.Color"/>
</f></get_rgb>
		<maxColor get="inline" set="null" line="1227" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></maxColor>
		<minColor get="inline" set="null" line="1231" static="1"><f a="this">
	<x path="Int"/>
	<x path="Float"/>
</f></minColor>
		<boundChannel get="inline" set="null" line="1235" static="1"><f a="this:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></boundChannel>
		<toString public="1" set="method" line="1239" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<toInt public="1" set="method" line="1247" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></toInt>
		<color_greater_than_color get="inline" set="null" line="1256" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</color_greater_than_color>
		<color_greater_than_int get="inline" set="null" line="1261" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</color_greater_than_int>
		<int_greater_than_color get="inline" set="null" line="1266" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</int_greater_than_color>
		<color_greater_than_float get="inline" set="null" line="1271" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</color_greater_than_float>
		<float_greater_than_color get="inline" set="null" line="1276" static="1">
			<f a="lhs:rhs">
				<x path="Float"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</float_greater_than_color>
		<color_greater_than_equal_color get="inline" set="null" line="1281" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</color_greater_than_equal_color>
		<color_greater_than_equal_int get="inline" set="null" line="1286" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</color_greater_than_equal_int>
		<int_greater_than_equal_color get="inline" set="null" line="1291" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</int_greater_than_equal_color>
		<color_greater_than_equal_float get="inline" set="null" line="1296" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</color_greater_than_equal_float>
		<float_greater_than_equal_color get="inline" set="null" line="1301" static="1">
			<f a="lhs:rhs">
				<x path="Float"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</float_greater_than_equal_color>
		<color_less_than_color get="inline" set="null" line="1306" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</color_less_than_color>
		<color_less_than_int get="inline" set="null" line="1311" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</color_less_than_int>
		<int_less_than_color get="inline" set="null" line="1316" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</int_less_than_color>
		<color_less_than_float get="inline" set="null" line="1321" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</color_less_than_float>
		<float_less_than_color get="inline" set="null" line="1326" static="1">
			<f a="lhs:rhs">
				<x path="Float"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</float_less_than_color>
		<color_less_than_equal_color get="inline" set="null" line="1331" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</color_less_than_equal_color>
		<color_less_than_equal_int get="inline" set="null" line="1336" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</color_less_than_equal_int>
		<int_less_than_equal_color get="inline" set="null" line="1341" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</int_less_than_equal_color>
		<color_less_than_equal_float get="inline" set="null" line="1346" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</color_less_than_equal_float>
		<float_less_than_equal_color get="inline" set="null" line="1351" static="1">
			<f a="lhs:rhs">
				<x path="Float"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</float_less_than_equal_color>
		<color_equal_color get="inline" set="null" line="1356" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A == B</e></m></meta>
		</color_equal_color>
		<color_equal_int get="inline" set="null" line="1361" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A == B</e></m></meta>
		</color_equal_int>
		<int_equal_color get="inline" set="null" line="1366" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A == B</e></m></meta>
		</int_equal_color>
		<color_equal_float get="inline" set="null" line="1371" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A == B</e></m></meta>
		</color_equal_float>
		<float_equal_color get="inline" set="null" line="1376" static="1">
			<f a="lhs:rhs">
				<x path="Float"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A == B</e></m></meta>
		</float_equal_color>
		<color_not_equal_color get="inline" set="null" line="1381" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A != B</e></m></meta>
		</color_not_equal_color>
		<color_not_equal_int get="inline" set="null" line="1386" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A != B</e></m></meta>
		</color_not_equal_int>
		<int_not_equal_color get="inline" set="null" line="1391" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A != B</e></m></meta>
		</int_not_equal_color>
		<color_not_equal_float get="inline" set="null" line="1396" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A != B</e></m></meta>
		</color_not_equal_float>
		<float_not_equal_color get="inline" set="null" line="1401" static="1">
			<f a="lhs:rhs">
				<x path="Float"/>
				<x path="vision.ds.Color"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A != B</e></m></meta>
		</float_not_equal_color>
		<color_bitwise_and_color get="inline" set="null" line="1406" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
		</color_bitwise_and_color>
		<color_bitwise_and_int get="inline" set="null" line="1411" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
		</color_bitwise_and_int>
		<int_bitwise_and_color get="inline" set="null" line="1416" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
		</int_bitwise_and_color>
		<color_bitwise_or_color get="inline" set="null" line="1421" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A | B</e></m></meta>
		</color_bitwise_or_color>
		<color_bitwise_or_int get="inline" set="null" line="1426" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A | B</e></m></meta>
		</color_bitwise_or_int>
		<int_bitwise_or_color get="inline" set="null" line="1431" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A | B</e></m></meta>
		</int_bitwise_or_color>
		<color_bitwise_xor_color get="inline" set="null" line="1436" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A ^ B</e></m></meta>
		</color_bitwise_xor_color>
		<color_bitwise_xor_int get="inline" set="null" line="1441" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A ^ B</e></m></meta>
		</color_bitwise_xor_int>
		<int_bitwise_xor_color get="inline" set="null" line="1446" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e>A ^ B</e></m></meta>
		</int_bitwise_xor_color>
		<color_bitwise_left_shift_color get="inline" set="null" line="1451" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
		</color_bitwise_left_shift_color>
		<color_bitwise_left_shift_int get="inline" set="null" line="1456" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
		</color_bitwise_left_shift_int>
		<int_bitwise_left_shift_color get="inline" set="null" line="1461" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
		</int_bitwise_left_shift_color>
		<color_bitwise_right_shift_color get="inline" set="null" line="1466" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
		</color_bitwise_right_shift_color>
		<color_bitwise_right_shift_int get="inline" set="null" line="1471" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
		</color_bitwise_right_shift_int>
		<int_bitwise_right_shift_color get="inline" set="null" line="1476" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
		</int_bitwise_right_shift_color>
		<color_bitwise_unsigned_right_shift_color get="inline" set="null" line="1481" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
		</color_bitwise_unsigned_right_shift_color>
		<color_bitwise_unsigned_right_shift_int get="inline" set="null" line="1486" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
		</color_bitwise_unsigned_right_shift_int>
		<int_bitwise_unsigned_right_shift_color get="inline" set="null" line="1491" static="1">
			<f a="lhs:rhs">
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
		</int_bitwise_unsigned_right_shift_color>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="vision.ds.Harmony" params="" file="src/vision/ds/Color.hx" module="vision.ds.Color"><a>
	<warmer><x path="vision.ds.Color"/></warmer>
	<original><x path="vision.ds.Color"/></original>
	<colder><x path="vision.ds.Color"/></colder>
</a></typedef>
	<typedef path="vision.ds.TriadicHarmony" params="" file="src/vision/ds/Color.hx" module="vision.ds.Color"><a>
	<color3><x path="vision.ds.Color"/></color3>
	<color2><x path="vision.ds.Color"/></color2>
	<color1><x path="vision.ds.Color"/></color1>
</a></typedef>
	<class path="vision.ds.Heatmap" params="" file="src/vision/ds/Heatmap.hx">
		<data public="1"><c path="vision.ds.Array2D"><x path="Float"/></c></data>
		<baseValue public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>The value each pixel in the heatmap will be set to.</haxe_doc>
		</baseValue>
		<upperBound public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>A value representing the upper bound of each element in the heatmap.  
		To disable this, set it to `null`.</haxe_doc>
		</upperBound>
		<lowerBound public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>A value representing the lower bound of each element in the heatmap.  
		To disable this, set it to `null`.</haxe_doc>
		</lowerBound>
		<set public="1" set="method" line="38"><f a="x:y:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<get public="1" set="method" line="42"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></get>
		<getDataRange public="1" set="method" line="46"><f a=""><a>
	<min><x path="Float"/></min>
	<max><x path="Float"/></max>
</a></f></getDataRange>
		<getLocalMaximums public="1" set="method" line="56">
			<f a="?threshold:?windowSize" v="null:3">
				<x path="Float"/>
				<x path="Int"/>
				<c path="Array"><x path="vision.ds.IntPoint2D"/></c>
			</f>
			<meta><m n=":value"><e>{ windowSize : 3, threshold : null }</e></m></meta>
		</getLocalMaximums>
		<getLocalMinimums public="1" set="method" line="81">
			<f a="?threshold:?windowSize" v="null:3">
				<x path="Float"/>
				<x path="Int"/>
				<c path="Array"><x path="vision.ds.IntPoint2D"/></c>
			</f>
			<meta><m n=":value"><e>{ windowSize : 3, threshold : null }</e></m></meta>
		</getLocalMinimums>
		<normalize public="1" set="method" line="106">
			<f a="?minValue:?maxValue" v="0:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ maxValue : 1, minValue : 0 }</e></m></meta>
		</normalize>
		<visualize public="1" set="method" line="116">
			<f a="?lowerColor:?upperColor" v="Color.BLACK:Color.WHITE">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ upperColor : Color.WHITE, lowerColor : Color.BLACK }</e></m></meta>
		</visualize>
		<new public="1" set="method" line="32">
			<f a="width:height:?baseValue" v="::0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ baseValue : 0 }</e></m></meta>
		</new>
		<haxe_doc>A class used both for matrix data visualization using colors, and for finding
	certain elements in a matrix, e.g. finding local maximums/minimums.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.ds.Histogram" params="" file="src/vision/ds/Histogram.hx">
		<underlying><c path="Array"><x path="Null"><x path="Int"/></x></c></underlying>
		<length public="1" get="accessor" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>The amount of items in this `Histogram`</haxe_doc>
		</length>
		<median public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The value at the middle of this `Histogram`.</haxe_doc>
		</median>
		<increment public="1" set="method" line="31">
			<f a="cell">
				<x path="Int"/>
				<c path="vision.ds.Histogram"/>
			</f>
			<haxe_doc>Increments the value at `cell`.</haxe_doc>
		</increment>
		<decrement public="1" set="method" line="39">
			<f a="cell">
				<x path="Int"/>
				<c path="vision.ds.Histogram"/>
			</f>
			<haxe_doc>Decrements the value at `cell`.</haxe_doc>
		</decrement>
		<get_median set="method" line="44"><f a=""><x path="Int"/></f></get_median>
		<get_length set="method" line="56"><f a=""><x path="Int"/></f></get_length>
		<new public="1" set="method" line="24">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new, empty `Histogram`</haxe_doc>
		</new>
		<haxe_doc>* A 2D graph, usually represents a sorted distribution of numerical values.</haxe_doc>
	</class>
	<abstract path="vision.ds.Image" params="" file="src/vision/ds/Image.hx">
		<from><icast field="from2DArray"><c path="Array"><c path="Array"><x path="vision.ds.Color"/></c></c></icast></from>
		<this><x path="vision.ds.ByteArray"/></this>
		<to>
			<icast field="to2DArray"><c path="Array"><c path="Array"><x path="vision.ds.Color"/></c></c></icast>
			<icast field="toBytes"><x path="vision.ds.ByteArray"/></icast>
		</to>
		<haxe_doc>Represents a 2D image, as a matrix of Colors.</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="vision.ds._Image.Image_Impl_" params="" file="src/vision/ds/Image.hx" private="1" module="vision.ds.Image" final="1">
	<OFFSET expr="11" line="39" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>11</e></m></meta>
		<haxe_doc><![CDATA[the first 2 bytes represent image width,  
		the next 4 bytes are the `x` & `y` position of an image view,  
		the next 4 bytes are the `width` & `height` of an image view,
		the last byte represents view shape]]></haxe_doc>
	</OFFSET>
	<WIDTH_BYTES expr="2" line="41" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>2</e></m></meta>
	</WIDTH_BYTES>
	<VIEW_XY_BYTES expr="4" line="42" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
	</VIEW_XY_BYTES>
	<VIEW_WH_BYTES expr="4" line="43" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
	</VIEW_WH_BYTES>
	<VIEW_SHAPE_BYTES expr="1" line="44" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>1</e></m></meta>
	</VIEW_SHAPE_BYTES>
	<DATA_GAP expr="2" line="45" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>2</e></m></meta>
	</DATA_GAP>
	<underlying public="1" get="accessor" set="null" static="1">
		<x path="vision.ds.ByteArray"/>
		<haxe_doc>Returns the underlying type of this abstract.</haxe_doc>
	</underlying>
	<get_underlying get="inline" set="null" line="52" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="vision.ds.ByteArray"/>
</f></get_underlying>
	<width public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<haxe_doc>The width of the image.</haxe_doc>
	</width>
	<get_width get="inline" set="null" line="67" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
</f></get_width>
	<height public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<haxe_doc>The height of the image.</haxe_doc>
	</height>
	<get_height get="inline" set="null" line="83" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
</f></get_height>
	<view public="1" get="accessor" set="accessor" static="1">
		<c path="vision.ds.ImageView"/>
		<haxe_doc>The current image's `ImageView`. You can get/set this field to change the view, but changing it's values won't effect anything.

		`ImageView`s disallow setting pixels on parts outside of the view. That's useful when you want to operate
		on a certain part of the image, without modifying other portions/copying pixels around.</haxe_doc>
	</view>
	<get_view get="inline" set="null" line="99" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<c path="vision.ds.ImageView"/>
</f></get_view>
	<set_view get="inline" set="null" line="103" static="1"><f a="this:view">
	<x path="vision.ds.ByteArray"/>
	<c path="vision.ds.ImageView"/>
	<c path="vision.ds.ImageView"/>
</f></set_view>
	<_new public="1" get="inline" set="null" line="115" static="1">
		<f a="width:height:?color" v="::0x00000000">
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Image"/>
		</f>
		<meta>
			<m n=":value"><e>{ color : 0x00000000 }</e></m>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new image of the given size. Once is created, the image cannot be resized.

		@param width The width of the image.
		@param height The height of the image.
		@param color The color to fill the image with. if unspecified, the image is transparent.</haxe_doc>
	</_new>
	<getColorFromStartingBytePos get="inline" set="null" line="133" static="1"><f a="this:position">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="vision.ds.Color"/>
</f></getColorFromStartingBytePos>
	<setColorFromStartingBytePos get="inline" set="null" line="138" static="1"><f a="this:position:c">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="vision.ds.Color"/>
	<x path="vision.ds.Color"/>
</f></setColorFromStartingBytePos>
	<getPixel public="1" get="inline" set="null" line="169" static="1">
		<f a="this:x:y">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Gets the color of the pixel at the given coordinates.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@throws OutOfBounds if the coordinates are outside the bounds of the image.
		@return The color of the pixel at the given coordinates.</haxe_doc>
	</getPixel>
	<getSafePixel public="1" get="inline" set="null" line="190" static="1">
		<f a="this:x:y">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Gets the color of the pixel at the given coordinates.

		Coordinates outside the bounds of the image are allowed.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@return The color of the pixel at the given coordinates.</haxe_doc>
	</getSafePixel>
	<getUnsafePixel get="inline" set="null" line="195" static="1">
		<f a="this:x:y">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<meta><m n=":allow"><e>vision</e></m></meta>
	</getUnsafePixel>
	<getFloatingPixel public="1" get="inline" set="null" line="244" static="1">
		<f a="this:x:y">
			<x path="vision.ds.ByteArray"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc><![CDATA[Gets the color of the pixel at the given coordinates.
		These coordinates can also be of type `Float`, in which case
		the value returned should be an interpolation of the surrounding, physical pixels.

		**This Operation is safe - Out of bound coordinates won't throw an error, and will instead use the closest pixel.**

		### How Does This Work?

		Lets say we want the pixel at `(0.5, 0.5)`:
		```
		(0,0)   (1,0)                                     
														 
			  Â·     < Y (0.5)                      
														 
		(0,1)   (1,1)                                     
			  ^                                           
			X (0.5)                                        
		```

		First, we're going to calculate the actual fraction - the means, extracting the numbers after the decimal point:

			final xFraction = x - Std.int(x);
			final yFraction = y - Std.int(y);


		Then, we just multiply each of the surrounding pixel's value by it's distance from the initial X value (using `xFraction` and `yFraction`):

			final pixelsBeforeYMultiplier = 1 - yFraction, pixelsAfterYMultiplier = yFraction;
			final pixelsBeforeXMultiplier = 1 - xFraction, pixelsAfterXMultiplier = xFraction;
			final bottomLayer = pixelsBeforeYMultiplier * (pixelsBeforeXMultiplier * getPixel(Std.int(x), Std.int(y)) + pixelsAfterXMultiplier * getPixel(Std.int(x) + 1, Std.int(y)));
			final topLayer = pixelsAfterYMultiplier * (pixelsBeforeXMultiplier * getPixel(Std.int(x), Std.int(y) + 1) + pixelsAfterXMultiplier * getPixel(Std.int(x) + 1, Std.int(y) + 1));


		And add the two layers to get the result:


			var finalColor:Color = Std.int(bottomLayer + topLayer);


		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@return The color of the pixel at the given coordinates.]]></haxe_doc>
	</getFloatingPixel>
	<setPixel public="1" get="inline" set="null" line="275" static="1">
		<f a="this:x:y:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Sets the color of the pixel at the given coordinates.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.
		@param color The color to set the pixel to.

		@throws OutOfBounds if the coordinates are outside the bounds of the image.</haxe_doc>
	</setPixel>
	<setSafePixel public="1" get="inline" set="null" line="293" static="1"><f a="this:x:y:color">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="vision.ds.Color"/>
	<x path="Void"/>
</f></setSafePixel>
	<setFloatingPixel public="1" get="inline" set="null" line="305" static="1"><f a="this:x:y:color">
	<x path="vision.ds.ByteArray"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="vision.ds.Color"/>
	<x path="Void"/>
</f></setFloatingPixel>
	<setUnsafePixel get="inline" set="null" line="323" static="1">
		<f a="this:x:y:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<meta><m n=":allow"><e>vision</e></m></meta>
	</setUnsafePixel>
	<paintPixel public="1" get="inline" set="null" line="348" static="1">
		<f a="this:x:y:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Sets the color of a pixel, but doesn't completely overwrite the pixel:

		- if the color of the new pixel is the same as the old pixel, the old pixel is kept.
		- if the alpha of the new pixel is 0, the old pixel is kept.
		- if the alpha of the new pixel is 255, the new pixel is kept.
		- if the alpha of the new pixel is between 0 and 255, the new pixel is blended with the old pixel.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.
		@param color The color to set the pixel to. Pay attention to the alpha value.
		@throws OutOfBounds if the coordinates are outside the bounds of the image.</haxe_doc>
	</paintPixel>
	<paintFloatingPixel public="1" get="inline" set="null" line="367" static="1"><f a="this:x:y:color">
	<x path="vision.ds.ByteArray"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="vision.ds.Color"/>
	<x path="Void"/>
</f></paintFloatingPixel>
	<paintSafePixel public="1" get="inline" set="null" line="400" static="1"><f a="this:x:y:color">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></paintSafePixel>
	<paintUnsafePixel get="inline" set="null" line="405" static="1">
		<f a="this:x:y:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<meta><m n=":allow"><e>vision</e></m></meta>
	</paintUnsafePixel>
	<hasPixel public="1" get="inline" set="null" line="431" static="1">
		<f a="this:x:y">
			<x path="vision.ds.ByteArray"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Checks if the given coordinates are within the bounds of the image.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@return True if the coordinates are within the bounds of the image.</haxe_doc>
	</hasPixel>
	<movePixel public="1" set="method" line="450" static="1">
		<f a="this:fromX:fromY:toX:toY:oldPixelResetColor">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Moves the pixel at `(fromX, fromY)` to `(toX, toY)` and resets the color at `(fromX, fromY)`.

		@param fromX The x-coordinate of the pixel to move.
		@param fromY The y-coordinate of the pixel to move.
		@param toX The x-coordinate of the pixel to set to the color of `(fromX, fromY)` to.
		@param toY The y-coordinate of the pixel to set to the color of `(fromX, fromY)` to.
		@param oldPixelResetColor After moving the pixel, the color of the pixel at `(fromX, fromY)` resets to `0x00000000`. To change that color, set this parameter</haxe_doc>
	</movePixel>
	<moveSafePixel public="1" set="method" line="464" static="1">
		<f a="this:fromX:fromY:toX:toY:oldPixelResetColor">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Moves the pixel at `(fromX, fromY)` to `(toX, toY)` and resets the color at `(fromX, fromY)`. Values outside teh bounds of `this` image are allowed.

		@param fromX The x-coordinate of the pixel to move.
		@param fromY The y-coordinate of the pixel to move.
		@param toX The x-coordinate of the pixel to set to the color of `(fromX, fromY)` to.
		@param toY The y-coordinate of the pixel to set to the color of `(fromX, fromY)` to.
		@param oldPixelResetColor After moving the pixel, the color of the pixel at `(fromX, fromY)` resets to `0x00000000`. To change that color, set this parameter</haxe_doc>
	</moveSafePixel>
	<moveFloatingPixel public="1" set="method" line="480" static="1">
		<f a="this:fromX:fromY:toX:toY:oldPixelResetColor">
			<x path="vision.ds.ByteArray"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Moves the pixel at `(fromX, fromY)` to `(toX, toY)` and resets the color at `(fromX, fromY)`. Fractional values are allowed.
		
		This Operation is safe - Out of bound coordinates won't throw an error, and will instead use the closest pixel.

		@param fromX The x-coordinate of the pixel to move.
		@param fromY The y-coordinate of the pixel to move.
		@param toX The x-coordinate of the pixel to set to the color of `(fromX, fromY)` to.
		@param toY The y-coordinate of the pixel to set to the color of `(fromX, fromY)` to.
		@param oldPixelResetColor After moving the pixel, the color of the pixel at `(fromX, fromY)` resets to `0x00000000`. To change that color, set this parameter</haxe_doc>
	</moveFloatingPixel>
	<moveUnsafePixel public="1" set="method" line="485" static="1"><f a="this:fromX:fromY:toX:toY:oldPixelResetColor">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="vision.ds.Color"/>
	<x path="Void"/>
</f></moveUnsafePixel>
	<copyPixelFrom public="1" get="inline" set="null" line="500" static="1">
		<f a="this:image:x:y">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.Image"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Copies a pixel from the given image to this image.

		@param image The image to copy the pixel from.
		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@throws OutOfBounds if the given coordinates are outside the bounds of one or both of the images
		@return The color of the pixel at the given coordinates.</haxe_doc>
	</copyPixelFrom>
	<copyPixelTo public="1" get="inline" set="null" line="516" static="1">
		<f a="this:image:x:y">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.Image"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
		</f>
		<haxe_doc>Copies a pixel from the given image to this image.

		@param image The image to copy the pixel to.
		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@throws OutOfBounds if the given coordinates are outside the bounds of one or both of the images
		@return The color of the pixel at the given coordinates.</haxe_doc>
	</copyPixelTo>
	<getImagePortion public="1" get="inline" set="null" line="528" static="1">
		<f a="this:rect">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.Rectangle"/>
			<x path="vision.ds.Image"/>
		</f>
		<haxe_doc>Returns a portion of the image, specified by a rectangle.

		@param rect The rectangle specifying the portion of the image to return.

		@throws OutOfBounds if the portion of the image to get is outside the bounds of the original image.
		@return A new image containing the specified portion of the original image.</haxe_doc>
	</getImagePortion>
	<setImagePortion public="1" get="inline" set="null" line="546" static="1">
		<f a="this:rect:image">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.Rectangle"/>
			<x path="vision.ds.Image"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Sets a portion of the image, specified by a rectangle, to another image.

		@param rect The rectangle specifying the portion of the image to set.
		@param image The image to set the portion of the image to.

		@throws OutOfBounds if the portion of the image to set is outside the bounds of the original image.</haxe_doc>
	</setImagePortion>
	<drawLine public="1" get="inline" set="null" line="565" static="1">
		<f a="this:x1:y1:x2:y2:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Draws a line from (x1, y1) to (x2, y2) using the given color.</haxe_doc>
	</drawLine>
	<drawRay2D public="1" get="inline" set="null" line="601" static="1">
		<f a="this:line:color">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.Ray2D"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Draws an intine line specified by a Ray2D object.

		**Notice** - The (0, 0) point is **not** the same is `image.getPixel(0, 0)`,
		but rather the bottom left corner of the image - `image.getPixel(0, image.height - 1)`.

		This "vertical flip" is done to match the way the ray is draw on the cartesian plane.

		@param line The line to draw.
		@param color The color to draw the line with.

		@see Ray2D</haxe_doc>
	</drawRay2D>
	<drawLine2D public="1" get="inline" set="null" line="642" static="1">
		<f a="this:line:color">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.Line2D"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Draws a `Line2D` object using the given color.

		If the line segment is not completely within the image, 
		it doesn't throw an error, but just draws the part of the 
		line segment that is within the image.

		@param line The line segment to draw.
		@param color The color to draw the line segment with.

		@see Line2D</haxe_doc>
	</drawLine2D>
	<fillRect public="1" get="inline" set="null" line="675" static="1">
		<f a="this:x:y:width:height:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Sets a rectangle of pixels to the given color, essentially filling it with the given color.

		@param rect The rectangle to fill: The fill starts at (x, y) and extends to (x + width, y + height), not including the endpoints.
		@param color The color to fill that rectangular portion with.</haxe_doc>
	</fillRect>
	<drawRect public="1" get="inline" set="null" line="691" static="1">
		<f a="this:x:y:width:height:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Draws a rectangular outline of the given color.

		This function is a shortcut for just doing repeated calls to drawLine.

		@param rect The rectangle to draw the outline of.
		@param color The color to draw the outline with.</haxe_doc>
	</drawRect>
	<drawQuadraticBezier public="1" get="inline" set="null" line="710" static="1">
		<f a="this:line:control:color:?accuracy" v="::::1000">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.Line2D"/>
			<x path="vision.ds.IntPoint2D"/>
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ accuracy : 1000 }</e></m></meta>
		<haxe_doc>Draws a curved line specified by a line and one control point.

		This method draws a quadratic Bezier curve.

		@param line The line to draw.
		@param control The control point of the curve.
		@param color The color to draw the line with.
		@param accuracy The number of iterations to use when drawing the curve. the higher the number, the more iterations are used, and the more accurate the curve is. for example, accuracy of 100 will draw the curve with 100 iterations, and will draw 100 points on the curve. **default is 1000**

		@see Line2D</haxe_doc>
	</drawQuadraticBezier>
	<drawCubicBezier public="1" get="inline" set="null" line="749" static="1">
		<f a="this:line:control1:control2:color:?accuracy" v=":::::1000">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.Line2D"/>
			<x path="vision.ds.IntPoint2D"/>
			<x path="vision.ds.IntPoint2D"/>
			<x path="vision.ds.Color"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ accuracy : 1000 }</e></m></meta>
		<haxe_doc>Draws a curved line specified by a line and two control points.

		This method draws a cubic Bezier curve.

		@param line The line to draw.
		@param control1 The first control point of the curve.
		@param control2 The second control point of the curve.
		@param color The color to draw the curve with.
		@param accuracy The number of iterations to use when drawing the curve. The higher the number, the more iterations are used, and the more accurate the curve is. For example: accuracy of 100 will draw the curve with 100 iterations, and will draw 100 points on the curve. **default is 1000**

		@see Line2D</haxe_doc>
	</drawCubicBezier>
	<fillCircle public="1" get="inline" set="null" line="804" static="1">
		<f a="this:X:Y:r:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Fills a circle with the given color:

		 - The center of the circle is at (X, Y)
		 - The radius of the circle is r
		 - Anti-aliasing will not be used.

		@param x The x coordinate of the center of the circle.
		@param y The y coordinate of the center of the circle.
		@param r The radius of the circle.
		@param color The color to draw the circle with.</haxe_doc>
	</fillCircle>
	<drawCircle public="1" get="inline" set="null" line="847" static="1">
		<f a="this:X:Y:r:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Draws a circle of the given color:

		 - The center of the circle is at (X, Y)
		 - The radius of the circle is r
		 - Anti-aliasing will not be used.

		@param x The x coordinate of the center of the circle.
		@param y The y coordinate of the center of the circle.
		@param r The radius of the circle.
		@param color The color to draw the circle with.</haxe_doc>
	</drawCircle>
	<drawEllipse public="1" get="inline" set="null" line="877" static="1">
		<f a="this:centerX:centerY:radiusX:radiusY:color">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Draws an ellipse of the given color:

		 - The center of the ellipse is at (X, Y)
		 - The radius of the ellipse is r
		 - Anti-aliasing will not be used.

		@param centerX The x coordinate of the center of the ellipse.
		@param centerY The y coordinate of the center of the ellipse.
		@param radiusX The x radius of the ellipse.
		@param radiusY The y radius of the ellipse.
		@param color The color to draw the ellipse with.</haxe_doc>
	</drawEllipse>
	<fillColorRecursive public="1" set="method" line="960" static="1">
		<f a="this:position:color">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.IntPoint2D"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Recursively fills a section of the image. the section filled has to match
		`position`'s color.

		when the fill encounters a color that is not `position`'s color, it
		will stop filling in that direction.

		**Warning** - this function is recursive. This function is not slow, but can trigger
		a stack overflow if used on large images. This is only here so an implementation will be available.

		@param position The position to start filling at. You can use a Point2D or IntPoint2D.
		@param color The color to fill with.</haxe_doc>
	</fillColorRecursive>
	<fillColor public="1" set="method" line="989" static="1">
		<f a="this:position:color">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.IntPoint2D"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Fills a section of the image. the section filled has to match
		`position`'s color.

		This uses the BFS `Breadth First Search` algorithm

		@param position The position to start filling at. You can use a Point2D or IntPoint2D.
		@param color The color to fill with.</haxe_doc>
	</fillColor>
	<fillUntilColor public="1" set="method" line="1026" static="1">
		<f a="this:position:color:borderColor">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.IntPoint2D"/>
			<x path="vision.ds.Color"/>
			<x path="vision.ds.Color"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Fills a section of the image. the section filled has to be bordered by pixels of color `borderColor`.

		This uses the BFS `Breadth First Search` algorithm

		@param position The position to start filling at. You can use a Point2D or IntPoint2D.
		@param color The color to fill with.
		@param borderColor The color upon which to stop filling.</haxe_doc>
	</fillUntilColor>
	<clone public="1" set="method" line="1066" static="1">
		<f a="this">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.Image"/>
		</f>
		<haxe_doc>Clones this image.

		Useful if you want to operate on `this` image, without modifying it:

			var blurred = Vision.gaussianBlur(image.clone());</haxe_doc>
	</clone>
	<mirror public="1" get="inline" set="null" line="1077" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="vision.ds.Image"/>
</f></mirror>
	<flip public="1" get="inline" set="null" line="1085" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="vision.ds.Image"/>
</f></flip>
	<stamp public="1" get="inline" set="null" line="1102" static="1">
		<f a="this:X:Y:image">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Image"/>
			<x path="vision.ds.Image"/>
		</f>
		<haxe_doc>* Stamps the given image onto this image, with the stamped image's top left corner being at (`X`, `Y`).
	 * 
	 * 
	 * @param X The X coordinate of the top left corner of the stamped image.
	 * @param Y The Y coordinate of the top left corner of the stamped image
	 * @param image The image to stamp. Alpha values are respected.
	 * @return this image after stamping the given image onto it.</haxe_doc>
	</stamp>
	<resize public="1" get="inline" set="null" line="1121" static="1">
		<f a="this:?newWidth:?newHeight:?algorithm" v=":-1:-1:">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.ImageResizeAlgorithm"/>
			<x path="vision.ds.Image"/>
		</f>
		<meta><m n=":value"><e>{ newHeight : -1, newWidth : -1 }</e></m></meta>
		<haxe_doc>Resizes the image according to `algorithm`, to `newWidth` by `newHeight`.

		@param newWidth The width to resize to. if assigned to `-1`, the image resizes to the given `newHeight`, and keeps the aspect-ratio of the original image.
		@param newHeight The height to resize to. if assigned to `-1`, the image resizes to the given `newWidth`, and keeps the aspect-ratio of the original image.
		@param algorithm Which algorithm to use. You can use the algorithms available in `ImageResizeAlgorithm`. If no algorithm is specified, uses `ImageTools.defaultResizeAlgorithm`.
		@return this image, after resizing.</haxe_doc>
	</resize>
	<rotate public="1" get="inline" set="null" line="1160" static="1">
		<f a="this:angle:?degrees:?expandImageBounds" v="::true:true">
			<x path="vision.ds.ByteArray"/>
			<x path="Float"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="vision.ds.Image"/>
		</f>
		<meta><m n=":value"><e>{ expandImageBounds : true, degrees : true }</e></m></meta>
		<haxe_doc>Rotates this image's pixel by `angle` degrees\radians.  
		Notice - rotating an image and then re-rotating to the image's previous state won't bring you exactly the same image.

		@param angle The angle to rotate by.
		@param degrees if `true`, `angle` is in degrees. Otherwise, `angle` is in radians.
		@param expandImageBounds Whether to expand the image's bounds to fit the rotated image. Default is `true`.</haxe_doc>
	</rotate>
	<toString public="1" set="method" line="1212" static="1">
		<f a="this:?special" v=":true">
			<x path="vision.ds.ByteArray"/>
			<x path="Bool"/>
			<c path="String"/>
		</f>
		<meta><m n=":value"><e>{ special : true }</e></m></meta>
		<haxe_doc>Gets the image as a string.

		@param special When using the `Console.hx` haxelib, images can be printed to the console
		with color. Set this to false if you don't want this to happen. Set to `true` by default.</haxe_doc>
	</toString>
	<forEachPixel public="1" get="inline" set="null" line="1232" static="1">
		<f a="this:callback">
			<x path="vision.ds.ByteArray"/>
			<f a="x:y:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<x path="Void"/>
		</f>
		<haxe_doc><![CDATA[Iterates over each pixel inside this image, from left to right, top to bottom.
	    @param callback A function to dispatch on each pixel: Arguments contain the X & Y of the pixel, and its color.]]></haxe_doc>
	</forEachPixel>
	<forEachPixelInView public="1" get="inline" set="null" line="1250" static="1">
		<f a="this:callback">
			<x path="vision.ds.ByteArray"/>
			<f a="x:y:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<x path="Void"/>
		</f>
		<haxe_doc><![CDATA[Iterates over each pixel inside this image, from left to right, top to bottom.

		This function differs from `forEachPixel` by not dispatching `callback()` 
		on pixels outside of the currently set `ImageView`.

		If an `ImageView` isn't set, this function will call `forEachPixel` instead to increase performance. 

		@param callback A function to dispatch on each pixel: Arguments contain the X & Y of the pixel, and its color. Won't dispatch for pixels outside of the currently set view.]]></haxe_doc>
	</forEachPixelInView>
	<iterator public="1" get="inline" set="null" line="1267" static="1">
		<f a="this">
			<x path="vision.ds.ByteArray"/>
			<t path="Iterator"><c path="vision.ds.Pixel"/></t>
		</f>
		<haxe_doc>Returns an iterator over this image's pixels.</haxe_doc>
	</iterator>
	<center public="1" get="inline" set="null" line="1274" static="1">
		<f a="this">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.Point2D"/>
		</f>
		<haxe_doc>Returns a `Point2D` representing the center of the image</haxe_doc>
	</center>
	<pixelToRelative public="1" get="inline" set="null" line="1283" static="1">
		<f a="this:point">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.Point2D"/>
			<c path="vision.ds.Point2D"/>
		</f>
		<haxe_doc>Converts a `Point2D` from pixel coordinates (for example, `(121, 435)`) to relative coordinates, for this image (for example, `(0.5, 0.5)`).
		@param point A `Point2D` in pixel coordinates
		@return A `Point2D` in relative coordinates, such that: `R = (Px / W, Py / H)`</haxe_doc>
		<overloads><pixelToRelative public="1" get="inline" set="null" line="1293">
	<f a="this:x:y">
		<x path="vision.ds.ByteArray"/>
		<x path="Float"/>
		<x path="Float"/>
		<c path="vision.ds.Point2D"/>
	</f>
	<haxe_doc>Converts a `Point2D` from relative coordinates (for example, `(0.5, 0.5)`) to pixel coordinates, for this image (for example, `(121, 435)`).
		@param x The X component of the `Point2D` in relative coordinates
		@param y The Y component of the `Point2D` in relative coordinates
		@return A `Point2D` in pixel coordinates, such that: `P = (x * W, y * H)`</haxe_doc>
</pixelToRelative></overloads>
	</pixelToRelative>
	<relativeToPixel public="1" get="inline" set="null" line="1302" static="1">
		<f a="this:point">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.Point2D"/>
			<c path="vision.ds.Point2D"/>
		</f>
		<haxe_doc>Converts a `Point2D` from relative coordinates (for example, `(0.5, 0.5)`) to pixel coordinates, for this image (for example, `(121, 435)`).
		@param point A `Point2D` in relative coordinates
		@return A `Point2D` in pixel coordinates, such that: `P = (Rx * W, Ry * H)`</haxe_doc>
		<overloads><relativeToPixel public="1" get="inline" set="null" line="1312">
	<f a="this:x:y">
		<x path="vision.ds.ByteArray"/>
		<x path="Float"/>
		<x path="Float"/>
		<c path="vision.ds.Point2D"/>
	</f>
	<haxe_doc>Converts a `Point2D` from pixel coordinates (for example, `(121, 435)`) to relative coordinates, for this image (for example, `(0.5, 0.5)`).
		@param x The X component of the `Point2D` in pixel coordinates
		@param y The Y component of the `Point2D` in pixel coordinates
		@return A `Point2D` in relative coordinates, such that: `R = (x / W, y / H)`</haxe_doc>
</relativeToPixel></overloads>
	</relativeToPixel>
	<hasView public="1" get="inline" set="null" line="1326" static="1">
		<f a="this">
			<x path="vision.ds.ByteArray"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Checks whether or not this image currently has a view

		If `view`'s dimensions are all 0'ed out, or are greater than/the same as the image's dimensions, this will return false.</haxe_doc>
	</hasView>
	<setView public="1" get="inline" set="null" line="1346" static="1">
		<f a="this:view">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.ImageView"/>
			<x path="vision.ds.Image"/>
		</f>
		<haxe_doc>Sets the current `ImageView`, and returns this image.

		If `view`'s dimensions are all 0'ed out, or are greater than/the same as the image's dimensions, `hasView()` will return false.

		If you want to remove the currently set `ImageView`, check out `removeView()`.

		@param view The `ImageView` to set to.
		@return This image, after applying the view.</haxe_doc>
	</setView>
	<getView public="1" get="inline" set="null" line="1358" static="1">
		<f a="this">
			<x path="vision.ds.ByteArray"/>
			<c path="vision.ds.ImageView"/>
		</f>
		<haxe_doc>Gets the currently set `ImageView`.</haxe_doc>
	</getView>
	<removeView public="1" get="inline" set="null" line="1371" static="1">
		<f a="this">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.Image"/>
		</f>
		<haxe_doc>Removes the currently set `ImageView`, and returns this image.</haxe_doc>
	</removeView>
	<copyViewFrom public="1" get="inline" set="null" line="1383" static="1">
		<f a="this:from">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.Image"/>
			<x path="vision.ds.Image"/>
		</f>
		<haxe_doc>Copies the view from the given `Image` into this image.</haxe_doc>
	</copyViewFrom>
	<hasPixelInView public="1" get="inline" set="null" line="1406" static="1">
		<f a="this:x:y:?v">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<c path="vision.ds.ImageView"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Checks whether or not the given pixel in coordinates `(x, y)` is inside the given `ImageView`, 
		or inside currently set `ImageView` (if `v` is `null`).

		If `v` is null, and this image's view isn't set (check out `hasView()` for more details), 
		this function calls `hasPixel()` to remove unnecessary calculations.

		@param x The x position of the pixel
		@param y The y position of the pixel
		@param v A view to check against, or `null` if you want to check against this image's view.
		@return Whether or not the given pixel is inside the view.</haxe_doc>
	</hasPixelInView>
	<from2DArray public="1" get="inline" set="null" line="1559" static="1">
		<f a="array">
			<c path="Array"><c path="Array"><x path="vision.ds.Color"/></c></c>
			<x path="vision.ds.Image"/>
		</f>
		<meta><m n=":from"/></meta>
		<haxe_doc>Takes a 2D array of colors, and returns an image `array[0].length` pixels wide and `array.length` pixels tall.

		The array is not altered.

		@param array the 2-dimensional color array. Make sure `array[0]`'s length is your desired image width.
		@return a new `Image`</haxe_doc>
	</from2DArray>
	<to2DArray public="1" get="inline" set="null" line="1588" static="1">
		<f a="this">
			<x path="vision.ds.ByteArray"/>
			<c path="Array"><c path="Array"><x path="vision.ds.Color"/></c></c>
		</f>
		<meta><m n=":to"/></meta>
		<haxe_doc>Returns a new, 2-dimensional array, with each cell containing the pixel on the image at it's indices (`array[x][y]` = `image.getPixel(x, y)`)
		@return a 2D array of colors.</haxe_doc>
	</to2DArray>
	<fromBytes public="1" get="inline" set="null" line="1607" static="1">
		<f a="bytes:width:?height">
			<x path="vision.ds.ByteArray"/>
			<x path="Int"/>
			<x path="Int"/>
			<d/>
		</f>
		<haxe_doc>Takes a `ByteArray`/`haxe.io.Bytes` instance and some stats, and returns a new image instance
		that correctly represents the colors inside `bytes` at the given size
		@param bytes The byte array to be used. **Make it's color format is `ARGB`.** if it isn't, use `PixelFormat.convertPixelFormat(bytes, fromFormat, ARGB)`
		@param width The width of the returned image.
		@param height Optional, the height of the returned image. determined automatically, can be overridden by setting this parameter</haxe_doc>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="1627" static="1">
		<f a="this">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.ByteArray"/>
		</f>
		<meta><m n=":to"/></meta>
		<haxe_doc>Returns a `ByteArray` of format `ARGB` of the pixels of this image.
		@return A new `ByteArray`</haxe_doc>
		<overloads><toBytes public="1" get="inline" set="null" line="1636">
	<f a="this:?colorFormat" v=":ARGB">
		<x path="vision.ds.ByteArray"/>
		<x path="vision.ds.PixelFormat"/>
		<x path="vision.ds.ByteArray"/>
	</f>
	<meta><m n=":value"><e>{ colorFormat : ARGB }</e></m></meta>
	<haxe_doc>Returns a `ByteArray` of format `colorFormat` of the pixels of this image.
		@param colorFormat The wanted color format of the returned `ByteArray`.
		@return A new `ByteArray`</haxe_doc>
</toBytes></overloads>
	</toBytes>
	<image_or_image get="inline" set="null" line="1643" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Image"/>
			<x path="vision.ds.Image"/>
			<x path="vision.ds.Image"/>
		</f>
		<meta><m n=":op"><e>A | B</e></m></meta>
	</image_or_image>
	<image_xor_image get="inline" set="null" line="1650" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Image"/>
			<x path="vision.ds.Image"/>
			<x path="vision.ds.Image"/>
		</f>
		<meta><m n=":op"><e>A ^ B</e></m></meta>
	</image_xor_image>
	<image_and_image get="inline" set="null" line="1657" static="1">
		<f a="lhs:rhs">
			<x path="vision.ds.Image"/>
			<x path="vision.ds.Image"/>
			<x path="vision.ds.Image"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
	</image_and_image>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds._Image.Image_Impl_" params="" file="src/vision/ds/Image.hx" private="1" module="vision.ds.Image" final="1">
		<OFFSET expr="11" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
			<haxe_doc><![CDATA[the first 2 bytes represent image width,  
		the next 4 bytes are the `x` & `y` position of an image view,  
		the next 4 bytes are the `width` & `height` of an image view,
		the last byte represents view shape]]></haxe_doc>
		</OFFSET>
		<WIDTH_BYTES expr="2" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</WIDTH_BYTES>
		<VIEW_XY_BYTES expr="4" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</VIEW_XY_BYTES>
		<VIEW_WH_BYTES expr="4" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</VIEW_WH_BYTES>
		<VIEW_SHAPE_BYTES expr="1" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</VIEW_SHAPE_BYTES>
		<DATA_GAP expr="2" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</DATA_GAP>
		<underlying public="1" get="accessor" set="null" static="1">
			<x path="vision.ds.ByteArray"/>
			<haxe_doc>Returns the underlying type of this abstract.</haxe_doc>
		</underlying>
		<get_underlying get="inline" set="null" line="52" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="vision.ds.ByteArray"/>
</f></get_underlying>
		<width public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>The width of the image.</haxe_doc>
		</width>
		<get_width get="inline" set="null" line="67" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
</f></get_width>
		<height public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>The height of the image.</haxe_doc>
		</height>
		<get_height get="inline" set="null" line="83" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
</f></get_height>
		<view public="1" get="accessor" set="accessor" static="1">
			<c path="vision.ds.ImageView"/>
			<haxe_doc>The current image's `ImageView`. You can get/set this field to change the view, but changing it's values won't effect anything.

		`ImageView`s disallow setting pixels on parts outside of the view. That's useful when you want to operate
		on a certain part of the image, without modifying other portions/copying pixels around.</haxe_doc>
		</view>
		<get_view get="inline" set="null" line="99" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<c path="vision.ds.ImageView"/>
</f></get_view>
		<set_view get="inline" set="null" line="103" static="1"><f a="this:view">
	<x path="vision.ds.ByteArray"/>
	<c path="vision.ds.ImageView"/>
	<c path="vision.ds.ImageView"/>
</f></set_view>
		<_new public="1" get="inline" set="null" line="115" static="1">
			<f a="width:height:?color" v="::0x00000000">
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta>
				<m n=":value"><e>{ color : 0x00000000 }</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new image of the given size. Once is created, the image cannot be resized.

		@param width The width of the image.
		@param height The height of the image.
		@param color The color to fill the image with. if unspecified, the image is transparent.</haxe_doc>
		</_new>
		<getColorFromStartingBytePos get="inline" set="null" line="133" static="1"><f a="this:position">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="vision.ds.Color"/>
</f></getColorFromStartingBytePos>
		<setColorFromStartingBytePos get="inline" set="null" line="138" static="1"><f a="this:position:c">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="vision.ds.Color"/>
	<x path="vision.ds.Color"/>
</f></setColorFromStartingBytePos>
		<getPixel public="1" get="inline" set="null" line="169" static="1">
			<f a="this:x:y">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Gets the color of the pixel at the given coordinates.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@throws OutOfBounds if the coordinates are outside the bounds of the image.
		@return The color of the pixel at the given coordinates.</haxe_doc>
		</getPixel>
		<getSafePixel public="1" get="inline" set="null" line="190" static="1">
			<f a="this:x:y">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Gets the color of the pixel at the given coordinates.

		Coordinates outside the bounds of the image are allowed.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@return The color of the pixel at the given coordinates.</haxe_doc>
		</getSafePixel>
		<getUnsafePixel get="inline" set="null" line="195" static="1">
			<f a="this:x:y">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<meta><m n=":allow"><e>vision</e></m></meta>
		</getUnsafePixel>
		<getFloatingPixel public="1" get="inline" set="null" line="244" static="1">
			<f a="this:x:y">
				<x path="vision.ds.ByteArray"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc><![CDATA[Gets the color of the pixel at the given coordinates.
		These coordinates can also be of type `Float`, in which case
		the value returned should be an interpolation of the surrounding, physical pixels.

		**This Operation is safe - Out of bound coordinates won't throw an error, and will instead use the closest pixel.**

		### How Does This Work?

		Lets say we want the pixel at `(0.5, 0.5)`:
		```
		(0,0)   (1,0)                                     
														 
			  Â·     < Y (0.5)                      
														 
		(0,1)   (1,1)                                     
			  ^                                           
			X (0.5)                                        
		```

		First, we're going to calculate the actual fraction - the means, extracting the numbers after the decimal point:

			final xFraction = x - Std.int(x);
			final yFraction = y - Std.int(y);


		Then, we just multiply each of the surrounding pixel's value by it's distance from the initial X value (using `xFraction` and `yFraction`):

			final pixelsBeforeYMultiplier = 1 - yFraction, pixelsAfterYMultiplier = yFraction;
			final pixelsBeforeXMultiplier = 1 - xFraction, pixelsAfterXMultiplier = xFraction;
			final bottomLayer = pixelsBeforeYMultiplier * (pixelsBeforeXMultiplier * getPixel(Std.int(x), Std.int(y)) + pixelsAfterXMultiplier * getPixel(Std.int(x) + 1, Std.int(y)));
			final topLayer = pixelsAfterYMultiplier * (pixelsBeforeXMultiplier * getPixel(Std.int(x), Std.int(y) + 1) + pixelsAfterXMultiplier * getPixel(Std.int(x) + 1, Std.int(y) + 1));


		And add the two layers to get the result:


			var finalColor:Color = Std.int(bottomLayer + topLayer);


		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@return The color of the pixel at the given coordinates.]]></haxe_doc>
		</getFloatingPixel>
		<setPixel public="1" get="inline" set="null" line="275" static="1">
			<f a="this:x:y:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the color of the pixel at the given coordinates.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.
		@param color The color to set the pixel to.

		@throws OutOfBounds if the coordinates are outside the bounds of the image.</haxe_doc>
		</setPixel>
		<setSafePixel public="1" get="inline" set="null" line="293" static="1"><f a="this:x:y:color">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="vision.ds.Color"/>
	<x path="Void"/>
</f></setSafePixel>
		<setFloatingPixel public="1" get="inline" set="null" line="305" static="1"><f a="this:x:y:color">
	<x path="vision.ds.ByteArray"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="vision.ds.Color"/>
	<x path="Void"/>
</f></setFloatingPixel>
		<setUnsafePixel get="inline" set="null" line="323" static="1">
			<f a="this:x:y:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>vision</e></m></meta>
		</setUnsafePixel>
		<paintPixel public="1" get="inline" set="null" line="348" static="1">
			<f a="this:x:y:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the color of a pixel, but doesn't completely overwrite the pixel:

		- if the color of the new pixel is the same as the old pixel, the old pixel is kept.
		- if the alpha of the new pixel is 0, the old pixel is kept.
		- if the alpha of the new pixel is 255, the new pixel is kept.
		- if the alpha of the new pixel is between 0 and 255, the new pixel is blended with the old pixel.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.
		@param color The color to set the pixel to. Pay attention to the alpha value.
		@throws OutOfBounds if the coordinates are outside the bounds of the image.</haxe_doc>
		</paintPixel>
		<paintFloatingPixel public="1" get="inline" set="null" line="367" static="1"><f a="this:x:y:color">
	<x path="vision.ds.ByteArray"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="vision.ds.Color"/>
	<x path="Void"/>
</f></paintFloatingPixel>
		<paintSafePixel public="1" get="inline" set="null" line="400" static="1"><f a="this:x:y:color">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></paintSafePixel>
		<paintUnsafePixel get="inline" set="null" line="405" static="1">
			<f a="this:x:y:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>vision</e></m></meta>
		</paintUnsafePixel>
		<hasPixel public="1" get="inline" set="null" line="431" static="1">
			<f a="this:x:y">
				<x path="vision.ds.ByteArray"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks if the given coordinates are within the bounds of the image.

		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@return True if the coordinates are within the bounds of the image.</haxe_doc>
		</hasPixel>
		<movePixel public="1" set="method" line="450" static="1">
			<f a="this:fromX:fromY:toX:toY:oldPixelResetColor">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Moves the pixel at `(fromX, fromY)` to `(toX, toY)` and resets the color at `(fromX, fromY)`.

		@param fromX The x-coordinate of the pixel to move.
		@param fromY The y-coordinate of the pixel to move.
		@param toX The x-coordinate of the pixel to set to the color of `(fromX, fromY)` to.
		@param toY The y-coordinate of the pixel to set to the color of `(fromX, fromY)` to.
		@param oldPixelResetColor After moving the pixel, the color of the pixel at `(fromX, fromY)` resets to `0x00000000`. To change that color, set this parameter</haxe_doc>
		</movePixel>
		<moveSafePixel public="1" set="method" line="464" static="1">
			<f a="this:fromX:fromY:toX:toY:oldPixelResetColor">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Moves the pixel at `(fromX, fromY)` to `(toX, toY)` and resets the color at `(fromX, fromY)`. Values outside teh bounds of `this` image are allowed.

		@param fromX The x-coordinate of the pixel to move.
		@param fromY The y-coordinate of the pixel to move.
		@param toX The x-coordinate of the pixel to set to the color of `(fromX, fromY)` to.
		@param toY The y-coordinate of the pixel to set to the color of `(fromX, fromY)` to.
		@param oldPixelResetColor After moving the pixel, the color of the pixel at `(fromX, fromY)` resets to `0x00000000`. To change that color, set this parameter</haxe_doc>
		</moveSafePixel>
		<moveFloatingPixel public="1" set="method" line="480" static="1">
			<f a="this:fromX:fromY:toX:toY:oldPixelResetColor">
				<x path="vision.ds.ByteArray"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Moves the pixel at `(fromX, fromY)` to `(toX, toY)` and resets the color at `(fromX, fromY)`. Fractional values are allowed.
		
		This Operation is safe - Out of bound coordinates won't throw an error, and will instead use the closest pixel.

		@param fromX The x-coordinate of the pixel to move.
		@param fromY The y-coordinate of the pixel to move.
		@param toX The x-coordinate of the pixel to set to the color of `(fromX, fromY)` to.
		@param toY The y-coordinate of the pixel to set to the color of `(fromX, fromY)` to.
		@param oldPixelResetColor After moving the pixel, the color of the pixel at `(fromX, fromY)` resets to `0x00000000`. To change that color, set this parameter</haxe_doc>
		</moveFloatingPixel>
		<moveUnsafePixel public="1" set="method" line="485" static="1"><f a="this:fromX:fromY:toX:toY:oldPixelResetColor">
	<x path="vision.ds.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="vision.ds.Color"/>
	<x path="Void"/>
</f></moveUnsafePixel>
		<copyPixelFrom public="1" get="inline" set="null" line="500" static="1">
			<f a="this:image:x:y">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Copies a pixel from the given image to this image.

		@param image The image to copy the pixel from.
		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@throws OutOfBounds if the given coordinates are outside the bounds of one or both of the images
		@return The color of the pixel at the given coordinates.</haxe_doc>
		</copyPixelFrom>
		<copyPixelTo public="1" get="inline" set="null" line="516" static="1">
			<f a="this:image:x:y">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>Copies a pixel from the given image to this image.

		@param image The image to copy the pixel to.
		@param x The x coordinate of the pixel.
		@param y The y coordinate of the pixel.

		@throws OutOfBounds if the given coordinates are outside the bounds of one or both of the images
		@return The color of the pixel at the given coordinates.</haxe_doc>
		</copyPixelTo>
		<getImagePortion public="1" get="inline" set="null" line="528" static="1">
			<f a="this:rect">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.Rectangle"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Returns a portion of the image, specified by a rectangle.

		@param rect The rectangle specifying the portion of the image to return.

		@throws OutOfBounds if the portion of the image to get is outside the bounds of the original image.
		@return A new image containing the specified portion of the original image.</haxe_doc>
		</getImagePortion>
		<setImagePortion public="1" get="inline" set="null" line="546" static="1">
			<f a="this:rect:image">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.Rectangle"/>
				<x path="vision.ds.Image"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a portion of the image, specified by a rectangle, to another image.

		@param rect The rectangle specifying the portion of the image to set.
		@param image The image to set the portion of the image to.

		@throws OutOfBounds if the portion of the image to set is outside the bounds of the original image.</haxe_doc>
		</setImagePortion>
		<drawLine public="1" get="inline" set="null" line="565" static="1">
			<f a="this:x1:y1:x2:y2:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Draws a line from (x1, y1) to (x2, y2) using the given color.</haxe_doc>
		</drawLine>
		<drawRay2D public="1" get="inline" set="null" line="601" static="1">
			<f a="this:line:color">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.Ray2D"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Draws an intine line specified by a Ray2D object.

		**Notice** - The (0, 0) point is **not** the same is `image.getPixel(0, 0)`,
		but rather the bottom left corner of the image - `image.getPixel(0, image.height - 1)`.

		This "vertical flip" is done to match the way the ray is draw on the cartesian plane.

		@param line The line to draw.
		@param color The color to draw the line with.

		@see Ray2D</haxe_doc>
		</drawRay2D>
		<drawLine2D public="1" get="inline" set="null" line="642" static="1">
			<f a="this:line:color">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.Line2D"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Draws a `Line2D` object using the given color.

		If the line segment is not completely within the image, 
		it doesn't throw an error, but just draws the part of the 
		line segment that is within the image.

		@param line The line segment to draw.
		@param color The color to draw the line segment with.

		@see Line2D</haxe_doc>
		</drawLine2D>
		<fillRect public="1" get="inline" set="null" line="675" static="1">
			<f a="this:x:y:width:height:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a rectangle of pixels to the given color, essentially filling it with the given color.

		@param rect The rectangle to fill: The fill starts at (x, y) and extends to (x + width, y + height), not including the endpoints.
		@param color The color to fill that rectangular portion with.</haxe_doc>
		</fillRect>
		<drawRect public="1" get="inline" set="null" line="691" static="1">
			<f a="this:x:y:width:height:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Draws a rectangular outline of the given color.

		This function is a shortcut for just doing repeated calls to drawLine.

		@param rect The rectangle to draw the outline of.
		@param color The color to draw the outline with.</haxe_doc>
		</drawRect>
		<drawQuadraticBezier public="1" get="inline" set="null" line="710" static="1">
			<f a="this:line:control:color:?accuracy" v="::::1000">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.Line2D"/>
				<x path="vision.ds.IntPoint2D"/>
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ accuracy : 1000 }</e></m></meta>
			<haxe_doc>Draws a curved line specified by a line and one control point.

		This method draws a quadratic Bezier curve.

		@param line The line to draw.
		@param control The control point of the curve.
		@param color The color to draw the line with.
		@param accuracy The number of iterations to use when drawing the curve. the higher the number, the more iterations are used, and the more accurate the curve is. for example, accuracy of 100 will draw the curve with 100 iterations, and will draw 100 points on the curve. **default is 1000**

		@see Line2D</haxe_doc>
		</drawQuadraticBezier>
		<drawCubicBezier public="1" get="inline" set="null" line="749" static="1">
			<f a="this:line:control1:control2:color:?accuracy" v=":::::1000">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.Line2D"/>
				<x path="vision.ds.IntPoint2D"/>
				<x path="vision.ds.IntPoint2D"/>
				<x path="vision.ds.Color"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ accuracy : 1000 }</e></m></meta>
			<haxe_doc>Draws a curved line specified by a line and two control points.

		This method draws a cubic Bezier curve.

		@param line The line to draw.
		@param control1 The first control point of the curve.
		@param control2 The second control point of the curve.
		@param color The color to draw the curve with.
		@param accuracy The number of iterations to use when drawing the curve. The higher the number, the more iterations are used, and the more accurate the curve is. For example: accuracy of 100 will draw the curve with 100 iterations, and will draw 100 points on the curve. **default is 1000**

		@see Line2D</haxe_doc>
		</drawCubicBezier>
		<fillCircle public="1" get="inline" set="null" line="804" static="1">
			<f a="this:X:Y:r:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Fills a circle with the given color:

		 - The center of the circle is at (X, Y)
		 - The radius of the circle is r
		 - Anti-aliasing will not be used.

		@param x The x coordinate of the center of the circle.
		@param y The y coordinate of the center of the circle.
		@param r The radius of the circle.
		@param color The color to draw the circle with.</haxe_doc>
		</fillCircle>
		<drawCircle public="1" get="inline" set="null" line="847" static="1">
			<f a="this:X:Y:r:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Draws a circle of the given color:

		 - The center of the circle is at (X, Y)
		 - The radius of the circle is r
		 - Anti-aliasing will not be used.

		@param x The x coordinate of the center of the circle.
		@param y The y coordinate of the center of the circle.
		@param r The radius of the circle.
		@param color The color to draw the circle with.</haxe_doc>
		</drawCircle>
		<drawEllipse public="1" get="inline" set="null" line="877" static="1">
			<f a="this:centerX:centerY:radiusX:radiusY:color">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Draws an ellipse of the given color:

		 - The center of the ellipse is at (X, Y)
		 - The radius of the ellipse is r
		 - Anti-aliasing will not be used.

		@param centerX The x coordinate of the center of the ellipse.
		@param centerY The y coordinate of the center of the ellipse.
		@param radiusX The x radius of the ellipse.
		@param radiusY The y radius of the ellipse.
		@param color The color to draw the ellipse with.</haxe_doc>
		</drawEllipse>
		<fillColorRecursive public="1" set="method" line="960" static="1">
			<f a="this:position:color">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.IntPoint2D"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Recursively fills a section of the image. the section filled has to match
		`position`'s color.

		when the fill encounters a color that is not `position`'s color, it
		will stop filling in that direction.

		**Warning** - this function is recursive. This function is not slow, but can trigger
		a stack overflow if used on large images. This is only here so an implementation will be available.

		@param position The position to start filling at. You can use a Point2D or IntPoint2D.
		@param color The color to fill with.</haxe_doc>
		</fillColorRecursive>
		<fillColor public="1" set="method" line="989" static="1">
			<f a="this:position:color">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.IntPoint2D"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Fills a section of the image. the section filled has to match
		`position`'s color.

		This uses the BFS `Breadth First Search` algorithm

		@param position The position to start filling at. You can use a Point2D or IntPoint2D.
		@param color The color to fill with.</haxe_doc>
		</fillColor>
		<fillUntilColor public="1" set="method" line="1026" static="1">
			<f a="this:position:color:borderColor">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.IntPoint2D"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Fills a section of the image. the section filled has to be bordered by pixels of color `borderColor`.

		This uses the BFS `Breadth First Search` algorithm

		@param position The position to start filling at. You can use a Point2D or IntPoint2D.
		@param color The color to fill with.
		@param borderColor The color upon which to stop filling.</haxe_doc>
		</fillUntilColor>
		<clone public="1" set="method" line="1066" static="1">
			<f a="this">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Clones this image.

		Useful if you want to operate on `this` image, without modifying it:

			var blurred = Vision.gaussianBlur(image.clone());</haxe_doc>
		</clone>
		<mirror public="1" get="inline" set="null" line="1077" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="vision.ds.Image"/>
</f></mirror>
		<flip public="1" get="inline" set="null" line="1085" static="1"><f a="this">
	<x path="vision.ds.ByteArray"/>
	<x path="vision.ds.Image"/>
</f></flip>
		<stamp public="1" get="inline" set="null" line="1102" static="1">
			<f a="this:X:Y:image">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>* Stamps the given image onto this image, with the stamped image's top left corner being at (`X`, `Y`).
	 * 
	 * 
	 * @param X The X coordinate of the top left corner of the stamped image.
	 * @param Y The Y coordinate of the top left corner of the stamped image
	 * @param image The image to stamp. Alpha values are respected.
	 * @return this image after stamping the given image onto it.</haxe_doc>
		</stamp>
		<resize public="1" get="inline" set="null" line="1121" static="1">
			<f a="this:?newWidth:?newHeight:?algorithm" v=":-1:-1:">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.ImageResizeAlgorithm"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ newHeight : -1, newWidth : -1 }</e></m></meta>
			<haxe_doc>Resizes the image according to `algorithm`, to `newWidth` by `newHeight`.

		@param newWidth The width to resize to. if assigned to `-1`, the image resizes to the given `newHeight`, and keeps the aspect-ratio of the original image.
		@param newHeight The height to resize to. if assigned to `-1`, the image resizes to the given `newWidth`, and keeps the aspect-ratio of the original image.
		@param algorithm Which algorithm to use. You can use the algorithms available in `ImageResizeAlgorithm`. If no algorithm is specified, uses `ImageTools.defaultResizeAlgorithm`.
		@return this image, after resizing.</haxe_doc>
		</resize>
		<rotate public="1" get="inline" set="null" line="1160" static="1">
			<f a="this:angle:?degrees:?expandImageBounds" v="::true:true">
				<x path="vision.ds.ByteArray"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":value"><e>{ expandImageBounds : true, degrees : true }</e></m></meta>
			<haxe_doc>Rotates this image's pixel by `angle` degrees\radians.  
		Notice - rotating an image and then re-rotating to the image's previous state won't bring you exactly the same image.

		@param angle The angle to rotate by.
		@param degrees if `true`, `angle` is in degrees. Otherwise, `angle` is in radians.
		@param expandImageBounds Whether to expand the image's bounds to fit the rotated image. Default is `true`.</haxe_doc>
		</rotate>
		<toString public="1" set="method" line="1212" static="1">
			<f a="this:?special" v=":true">
				<x path="vision.ds.ByteArray"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ special : true }</e></m></meta>
			<haxe_doc>Gets the image as a string.

		@param special When using the `Console.hx` haxelib, images can be printed to the console
		with color. Set this to false if you don't want this to happen. Set to `true` by default.</haxe_doc>
		</toString>
		<forEachPixel public="1" get="inline" set="null" line="1232" static="1">
			<f a="this:callback">
				<x path="vision.ds.ByteArray"/>
				<f a="x:y:color">
					<x path="Int"/>
					<x path="Int"/>
					<x path="vision.ds.Color"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterates over each pixel inside this image, from left to right, top to bottom.
	    @param callback A function to dispatch on each pixel: Arguments contain the X & Y of the pixel, and its color.]]></haxe_doc>
		</forEachPixel>
		<forEachPixelInView public="1" get="inline" set="null" line="1250" static="1">
			<f a="this:callback">
				<x path="vision.ds.ByteArray"/>
				<f a="x:y:color">
					<x path="Int"/>
					<x path="Int"/>
					<x path="vision.ds.Color"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterates over each pixel inside this image, from left to right, top to bottom.

		This function differs from `forEachPixel` by not dispatching `callback()` 
		on pixels outside of the currently set `ImageView`.

		If an `ImageView` isn't set, this function will call `forEachPixel` instead to increase performance. 

		@param callback A function to dispatch on each pixel: Arguments contain the X & Y of the pixel, and its color. Won't dispatch for pixels outside of the currently set view.]]></haxe_doc>
		</forEachPixelInView>
		<iterator public="1" get="inline" set="null" line="1267" static="1">
			<f a="this">
				<x path="vision.ds.ByteArray"/>
				<t path="Iterator"><c path="vision.ds.Pixel"/></t>
			</f>
			<haxe_doc>Returns an iterator over this image's pixels.</haxe_doc>
		</iterator>
		<center public="1" get="inline" set="null" line="1274" static="1">
			<f a="this">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<haxe_doc>Returns a `Point2D` representing the center of the image</haxe_doc>
		</center>
		<pixelToRelative public="1" get="inline" set="null" line="1283" static="1">
			<f a="this:point">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<haxe_doc>Converts a `Point2D` from pixel coordinates (for example, `(121, 435)`) to relative coordinates, for this image (for example, `(0.5, 0.5)`).
		@param point A `Point2D` in pixel coordinates
		@return A `Point2D` in relative coordinates, such that: `R = (Px / W, Py / H)`</haxe_doc>
			<overloads><pixelToRelative public="1" get="inline" set="null" line="1293">
	<f a="this:x:y">
		<x path="vision.ds.ByteArray"/>
		<x path="Float"/>
		<x path="Float"/>
		<c path="vision.ds.Point2D"/>
	</f>
	<haxe_doc>Converts a `Point2D` from relative coordinates (for example, `(0.5, 0.5)`) to pixel coordinates, for this image (for example, `(121, 435)`).
		@param x The X component of the `Point2D` in relative coordinates
		@param y The Y component of the `Point2D` in relative coordinates
		@return A `Point2D` in pixel coordinates, such that: `P = (x * W, y * H)`</haxe_doc>
</pixelToRelative></overloads>
		</pixelToRelative>
		<relativeToPixel public="1" get="inline" set="null" line="1302" static="1">
			<f a="this:point">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<haxe_doc>Converts a `Point2D` from relative coordinates (for example, `(0.5, 0.5)`) to pixel coordinates, for this image (for example, `(121, 435)`).
		@param point A `Point2D` in relative coordinates
		@return A `Point2D` in pixel coordinates, such that: `P = (Rx * W, Ry * H)`</haxe_doc>
			<overloads><relativeToPixel public="1" get="inline" set="null" line="1312">
	<f a="this:x:y">
		<x path="vision.ds.ByteArray"/>
		<x path="Float"/>
		<x path="Float"/>
		<c path="vision.ds.Point2D"/>
	</f>
	<haxe_doc>Converts a `Point2D` from pixel coordinates (for example, `(121, 435)`) to relative coordinates, for this image (for example, `(0.5, 0.5)`).
		@param x The X component of the `Point2D` in pixel coordinates
		@param y The Y component of the `Point2D` in pixel coordinates
		@return A `Point2D` in relative coordinates, such that: `R = (x / W, y / H)`</haxe_doc>
</relativeToPixel></overloads>
		</relativeToPixel>
		<hasView public="1" get="inline" set="null" line="1326" static="1">
			<f a="this">
				<x path="vision.ds.ByteArray"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether or not this image currently has a view

		If `view`'s dimensions are all 0'ed out, or are greater than/the same as the image's dimensions, this will return false.</haxe_doc>
		</hasView>
		<setView public="1" get="inline" set="null" line="1346" static="1">
			<f a="this:view">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.ImageView"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Sets the current `ImageView`, and returns this image.

		If `view`'s dimensions are all 0'ed out, or are greater than/the same as the image's dimensions, `hasView()` will return false.

		If you want to remove the currently set `ImageView`, check out `removeView()`.

		@param view The `ImageView` to set to.
		@return This image, after applying the view.</haxe_doc>
		</setView>
		<getView public="1" get="inline" set="null" line="1358" static="1">
			<f a="this">
				<x path="vision.ds.ByteArray"/>
				<c path="vision.ds.ImageView"/>
			</f>
			<haxe_doc>Gets the currently set `ImageView`.</haxe_doc>
		</getView>
		<removeView public="1" get="inline" set="null" line="1371" static="1">
			<f a="this">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Removes the currently set `ImageView`, and returns this image.</haxe_doc>
		</removeView>
		<copyViewFrom public="1" get="inline" set="null" line="1383" static="1">
			<f a="this:from">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Copies the view from the given `Image` into this image.</haxe_doc>
		</copyViewFrom>
		<hasPixelInView public="1" get="inline" set="null" line="1406" static="1">
			<f a="this:x:y:?v">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="vision.ds.ImageView"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether or not the given pixel in coordinates `(x, y)` is inside the given `ImageView`, 
		or inside currently set `ImageView` (if `v` is `null`).

		If `v` is null, and this image's view isn't set (check out `hasView()` for more details), 
		this function calls `hasPixel()` to remove unnecessary calculations.

		@param x The x position of the pixel
		@param y The y position of the pixel
		@param v A view to check against, or `null` if you want to check against this image's view.
		@return Whether or not the given pixel is inside the view.</haxe_doc>
		</hasPixelInView>
		<from2DArray public="1" get="inline" set="null" line="1559" static="1">
			<f a="array">
				<c path="Array"><c path="Array"><x path="vision.ds.Color"/></c></c>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":from"/></meta>
			<haxe_doc>Takes a 2D array of colors, and returns an image `array[0].length` pixels wide and `array.length` pixels tall.

		The array is not altered.

		@param array the 2-dimensional color array. Make sure `array[0]`'s length is your desired image width.
		@return a new `Image`</haxe_doc>
		</from2DArray>
		<to2DArray public="1" get="inline" set="null" line="1588" static="1">
			<f a="this">
				<x path="vision.ds.ByteArray"/>
				<c path="Array"><c path="Array"><x path="vision.ds.Color"/></c></c>
			</f>
			<meta><m n=":to"/></meta>
			<haxe_doc>Returns a new, 2-dimensional array, with each cell containing the pixel on the image at it's indices (`array[x][y]` = `image.getPixel(x, y)`)
		@return a 2D array of colors.</haxe_doc>
		</to2DArray>
		<fromBytes public="1" get="inline" set="null" line="1607" static="1">
			<f a="bytes:width:?height">
				<x path="vision.ds.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>Takes a `ByteArray`/`haxe.io.Bytes` instance and some stats, and returns a new image instance
		that correctly represents the colors inside `bytes` at the given size
		@param bytes The byte array to be used. **Make it's color format is `ARGB`.** if it isn't, use `PixelFormat.convertPixelFormat(bytes, fromFormat, ARGB)`
		@param width The width of the returned image.
		@param height Optional, the height of the returned image. determined automatically, can be overridden by setting this parameter</haxe_doc>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="1627" static="1">
			<f a="this">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.ByteArray"/>
			</f>
			<meta><m n=":to"/></meta>
			<haxe_doc>Returns a `ByteArray` of format `ARGB` of the pixels of this image.
		@return A new `ByteArray`</haxe_doc>
			<overloads><toBytes public="1" get="inline" set="null" line="1636">
	<f a="this:?colorFormat" v=":ARGB">
		<x path="vision.ds.ByteArray"/>
		<x path="vision.ds.PixelFormat"/>
		<x path="vision.ds.ByteArray"/>
	</f>
	<meta><m n=":value"><e>{ colorFormat : ARGB }</e></m></meta>
	<haxe_doc>Returns a `ByteArray` of format `colorFormat` of the pixels of this image.
		@param colorFormat The wanted color format of the returned `ByteArray`.
		@return A new `ByteArray`</haxe_doc>
</toBytes></overloads>
		</toBytes>
		<image_or_image get="inline" set="null" line="1643" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":op"><e>A | B</e></m></meta>
		</image_or_image>
		<image_xor_image get="inline" set="null" line="1650" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":op"><e>A ^ B</e></m></meta>
		</image_xor_image>
		<image_and_image get="inline" set="null" line="1657" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Image"/>
				<x path="vision.ds.Image"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
		</image_and_image>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.ds._Image.PixelIterator" params="" file="src/vision/ds/Image.hx" private="1" module="vision.ds.Image">
		<i expr="4">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</i>
		<img><x path="vision.ds.Image"/></img>
		<next public="1" get="inline" set="null" line="1673"><f a=""><c path="vision.ds.Pixel"/></f></next>
		<hasNext public="1" get="inline" set="null" line="1681"><f a=""><x path="Bool"/></f></hasNext>
		<new public="1" get="inline" set="null" line="1669"><f a="img">
	<x path="vision.ds.Image"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="vision.ds.ImageFormat" params="" file="src/vision/ds/ImageFormat.hx">
		<this><x path="Int"/></this>
		<haxe_doc>The image format to encode in.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="vision.ds._ImageFormat.ImageFormat_Impl_" params="" file="src/vision/ds/ImageFormat.hx" private="1" module="vision.ds.ImageFormat" extern="1" final="1">
	<PNG public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="vision.ds.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>PNG encoding</haxe_doc>
	</PNG>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds._ImageFormat.ImageFormat_Impl_" params="" file="src/vision/ds/ImageFormat.hx" private="1" module="vision.ds.ImageFormat" extern="1" final="1">
		<PNG public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="vision.ds.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>PNG encoding</haxe_doc>
		</PNG>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="vision.ds.ImageResizeAlgorithm" params="" file="src/vision/ds/ImageResizeAlgorithm.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>The resize algorithm to use when changing the size of images.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="vision.ds._ImageResizeAlgorithm.ImageResizeAlgorithm_Impl_" params="" file="src/vision/ds/ImageResizeAlgorithm.hx" private="1" module="vision.ds.ImageResizeAlgorithm" extern="1" final="1">
	<NearestNeighbor public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="vision.ds.ImageResizeAlgorithm"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Nearest-Neighbor resizing. Works best for pixel art/resizing by powers of 2.</haxe_doc>
	</NearestNeighbor>
	<BilinearInterpolation public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="vision.ds.ImageResizeAlgorithm"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Bilinear Interpolation. The most reliable method for general resizing purposes. Yields the "least lossless" result.</haxe_doc>
	</BilinearInterpolation>
	<BicubicInterpolation public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="vision.ds.ImageResizeAlgorithm"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Unimplemented.</haxe_doc>
	</BicubicInterpolation>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds._ImageResizeAlgorithm.ImageResizeAlgorithm_Impl_" params="" file="src/vision/ds/ImageResizeAlgorithm.hx" private="1" module="vision.ds.ImageResizeAlgorithm" extern="1" final="1">
		<NearestNeighbor public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="vision.ds.ImageResizeAlgorithm"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Nearest-Neighbor resizing. Works best for pixel art/resizing by powers of 2.</haxe_doc>
		</NearestNeighbor>
		<BilinearInterpolation public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="vision.ds.ImageResizeAlgorithm"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Bilinear Interpolation. The most reliable method for general resizing purposes. Yields the "least lossless" result.</haxe_doc>
		</BilinearInterpolation>
		<BicubicInterpolation public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="vision.ds.ImageResizeAlgorithm"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Unimplemented.</haxe_doc>
		</BicubicInterpolation>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="vision.ds.ImageView" params="" file="src/vision/ds/ImageView.hx">
		<x public="1" expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":optional"/>
			</meta>
			<haxe_doc>The `x` position of the `ImageView`'s "bounding box"'s top-left corner.</haxe_doc>
		</x>
		<y public="1" expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":optional"/>
			</meta>
			<haxe_doc>The `y` position of the `ImageView`'s "bounding box"'s top-left corner.</haxe_doc>
		</y>
		<width public="1" expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":optional"/>
			</meta>
			<haxe_doc>The `ImageView`'s "bounding box"'s width.</haxe_doc>
		</width>
		<height public="1" expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":optional"/>
			</meta>
			<haxe_doc>The `ImageView`'s "bounding box"'s height.</haxe_doc>
		</height>
		<shape public="1" expr="RECTANGLE">
			<x path="vision.ds.ImageViewShape"/>
			<meta>
				<m n=":value"><e>RECTANGLE</e></m>
				<m n=":optional"/>
			</meta>
			<haxe_doc>The view's shape. 
        
        This determiens which pixels **inside** the bounding box are contained within the view, and which aren't.</haxe_doc>
		</shape>
		<toString public="1" set="method" line="28"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="4">
			<f a="?x:?y:?width:?height:?shape">
				<x path="Null"><x path="Int"/></x>
				<x path="Null"><x path="Int"/></x>
				<x path="Null"><x path="Int"/></x>
				<x path="Null"><x path="Int"/></x>
				<x path="Null"><x path="vision.ds.ImageViewShape"/></x>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc>@param shape The view's shape. 
        
        This determiens which pixels **inside** the bounding box are contained within the view, and which aren't.
@param height The `ImageView`'s "bounding box"'s height.
@param width The `ImageView`'s "bounding box"'s width.
@param y The `y` position of the `ImageView`'s "bounding box"'s top-left corner.
@param x The `x` position of the `ImageView`'s "bounding box"'s top-left corner.</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="vision.ds.ImageViewShape" params="" file="src/vision/ds/ImageViewShape.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="vision.ds._ImageViewShape.ImageViewShape_Impl_" params="" file="src/vision/ds/ImageViewShape.hx" private="1" module="vision.ds.ImageViewShape" extern="1" final="1">
	<RECTANGLE public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="vision.ds.ImageViewShape"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RECTANGLE>
	<RECTANGLE_INVERTED public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="vision.ds.ImageViewShape"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RECTANGLE_INVERTED>
	<ELLIPSE public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="vision.ds.ImageViewShape"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ELLIPSE>
	<ELLIPSE_INVERTED public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="vision.ds.ImageViewShape"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ELLIPSE_INVERTED>
	<RHOMBUS public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
		<x path="vision.ds.ImageViewShape"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RHOMBUS>
	<RHOMBUS_INVERTED public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
		<x path="vision.ds.ImageViewShape"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RHOMBUS_INVERTED>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds._ImageViewShape.ImageViewShape_Impl_" params="" file="src/vision/ds/ImageViewShape.hx" private="1" module="vision.ds.ImageViewShape" extern="1" final="1">
		<RECTANGLE public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="vision.ds.ImageViewShape"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RECTANGLE>
		<RECTANGLE_INVERTED public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="vision.ds.ImageViewShape"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RECTANGLE_INVERTED>
		<ELLIPSE public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="vision.ds.ImageViewShape"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ELLIPSE>
		<ELLIPSE_INVERTED public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="vision.ds.ImageViewShape"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ELLIPSE_INVERTED>
		<RHOMBUS public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
			<x path="vision.ds.ImageViewShape"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RHOMBUS>
		<RHOMBUS_INVERTED public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
			<x path="vision.ds.ImageViewShape"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RHOMBUS_INVERTED>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="vision.ds.Int16Point2D" params="" file="src/vision/ds/Int16Point2D.hx">
		<this><x path="Int"/></this>
		<to>
			<icast field="toPoint2D"><c path="vision.ds.Point2D"/></icast>
			<icast field="toIntPoint2D"><c path="vision.ds.Point2D"/></icast>
			<icast field="toInt"><x path="Int"/></icast>
		</to>
		<haxe_doc>A 2D point represented by 2, 16-bit integers.

	An abstract over a 32-bit `Int`, with its first 16 bits representing
	the X value, and the other bits representing the Y value

	**Attention - this is a pass-by-value type**</haxe_doc>
		<impl><class path="vision.ds._Int16Point2D.Int16Point2D_Impl_" params="" file="src/vision/ds/Int16Point2D.hx" private="1" module="vision.ds.Int16Point2D" final="1">
	<x public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>The `x` position of this `Int16Point2D`</haxe_doc>
	</x>
	<y public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>The `y` position of this `Int16Point2D`</haxe_doc>
	</y>
	<_new public="1" get="inline" set="null" line="24" static="1">
		<f a="?X:?Y" v="0:0">
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Int16Point2D"/>
		</f>
		<meta>
			<m n=":value"><e>{ Y : 0, X : 0 }</e></m>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<get_x get="inline" set="null" line="28" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_x>
	<set_x get="inline" set="null" line="31" static="1"><f a="this:x">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_x>
	<get_y get="inline" set="null" line="37" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_y>
	<set_y get="inline" set="null" line="41" static="1"><f a="this:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_y>
	<toString public="1" get="inline" set="null" line="50" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<haxe_doc>Returns a string representation of this `Int16Point2D`</haxe_doc>
	</toString>
	<toPoint2D public="1" get="inline" set="null" line="54" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="vision.ds.Point2D"/>
		</f>
		<meta><m n=":to"/></meta>
	</toPoint2D>
	<toIntPoint2D public="1" get="inline" set="null" line="58" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="vision.ds.Point2D"/>
		</f>
		<meta><m n=":to"/></meta>
	</toIntPoint2D>
	<toInt public="1" get="inline" set="null" line="62" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":to"/></meta>
	</toInt>
</class></impl>
	</abstract>
	<class path="vision.ds._Int16Point2D.Int16Point2D_Impl_" params="" file="src/vision/ds/Int16Point2D.hx" private="1" module="vision.ds.Int16Point2D" final="1">
		<x public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>The `x` position of this `Int16Point2D`</haxe_doc>
		</x>
		<y public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>The `y` position of this `Int16Point2D`</haxe_doc>
		</y>
		<_new public="1" get="inline" set="null" line="24" static="1">
			<f a="?X:?Y" v="0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Int16Point2D"/>
			</f>
			<meta>
				<m n=":value"><e>{ Y : 0, X : 0 }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<get_x get="inline" set="null" line="28" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_x>
		<set_x get="inline" set="null" line="31" static="1"><f a="this:x">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_x>
		<get_y get="inline" set="null" line="37" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_y>
		<set_y get="inline" set="null" line="41" static="1"><f a="this:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_y>
		<toString public="1" get="inline" set="null" line="50" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of this `Int16Point2D`</haxe_doc>
		</toString>
		<toPoint2D public="1" get="inline" set="null" line="54" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<meta><m n=":to"/></meta>
		</toPoint2D>
		<toIntPoint2D public="1" get="inline" set="null" line="58" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<meta><m n=":to"/></meta>
		</toIntPoint2D>
		<toInt public="1" get="inline" set="null" line="62" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":to"/></meta>
		</toInt>
	</class>
	<class path="vision.ds._IntPoint2D.Impl" params="" file="src/vision/ds/IntPoint2D.hx" private="1" module="vision.ds.IntPoint2D">
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<new public="1" get="inline" set="null" line="15"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="vision.ds.IntPoint2D" params="" file="src/vision/ds/IntPoint2D.hx">
		<from><icast field="fromPoint2D"><c path="vision.ds.Point2D"/></icast></from>
		<this><c path="vision.ds._IntPoint2D.Impl"/></this>
		<to><icast field="toPoint2D"><c path="vision.ds.Point2D"/></icast></to>
		<haxe_doc>A 2D point represented by two, 32-bit integers.</haxe_doc>
		<impl><class path="vision.ds._IntPoint2D.IntPoint2D_Impl_" params="" file="src/vision/ds/IntPoint2D.hx" private="1" module="vision.ds.IntPoint2D" final="1">
	<x public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>The `x` position of this `IntPoint2D`</haxe_doc>
	</x>
	<y public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>The `y` position of this `IntPoint2D`</haxe_doc>
	</y>
	<_new public="1" get="inline" set="null" line="37" static="1">
		<f a="x:y">
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.IntPoint2D"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<get_y get="inline" set="null" line="45" static="1"><f a="this">
	<c path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
</f></get_y>
	<get_x get="inline" set="null" line="53" static="1"><f a="this">
	<c path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
</f></get_x>
	<set_y get="inline" set="null" line="61" static="1"><f a="this:y">
	<c path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_y>
	<set_x get="inline" set="null" line="70" static="1"><f a="this:x">
	<c path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_x>
	<toPoint2D public="1" get="inline" set="null" line="79" static="1">
		<f a="this">
			<c path="vision.ds._IntPoint2D.Impl"/>
			<c path="vision.ds.Point2D"/>
		</f>
		<meta><m n=":to"/></meta>
	</toPoint2D>
	<fromPoint2D public="1" get="inline" set="null" line="83" static="1">
		<f a="p">
			<c path="vision.ds.Point2D"/>
			<x path="vision.ds.IntPoint2D"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromPoint2D>
	<toString public="1" get="inline" set="null" line="90" static="1">
		<f a="this">
			<c path="vision.ds._IntPoint2D.Impl"/>
			<c path="String"/>
		</f>
		<haxe_doc>Returns a `String` representations of this `IntPoint2D`.</haxe_doc>
	</toString>
	<copy public="1" get="inline" set="null" line="97" static="1">
		<f a="this">
			<c path="vision.ds._IntPoint2D.Impl"/>
			<x path="vision.ds.IntPoint2D"/>
		</f>
		<haxe_doc>Returns a new `IntPoint2D` instance, similar to this one.</haxe_doc>
	</copy>
	<distanceTo public="1" get="inline" set="null" line="109" static="1">
		<f a="this:point">
			<c path="vision.ds._IntPoint2D.Impl"/>
			<x path="vision.ds.IntPoint2D"/>
			<x path="Float"/>
		</f>
		<haxe_doc><![CDATA[Gets the distance between `this` and `point`.

		If `this` and `point` are have the same `x` & `y` position, `0` is returned.

		@param point The second point to calculate the distance to
		@return A `Float` representing the distance. `0` if `this` and `point` are congruent.]]></haxe_doc>
	</distanceTo>
	<degreesTo public="1" get="inline" set="null" line="122" static="1">
		<f a="this:point">
			<c path="vision.ds._IntPoint2D.Impl"/>
			<c path="vision.ds.Point2D"/>
			<x path="Float"/>
		</f>
		<haxe_doc><![CDATA[Gets the angle between `this` and `point`, in degrees.

		If `this` and `point` are have the same `x` & `y` position, `0` is returned.

		@param point The second point to calculate the angle to.
		@return A `Float` representing the angle, in degrees. `0` if `this` and `point` are congruent.]]></haxe_doc>
	</degreesTo>
	<radiansTo public="1" get="inline" set="null" line="134" static="1">
		<f a="this:point">
			<c path="vision.ds._IntPoint2D.Impl"/>
			<c path="vision.ds.Point2D"/>
			<x path="Float"/>
		</f>
		<haxe_doc><![CDATA[Gets the angle between `this` and `point`, in radians.

		If `this` and `point` are have the same `x` & `y` position, `0` is returned.

		@param point The second point to calculate the angle to.
		@return A `Float` representing the angle, in radians. `0` if `this` and `point` are congruent.]]></haxe_doc>
	</radiansTo>
</class></impl>
	</abstract>
	<class path="vision.ds._IntPoint2D.IntPoint2D_Impl_" params="" file="src/vision/ds/IntPoint2D.hx" private="1" module="vision.ds.IntPoint2D" final="1">
		<x public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>The `x` position of this `IntPoint2D`</haxe_doc>
		</x>
		<y public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>The `y` position of this `IntPoint2D`</haxe_doc>
		</y>
		<_new public="1" get="inline" set="null" line="37" static="1">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.IntPoint2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<get_y get="inline" set="null" line="45" static="1"><f a="this">
	<c path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
</f></get_y>
		<get_x get="inline" set="null" line="53" static="1"><f a="this">
	<c path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
</f></get_x>
		<set_y get="inline" set="null" line="61" static="1"><f a="this:y">
	<c path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_y>
		<set_x get="inline" set="null" line="70" static="1"><f a="this:x">
	<c path="vision.ds._IntPoint2D.Impl"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_x>
		<toPoint2D public="1" get="inline" set="null" line="79" static="1">
			<f a="this">
				<c path="vision.ds._IntPoint2D.Impl"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<meta><m n=":to"/></meta>
		</toPoint2D>
		<fromPoint2D public="1" get="inline" set="null" line="83" static="1">
			<f a="p">
				<c path="vision.ds.Point2D"/>
				<x path="vision.ds.IntPoint2D"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromPoint2D>
		<toString public="1" get="inline" set="null" line="90" static="1">
			<f a="this">
				<c path="vision.ds._IntPoint2D.Impl"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a `String` representations of this `IntPoint2D`.</haxe_doc>
		</toString>
		<copy public="1" get="inline" set="null" line="97" static="1">
			<f a="this">
				<c path="vision.ds._IntPoint2D.Impl"/>
				<x path="vision.ds.IntPoint2D"/>
			</f>
			<haxe_doc>Returns a new `IntPoint2D` instance, similar to this one.</haxe_doc>
		</copy>
		<distanceTo public="1" get="inline" set="null" line="109" static="1">
			<f a="this:point">
				<c path="vision.ds._IntPoint2D.Impl"/>
				<x path="vision.ds.IntPoint2D"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[Gets the distance between `this` and `point`.

		If `this` and `point` are have the same `x` & `y` position, `0` is returned.

		@param point The second point to calculate the distance to
		@return A `Float` representing the distance. `0` if `this` and `point` are congruent.]]></haxe_doc>
		</distanceTo>
		<degreesTo public="1" get="inline" set="null" line="122" static="1">
			<f a="this:point">
				<c path="vision.ds._IntPoint2D.Impl"/>
				<c path="vision.ds.Point2D"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[Gets the angle between `this` and `point`, in degrees.

		If `this` and `point` are have the same `x` & `y` position, `0` is returned.

		@param point The second point to calculate the angle to.
		@return A `Float` representing the angle, in degrees. `0` if `this` and `point` are congruent.]]></haxe_doc>
		</degreesTo>
		<radiansTo public="1" get="inline" set="null" line="134" static="1">
			<f a="this:point">
				<c path="vision.ds._IntPoint2D.Impl"/>
				<c path="vision.ds.Point2D"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[Gets the angle between `this` and `point`, in radians.

		If `this` and `point` are have the same `x` & `y` position, `0` is returned.

		@param point The second point to calculate the angle to.
		@return A `Float` representing the angle, in radians. `0` if `this` and `point` are congruent.]]></haxe_doc>
		</radiansTo>
	</class>
	<enum path="vision.ds.Kernel2D" params="" file="src/vision/ds/Kernel2D.hx">
		<Identity><haxe_doc>* This kernel preserves the image's pixel data.
	 * 
	 * ```
	 * 0  0  0
	 * 0  1  0
	 * 0  0  0
	 * ```
	 * 
	 * Original:
	 * 
	 * ![Pre-processed](https://upload.wikimedia.org/wikipedia/commons/5/50/Vd-Orig.png)
	 * 
	 * Convolved:
	 * 
	 * ![Post-processed](https://upload.wikimedia.org/wikipedia/commons/5/50/Vd-Orig.png)</haxe_doc></Identity>
		<BoxBlur><haxe_doc>* This kernel applies a nearest-neighbor style blurring to the image.
	 * 
	 * ```
	 * 1  1  1
	 * 1  1  1
	 * 1  1  1
	 * ```
	 * 
	 * Original:
	 * 
	 * ![Pre-processed](https://upload.wikimedia.org/wikipedia/commons/5/50/Vd-Orig.png)
	 * 
	 * Convolved:
	 * 
	 * ![Post-processed](https://upload.wikimedia.org/wikipedia/commons/0/04/Vd-Blur2.png)</haxe_doc></BoxBlur>
		<LaplacianPositive><haxe_doc>* This kernel applies a Positive Laplacian Operator:
	 * 
	 * ```
	 * 0  1  0
	 * 1  -4 1
	 * 0  1  0
	 * ```
	 * 
	 * Original:
	 * 
	 * ![Pre-processed](https://upload.wikimedia.org/wikipedia/commons/5/50/Vd-Orig.png)
	 * 
	 * Convolved:
	 * 
	 * ![Post-processed](https://upload.wikimedia.org/wikipedia/commons/0/04/Vd-Orig.png)</haxe_doc></LaplacianPositive>
		<LaplacianNegative><haxe_doc>* This kernel applies a Negative Laplacian Operator:
	 * 
	 * ```
	 * 0  -1  0
	 * -1  4 -1
	 * 0  -1  0
	 * ```
	 * 
	 * Original:
	 * 
	 * ![Pre-processed](https://upload.wikimedia.org/wikipedia/commons/5/50/Vd-Orig.png)
	 * 
	 * Convolved:
	 * 
	 * ![Post-processed](https://upload.wikimedia.org/wikipedia/commons/0/04/Vd-Orig.png)</haxe_doc></LaplacianNegative>
		<RidgeDetection><haxe_doc><![CDATA[* This kernel is often used to detect changes of surface level in an image.
	 * 
	 * For a more aggressive kernel, see `RidgeDetectionAggressive`
	 * 
	 * ```
	 * -1  -1  -1
	 * -1  +4  -1
	 * -1  -1  -1
	 * ```
	 *
	 * Original:
	 * 
	 * ![Pre-processed](https://upload.wikimedia.org/wikipedia/commons/5/50/Vd-Orig.png)
	 * 
	 * Convolved (Normalized & Range Limited):
	 * 
	 * ![Post-processed](https://upload.wikimedia.org/wikipedia/commons/2/20/Vd-Rige1.png)]]></haxe_doc></RidgeDetection>
		<RidgeDetectionAggressive><haxe_doc><![CDATA[* This kernel is often used to detect changes of surface level in an image.
	 * 
	 * This kernel is more sensitive to surface changes than its softer counterpart.
	 * 
	 * ```
	 * -1  -1  -1
	 * -1  +7  -1
	 * -1  -1  -1
	 * ```
	 *
	 * Original:
	 * 
	 * ![Pre-processed](https://upload.wikimedia.org/wikipedia/commons/5/50/Vd-Orig.png)
	 * 
	 * Convolved (Normalized & Range Limited):
	 * 
	 * ![Post-processed](https://upload.wikimedia.org/wikipedia/commons/0/0b/Vd-Rige2.png)]]></haxe_doc></RidgeDetectionAggressive>
		<Sharpen><haxe_doc>* This kernel is often used to sharpen, or "deepfry" an image. It highlights
	 * the change in pixel values where colors in the image change dramatically
	 * from one pixel to the other.
	 * 
	 * ```
	 * +0  -1  +0
	 * -1  +5  -1
	 * +0  -1  +0
	 * ``` 
	 * Original:
	 * 
	 * ![Pre-processed](https://upload.wikimedia.org/wikipedia/commons/5/50/Vd-Orig.png)
	 * 
	 * Convolved:
	 * 
	 * ![Post-processed](https://upload.wikimedia.org/wikipedia/commons/4/4e/Vd-Sharp.png)</haxe_doc></Sharpen>
		<UnsharpMasking><haxe_doc>* Based on the `Gaussian Blur`, this kernel doesn't actually blur the image, but
	 * uses a similar filter to slightly sharpen the image, while retaining the image's
	 * quality. Can be used to slightly increase the quality of a blurry image.
	 * 
	 * ```
	 * 1  4  6   4  1
	 * 4 16  24  16 4
	 * 6 24 -476 24 6
	 * 4 16  24  16 4
	 * 1  4  6   4  1
	 * ```
	 * 
	 * Original:
	 * 
	 * ![Pre-processed](https://upload.wikimedia.org/wikipedia/commons/5/50/Vd-Orig.png)
	 * 
	 * Convolved:
	 * 
	 * ![Post-processed](https://upload.wikimedia.org/wikipedia/commons/e/ef/Vd-Unsharp_5x5.png)</haxe_doc></UnsharpMasking>
		<Assemble3x3 a="corner:edge:center">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<haxe_doc>* Makes a 3x3 kernel, following this structure:
	 * 
	 * |     |   1    |   2    |   3    |
	 * |:---:| :---:  | :---:  | :---:  |
	 * |  1  |`corner`|` edge `|`corner`|
	 * |  2  |` edge` |`center`|` edge `|
	 * |  3  |`corner`|` edge `|`corner`|
	 * 
	 *</haxe_doc>
		</Assemble3x3>
		<Assemble5x5 a="farCorner:farEdge:edge:midCorner:midEdge:center">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<haxe_doc><![CDATA[* Makes a 5x5 kernel, following this structure:
	 * 
	 * |     |     1     |     2     |    3    |     4     |     5     |
	 * |:---:|   :---:   |   :---:   |  :---:  |   :---:   |   :---:   |
	 * |  1  |`farCorner`|`farEdge`  |`edge`   |`farEdge`  |`farCorner`|
	 * |&nbsp;||||||
	 * |  2  |`farEdge`  |`midCorner`|`midEdge`|`midCorner`|`farEdge`  |
	 * |&nbsp;||||||
	 * |  3  |`edge`     |`midEdge`  |`center` |`midEdge`  |`edge`     |
	 * |&nbsp;||||||
	 * |  4  |`farEdge`  |`midCorner`|`midEdge`|`midCorner`|`farEdge`  |
	 * |&nbsp;||||||
	 * |  5  |`farCorner`|`farEdge`  |`edge`   |`farEdge`  |`farCorner`|
	 * 
	 *]]></haxe_doc>
		</Assemble5x5>
		<Custom a="kernel">
			<c path="Array"><c path="Array"><x path="Float"/></c></c>
			<haxe_doc>* make a kernel without any special tools.
	 * 
	 * Usage:
	 * 
	 *      Custom([
	 *          [0, 1, 0],
	 *          [0, 1, 0],
	 *          [0, 1, 0],
	 *      ])</haxe_doc>
		</Custom>
		<GaussianBlur a="size:sigma">
			<x path="vision.ds.gaussian.GaussianKernelSize"/>
			<x path="Float"/>
			<haxe_doc><![CDATA[* Generates a gaussian kernel of size `size`x`size`, and uses `sigma` for the distribution factor.
	 * 
	 * Example of an (approximated) 5x5 gaussian kernel:
	 * 
	 * ```
	 * 1  4  6  4  1
	 * 4 16  24 16 4
	 * 6 24  36 24 6
	 * 4 16  24 16 4
	 * 1  4  6  4  1
	 * ```
	 * 
	 * Original:
	 * 
	 * ![Pre-Processed](https://upload.wikimedia.org/wikipedia/commons/5/50/Vd-Orig.png)
	 * 
	 * `GaussianBlur(X3, 1)`, `GaussianBlur(X5, 1)`:
	 * 
	 * ![Post-Processed](https://upload.wikimedia.org/wikipedia/commons/2/28/Vd-Blur1.png)&nbsp;,&nbsp;![Post-Processed](https://upload.wikimedia.org/wikipedia/commons/0/04/Vd-Blur_Gaussian_5x5.png)]]></haxe_doc>
		</GaussianBlur>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="vision.ds.Line2D" params="" file="src/vision/ds/Line2D.hx">
		<fromRay2D public="1" get="inline" set="null" line="99" static="1">
			<f a="ray">
				<c path="vision.ds.Ray2D"/>
				<c path="vision.ds.Line2D"/>
			</f>
			<haxe_doc><![CDATA[Takes an instance of `Ray2D`, and returns a new `Line2D` with the same direction.

		The `start` & `end` point may not be consistent. Set them manually if you need to.]]></haxe_doc>
		</fromRay2D>
		<length public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>The distance between `start` and `end`</haxe_doc>
		</length>
		<slope public="1" set="null">
			<x path="Float"/>
			<haxe_doc>The slope of the line stretched from `start` to `end`</haxe_doc>
		</slope>
		<degrees public="1" set="null">
			<x path="Float"/>
			<haxe_doc>The degrees of the line stretched from `start` to `end`</haxe_doc>
		</degrees>
		<radians public="1" set="null">
			<x path="Float"/>
			<haxe_doc>The radians of the line stretched from `start` to `end`</haxe_doc>
		</radians>
		<start public="1" set="accessor" expr="{ x : 0, y : 0 }">
			<c path="vision.ds.Point2D"/>
			<meta><m n=":value"><e>{ x : 0, y : 0 }</e></m></meta>
			<haxe_doc>The starting point of this `Line2D`.</haxe_doc>
		</start>
		<end public="1" set="accessor" expr="{ x : 0, y : 0 }">
			<c path="vision.ds.Point2D"/>
			<meta><m n=":value"><e>{ x : 0, y : 0 }</e></m></meta>
			<haxe_doc>The ending point of this `Line2D`.</haxe_doc>
		</end>
		<middle public="1" get="accessor" set="accessor">
			<c path="vision.ds.Point2D"/>
			<haxe_doc>The middle point of this `Line2D`</haxe_doc>
		</middle>
		<get_length get="inline" set="null" line="58"><f a=""><x path="Float"/></f></get_length>
		<intersect public="1" set="method" line="70">
			<f a="line">
				<c path="vision.ds.Line2D"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<haxe_doc>Gets the intersection point between `this` and `line`.

		If `this` and `line` don't intersect, `null` is returned.

		@param line The second line to intersect with.
		@return A `Point2D` instance, `null` if `this` and `line` don't intersect.</haxe_doc>
		</intersect>
		<distanceTo public="1" set="method" line="82">
			<f a="line">
				<c path="vision.ds.Line2D"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Gets the distance between `this` and `line`.

		If `this` and `line` intersect, `0` is returned.

		@param line The second line to calculate the distance to.
		@return A `Float` representing the distance. `0` if `this` and `line` intersect.</haxe_doc>
		</distanceTo>
		<toString public="1" get="inline" set="null" line="90">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Returns a `String` representation of this `Line2D`.</haxe_doc>
		</toString>
		<toRay2D public="1" get="inline" set="null" line="110">
			<f a=""><c path="vision.ds.Ray2D"/></f>
			<haxe_doc>Constructs a new `Ray2D` using this `Line2D`'s start point and slope.</haxe_doc>
		</toRay2D>
		<set_start get="inline" set="null" line="114"><f a="value">
	<c path="vision.ds.Point2D"/>
	<c path="vision.ds.Point2D"/>
</f></set_start>
		<set_end get="inline" set="null" line="121"><f a="value">
	<c path="vision.ds.Point2D"/>
	<c path="vision.ds.Point2D"/>
</f></set_end>
		<get_middle get="inline" set="null" line="128"><f a=""><c path="vision.ds.Point2D"/></f></get_middle>
		<set_middle get="inline" set="null" line="132"><f a="value">
	<c path="vision.ds.Point2D"/>
	<c path="vision.ds.Point2D"/>
</f></set_middle>
		<new public="1" get="inline" set="null" line="48">
			<f a="start:end">
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Point2D"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Constructs a new `Line2D` from two `Point2D`s</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Represents a 2-dimensional line, by `start` & `end` point]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="vision.ds.Matrix2D" params="" file="src/vision/ds/Matrix2D.hx">
		<from>
			<icast><c path="vision.ds.Array2D"><x path="Float"/></c></icast>
			<icast field="from_array_array_float"><c path="Array"><c path="Array"><x path="Float"/></c></c></icast>
			<icast field="from_array_array_int"><c path="Array"><c path="Array"><x path="Int"/></c></c></icast>
		</from>
		<this><c path="vision.ds.Array2D"><x path="Float"/></c></this>
		<to>
			<icast><c path="vision.ds.Array2D"><x path="Float"/></c></icast>
			<icast field="to_array_array_float"><c path="Array"><c path="Array"><x path="Float"/></c></c></icast>
		</to>
		<haxe_doc>Represents a transformation matrix, used for warping images in one way or another.  
	A matrix warps an image by multiplying each pixel's coordinates by the matrix, as follows:
	```txt
	â”Œ             â”   
	â”‚ aâ‚€â‚€ aâ‚€â‚ aâ‚€â‚‚ â”‚   â”Œ       â”
	â”‚ aâ‚â‚€ aâ‚â‚ aâ‚â‚‚ â”‚ â— â”‚ x y 1 â”‚
	â”‚ aâ‚‚â‚€ aâ‚‚â‚ aâ‚‚â‚‚ â”‚   â””       â”˜
	â””             â”˜   
	```
	where `x` and `y` are the coordinates of the pixel, `1` is, well, `1`, and `aâ‚™ â‚™` represents a value in the matrix.

	multiplication is done by multiplying each row in one matrix by its corresponding column in the other (nâ‚œâ‚• row to nâ‚œâ‚• column):
	```txt
	â”Œ             â”   
	â”‚ aâ‚€â‚€ aâ‚€â‚ aâ‚€â‚‚ â”‚   â”Œ       â”    â”Œ                                                          â”
	â”‚ aâ‚â‚€ aâ‚â‚ aâ‚â‚‚ â”‚ â— â”‚ x y 1 â”‚ âŸ¹ â”‚ x(aâ‚€â‚€ + aâ‚€â‚ + aâ‚€â‚‚) y(aâ‚â‚€ + aâ‚â‚ + aâ‚â‚‚) 1(aâ‚‚â‚€ + aâ‚‚â‚ + aâ‚‚â‚‚) â”‚
	â”‚ aâ‚‚â‚€ aâ‚‚â‚ aâ‚‚â‚‚ â”‚   â””       â”˜    â””                                                          â”˜
	â””             â”˜   
	```

	---

	For your comfort, some simple transformation matrices are already provided, and accessible as a static property of `Matrix2D`.


	@see For a general purpose, not-necessarily-mathematic matrix - `Array2D`
	@see For provided convolution matrices - `Kernel2D`</haxe_doc>
		<meta><m n=":forward">
	<e>get</e>
	<e>set</e>
	<e>fill</e>
	<e>width</e>
	<e>height</e>
</m></meta>
		<impl><class path="vision.ds._Matrix2D.Matrix2D_Impl_" params="" file="src/vision/ds/Matrix2D.hx" private="1" module="vision.ds.Matrix2D" final="1">
	<underlying public="1" get="accessor" set="accessor" static="1">
		<c path="vision.ds.Array2D"><x path="Float"/></c>
		<haxe_doc>The underlying `Array2D` instance</haxe_doc>
	</underlying>
	<get_underlying get="inline" set="null" line="48" static="1"><f a="this">
	<c path="vision.ds.Array2D"><x path="Float"/></c>
	<c path="vision.ds.Array2D"><x path="Float"/></c>
</f></get_underlying>
	<set_underlying get="inline" set="null" line="52" static="1"><f a="this:arr2d">
	<c path="vision.ds.Array2D"><x path="Float"/></c>
	<c path="vision.ds.Array2D"><x path="Float"/></c>
	<c path="vision.ds.Array2D"><x path="Float"/></c>
</f></set_underlying>
	<rows public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>The amount of rows this matrix contains. Equivalent to `this.height`</haxe_doc>
	</rows>
	<get_rows get="inline" set="null" line="61" static="1">
		<f a="this">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</get_rows>
	<set_rows get="inline" set="null" line="64" static="1">
		<f a="this:amount">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</set_rows>
	<columns public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>The amount of columns this matrix contains. Equivalent to `this.width`</haxe_doc>
	</columns>
	<get_columns get="inline" set="null" line="73" static="1">
		<f a="this">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</get_columns>
	<set_columns get="inline" set="null" line="76" static="1">
		<f a="this:amount">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</set_columns>
	<_new public="1" get="inline" set="null" line="87" static="1">
		<f a="width:height">
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
		<haxe_doc>Creates a new, empty `Matrix2D`
	    @param width the amount of elements in each row
	    @param height the amount of rows</haxe_doc>
	</_new>
	<invert public="1" get="inline" set="null" line="95" static="1">
		<f a="this">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<haxe_doc>Inverts this `Matrix2D` using Gauss-Jordan elimination
        @return this `Matrix2D`, after it has been inverted</haxe_doc>
	</invert>
	<getDeterminant public="1" get="inline" set="null" line="102" static="1">
		<f a="this">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Float"/>
		</f>
		<haxe_doc>Gets the determinant of this `Matrix2D`.</haxe_doc>
	</getDeterminant>
	<getTrace public="1" get="inline" set="null" line="134" static="1">
		<f a="this">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Float"/>
		</f>
		<haxe_doc>Returns the trace of this `Matrix2D`.

		Trace is the sum of the elements on the diagonal, spanning from `(0, 0)` to `(w, h)` when `w = h`.
		
		@throws MatrixOperationError if the matrix is not a square matrix, i.e. `w != h`</haxe_doc>
	</getTrace>
	<multiplyWithScalar public="1" get="inline" set="null" line="147" static="1">
		<f a="this:scalar">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Float"/>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<haxe_doc>Multiplies this `Matrix2D` with a given scalar (a number).</haxe_doc>
	</multiplyWithScalar>
	<clone public="1" get="inline" set="null" line="162" static="1">
		<f a="this">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<haxe_doc>Return a copy of this `Matrix2D`</haxe_doc>
	</clone>
	<map public="1" get="inline" set="null" line="172" static="1">
		<f a="this:mappingFunction">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<haxe_doc>Manipulates each element of this `Matrix2D` with the given function, and
		returns a new `Matrix2D` with the manipulated elements.

		@param mappingFunction the function to apply to each element. Should take a `Float`, and return a `Float`.</haxe_doc>
	</map>
	<getSubMatrix public="1" get="inline" set="null" line="191" static="1">
		<f a="this:?fromX:?fromY:?toX:?toY" v=":0:0::">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<meta><m n=":value"><e>{ fromY : 0, fromX : 0 }</e></m></meta>
		<haxe_doc>Returns a new matrix, containing the elements of this matrix, starting at 
        (`fromX`, `fromY`) and ending at `toX`, `toY`.

        @param fromX The `x` coordinate of the top left corner from which we start reading. Defaults to `0`.
        @param fromY The `y` coordinate of the top left corner from which we start reading. Defaults to `0`.
        @param toX The `x` coordinate of the bottom right corner at which we stop reading. Defaults to `this.width`.
        @param toY The `y` coordinate of the bottom right corner at which we stop reading. Defaults to `this.height`.
        @return Matrix2D</haxe_doc>
	</getSubMatrix>
	<getColumn public="1" get="inline" set="null" line="216" static="1">
		<f a="this:x">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Int"/>
			<c path="Array"><x path="Float"/></c>
		</f>
		<haxe_doc>Returns an array containing the elements at the column `x`, from top to bottom.</haxe_doc>
	</getColumn>
	<getRow public="1" get="inline" set="null" line="223" static="1">
		<f a="this:y">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Int"/>
			<c path="Array"><x path="Float"/></c>
		</f>
		<haxe_doc>Returns an array containing the elements at the row `y`, from left to right.</haxe_doc>
	</getRow>
	<setColumn public="1" get="inline" set="null" line="233" static="1">
		<f a="this:x:arr">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Int"/>
			<c path="Array"><x path="Float"/></c>
			<x path="Void"/>
		</f>
		<haxe_doc>Replaces the elements of the column at index `x` with the elements in `arr`

        @param x the 0-based index of the column
        @param arr the new column. Must be at least of the same length as the matrix' height</haxe_doc>
	</setColumn>
	<setRow public="1" get="inline" set="null" line="244" static="1">
		<f a="this:y:arr">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Int"/>
			<c path="Array"><x path="Float"/></c>
			<x path="Void"/>
		</f>
		<haxe_doc>Replaces the elements of the row at index `y` with the elements in `arr`

        @param y the 0-based index of the row
        @param arr the new row. Must be at least of the same length as the matrix' width</haxe_doc>
	</setRow>
	<insertColumn public="1" get="inline" set="null" line="256" static="1">
		<f a="this:x:arr">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Int"/>
			<c path="Array"><x path="Float"/></c>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<haxe_doc>Inserts an entire column right before the column at index `x`.

        @param x the 0-based index of the column to insert at
        @param arr the column to insert
        @return this modified `Matrix2D`</haxe_doc>
	</insertColumn>
	<insertRow public="1" get="inline" set="null" line="274" static="1">
		<f a="this:y:arr">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Int"/>
			<c path="Array"><x path="Float"/></c>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<haxe_doc>Inserts an entire row right before the row at index `y`.

        @param y the 0-based index of the row to insert at
        @param arr the row to insert
        @return this modified `Matrix2D`</haxe_doc>
	</insertRow>
	<removeColumn public="1" get="inline" set="null" line="291" static="1">
		<f a="this:x">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Int"/>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<haxe_doc>Removes an entire column from this `Matrix2D`.

        @param x the 0-based index of the column to remove
        @return this modified `Matrix2D`</haxe_doc>
	</removeColumn>
	<removeRow public="1" get="inline" set="null" line="307" static="1">
		<f a="this:y">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Int"/>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<haxe_doc>Removes an entire row from this `Matrix2D`.

        @param y the 0-based index of the row to remove
        @return this modified `Matrix2D`</haxe_doc>
	</removeRow>
	<toString public="1" get="inline" set="null" line="325" static="1">
		<f a="this:?precision:?pretty" v=":5:true">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="Int"/>
			<x path="Bool"/>
			<c path="String"/>
		</f>
		<meta><m n=":value"><e>{ pretty : true, precision : 5 }</e></m></meta>
		<haxe_doc>Returns a string representation of this `Matrix2D`.

        @param precision How many numbers beyond the decimal point to display. Only relevant when `pretty` is set to `true`
        @param pretty Whether to return a pretty-print of the matrix or not. 
        A pretty print adds a distinct matrix border, centered numbers, and ellipsis where numbers are truncated.</haxe_doc>
	</toString>
	<IDENTITY public="1" get="inline" set="null" line="410" static="1">
		<f a=""><x path="vision.ds.TransformationMatrix2D"/></f>
		<haxe_doc>Generates an identity matrix.</haxe_doc>
	</IDENTITY>
	<ROTATION public="1" get="inline" set="null" line="425" static="1">
		<f a="angle:?degrees:?origin" v=":true:null">
			<x path="Float"/>
			<x path="Bool"/>
			<c path="vision.ds.Point2D"/>
			<x path="vision.ds.TransformationMatrix2D"/>
		</f>
		<meta><m n=":value"><e>{ origin : null, degrees : true }</e></m></meta>
		<haxe_doc>Generates a rotation matrix of `angle` degrees/radians.

        @param angle The angle at which to rotate. goes counter-clockwise.
        @param degrees Whether `angle` is given in degrees or radians. Defaults to degrees.
		@param origin The point around which to rotate. Defaults to `(0, 0)`, which means the top-left corner.</haxe_doc>
	</ROTATION>
	<TRANSLATION public="1" get="inline" set="null" line="440" static="1">
		<f a="?x:?y" v="0:0">
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.TransformationMatrix2D"/>
		</f>
		<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		<haxe_doc>Generates a translation matrix that displaces the graphic 
        inside the image `x` pixels to the right and `y` pixels to the bottom.

        @param x Displacement in pixels to the right. Default value is 0.
        @param y Displacement in pixels to the bottom. Default value is 0.</haxe_doc>
	</TRANSLATION>
	<SCALE public="1" get="inline" set="null" line="454" static="1">
		<f a="?scaleX:?scaleY" v="1:1">
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.TransformationMatrix2D"/>
		</f>
		<meta><m n=":value"><e>{ scaleY : 1, scaleX : 1 }</e></m></meta>
		<haxe_doc>Generates a scaling matrix that "stretches" the width to the new width of `scaleX` * `width`,
        and the height to the new height of `scaleY` * `height`.
        @param scaleX Scaling along the X axis. Default value is 1.
        @param scaleY Scealing along the Y axis. Default value is 1.</haxe_doc>
	</SCALE>
	<SHEAR public="1" get="inline" set="null" line="469" static="1">
		<f a="?shearX:?shearY" v="0:0">
			<x path="Float"/>
			<x path="Float"/>
			<x path="vision.ds.TransformationMatrix2D"/>
		</f>
		<meta><m n=":value"><e>{ shearY : 0, shearX : 0 }</e></m></meta>
		<haxe_doc>Generates a shearing matrix that "skews" the slope of the image's edges in the x, y and z axis by `-1/shear`.
        For example, if `shearX` is `0.5`, the image is skewed horizontally, such that the slope of the two vertical edges becomes `-2`.

        @param shearX The amount of shearing done on the x-axis, or in other words, when dividing `-1` by `shearX`, determines the slope of the image on the vertical edges.
        @param shearY The amount of shearing done on the y-axis, or in other words, when dividing `-1` by `shearY`, determines the slope of the image on the horizontal edges.</haxe_doc>
	</SHEAR>
	<REFLECTION public="1" get="inline" set="null" line="483" static="1">
		<f a="angle:?degrees:?origin" v=":true:null">
			<x path="Float"/>
			<x path="Bool"/>
			<c path="vision.ds.Point2D"/>
			<x path="vision.ds.TransformationMatrix2D"/>
		</f>
		<meta><m n=":value"><e>{ origin : null, degrees : true }</e></m></meta>
		<haxe_doc>Generates a reflection matrix that "mirrors" an image along the axis which is `angle` degrees/radians form the `x` axis.
    	@param angle The angle at which to reflect. goes counter-clockwise.
        @param degrees Whether `angle` is given in degrees or radians. Defaults to degrees.
		@param origin The point around which to reflect. Defaults to `(0, 0)`, which means the top-left corner.</haxe_doc>
	</REFLECTION>
	<PERSPECTIVE public="1" get="inline" set="null" line="498" static="1">
		<f a="pointPairs">
			<c path="Array"><c path="vision.ds.specifics.PointTransformationPair"/></c>
			<x path="vision.ds.TransformationMatrix2D"/>
		</f>
		<haxe_doc>Generates a perspective warp matrix, that tweaks the perspective of an image, such
        that points at `pointPairs[n].from` will end up in the position `pointPairs[n].to`.

        @param pointPairs 4 pairs of points to "pin-point" the transform on.</haxe_doc>
	</PERSPECTIVE>
	<DEPTH public="1" get="inline" set="null" line="515" static="1">
		<f a="z:?towards">
			<x path="Float"/>
			<c path="vision.ds.Point2D"/>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<haxe_doc>Generates a translation matrix, that displaces the graphic in only the `z` axis.
        a positive `z` moves the graphic backwards, 
        while a value that approaches 0 moves the graphic forward.

        @param z  Displacement in pixels to the back.
		@param towards The point the graphic goes towards, as in, when `z` approaches positive infinity, the graphic goes towards that point. Defaults to `(0, 0)`.</haxe_doc>
	</DEPTH>
	<createFilled public="1" get="inline" set="null" line="529" static="1">
		<f a="rows">
			<x path="haxe.Rest"><c path="Array"><x path="Float"/></c></x>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<haxe_doc><![CDATA[Creates a new `Matrix2D` filled with `rows`, and of `rows.length` height.

	    @param rows multiple parameters of type `Array<Float>`, or a single, `Array<Array<Float>>` preceded by a `...` 
	    @return A `Matrix2D` instance.]]></haxe_doc>
	</createFilled>
	<createTransformation public="1" get="inline" set="null" line="547" static="1">
		<f a="xRow:yRow:?homogeneousRow">
			<c path="Array"><x path="Float"/></c>
			<c path="Array"><x path="Float"/></c>
			<c path="Array"><x path="Float"/></c>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<haxe_doc>Helper function to generate a transformation matrix, 
        exists as sort of a guide for the creation of such matrix.

        @param xRow The first row of the matrix. Will be the row deciding the transformed `x` position of a point.
        @param yRow The second row of the matrix. Will be the row deciding the transformed `y` position of a point.
        @param homogeneousRow The third row of the matrix. On affine transformations (or, ones that are entirely 2D)
        This should be set to `[0, 0, 1]`. On perspective transformations, used to decide the `z` coordinate of a given point.
        When casted back into a 2D point, the point's `z` coordinate is used as a denominator for the other `x` and `y` coordinates.
        @return The newly created `Matrix2D`</haxe_doc>
	</createTransformation>
	<multiplyMatrices public="1" get="inline" set="null" line="567" static="1">
		<f a="a:b">
			<x path="vision.ds.Matrix2D"/>
			<x path="vision.ds.Matrix2D"/>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<meta><m n=":op"><e>A * B</e></m></meta>
	</multiplyMatrices>
	<addMatrices public="1" get="inline" set="null" line="585" static="1">
		<f a="a:b">
			<x path="vision.ds.Matrix2D"/>
			<x path="vision.ds.Matrix2D"/>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</addMatrices>
	<subtractMatrices public="1" get="inline" set="null" line="600" static="1">
		<f a="a:b">
			<x path="vision.ds.Matrix2D"/>
			<x path="vision.ds.Matrix2D"/>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</subtractMatrices>
	<divideMatrices public="1" get="inline" set="null" line="615" static="1">
		<f a="a:b">
			<x path="vision.ds.Matrix2D"/>
			<x path="vision.ds.Matrix2D"/>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<meta><m n=":op"><e>A / B</e></m></meta>
	</divideMatrices>
	<multiply public="1" get="inline" set="null" line="634" static="1">
		<f a="this:b">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="vision.ds.Matrix2D"/>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<meta><m n=":op"><e>A *= B</e></m></meta>
	</multiply>
	<add public="1" get="inline" set="null" line="654" static="1">
		<f a="this:b">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="vision.ds.Matrix2D"/>
			<d/>
		</f>
		<meta><m n=":op"><e>A += B</e></m></meta>
	</add>
	<subtract public="1" get="inline" set="null" line="668" static="1">
		<f a="this:b">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="vision.ds.Matrix2D"/>
			<d/>
		</f>
		<meta><m n=":op"><e>A -= B</e></m></meta>
	</subtract>
	<divide public="1" get="inline" set="null" line="683" static="1">
		<f a="this:b">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<x path="vision.ds.Matrix2D"/>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<meta><m n=":op"><e>A /= B</e></m></meta>
	</divide>
	<to_array_array_float set="method" line="717" static="1">
		<f a="this">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<c path="Array"><c path="Array"><x path="Float"/></c></c>
		</f>
		<meta><m n=":to"/></meta>
	</to_array_array_float>
	<from_array_array_float set="method" line="721" static="1">
		<f a="array">
			<c path="Array"><c path="Array"><x path="Float"/></c></c>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<meta><m n=":from"/></meta>
	</from_array_array_float>
	<from_array_array_int set="method" line="727" static="1">
		<f a="array">
			<c path="Array"><c path="Array"><x path="Int"/></c></c>
			<x path="vision.ds.Matrix2D"/>
		</f>
		<meta><m n=":from"/></meta>
	</from_array_array_int>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds._Matrix2D.Matrix2D_Impl_" params="" file="src/vision/ds/Matrix2D.hx" private="1" module="vision.ds.Matrix2D" final="1">
		<underlying public="1" get="accessor" set="accessor" static="1">
			<c path="vision.ds.Array2D"><x path="Float"/></c>
			<haxe_doc>The underlying `Array2D` instance</haxe_doc>
		</underlying>
		<get_underlying get="inline" set="null" line="48" static="1"><f a="this">
	<c path="vision.ds.Array2D"><x path="Float"/></c>
	<c path="vision.ds.Array2D"><x path="Float"/></c>
</f></get_underlying>
		<set_underlying get="inline" set="null" line="52" static="1"><f a="this:arr2d">
	<c path="vision.ds.Array2D"><x path="Float"/></c>
	<c path="vision.ds.Array2D"><x path="Float"/></c>
	<c path="vision.ds.Array2D"><x path="Float"/></c>
</f></set_underlying>
		<rows public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>The amount of rows this matrix contains. Equivalent to `this.height`</haxe_doc>
		</rows>
		<get_rows get="inline" set="null" line="61" static="1">
			<f a="this">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</get_rows>
		<set_rows get="inline" set="null" line="64" static="1">
			<f a="this:amount">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_rows>
		<columns public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>The amount of columns this matrix contains. Equivalent to `this.width`</haxe_doc>
		</columns>
		<get_columns get="inline" set="null" line="73" static="1">
			<f a="this">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</get_columns>
		<set_columns get="inline" set="null" line="76" static="1">
			<f a="this:amount">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_columns>
		<_new public="1" get="inline" set="null" line="87" static="1">
			<f a="width:height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>Creates a new, empty `Matrix2D`
	    @param width the amount of elements in each row
	    @param height the amount of rows</haxe_doc>
		</_new>
		<invert public="1" get="inline" set="null" line="95" static="1">
			<f a="this">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<haxe_doc>Inverts this `Matrix2D` using Gauss-Jordan elimination
        @return this `Matrix2D`, after it has been inverted</haxe_doc>
		</invert>
		<getDeterminant public="1" get="inline" set="null" line="102" static="1">
			<f a="this">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Float"/>
			</f>
			<haxe_doc>Gets the determinant of this `Matrix2D`.</haxe_doc>
		</getDeterminant>
		<getTrace public="1" get="inline" set="null" line="134" static="1">
			<f a="this">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trace of this `Matrix2D`.

		Trace is the sum of the elements on the diagonal, spanning from `(0, 0)` to `(w, h)` when `w = h`.
		
		@throws MatrixOperationError if the matrix is not a square matrix, i.e. `w != h`</haxe_doc>
		</getTrace>
		<multiplyWithScalar public="1" get="inline" set="null" line="147" static="1">
			<f a="this:scalar">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Float"/>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<haxe_doc>Multiplies this `Matrix2D` with a given scalar (a number).</haxe_doc>
		</multiplyWithScalar>
		<clone public="1" get="inline" set="null" line="162" static="1">
			<f a="this">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<haxe_doc>Return a copy of this `Matrix2D`</haxe_doc>
		</clone>
		<map public="1" get="inline" set="null" line="172" static="1">
			<f a="this:mappingFunction">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<haxe_doc>Manipulates each element of this `Matrix2D` with the given function, and
		returns a new `Matrix2D` with the manipulated elements.

		@param mappingFunction the function to apply to each element. Should take a `Float`, and return a `Float`.</haxe_doc>
		</map>
		<getSubMatrix public="1" get="inline" set="null" line="191" static="1">
			<f a="this:?fromX:?fromY:?toX:?toY" v=":0:0::">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<meta><m n=":value"><e>{ fromY : 0, fromX : 0 }</e></m></meta>
			<haxe_doc>Returns a new matrix, containing the elements of this matrix, starting at 
        (`fromX`, `fromY`) and ending at `toX`, `toY`.

        @param fromX The `x` coordinate of the top left corner from which we start reading. Defaults to `0`.
        @param fromY The `y` coordinate of the top left corner from which we start reading. Defaults to `0`.
        @param toX The `x` coordinate of the bottom right corner at which we stop reading. Defaults to `this.width`.
        @param toY The `y` coordinate of the bottom right corner at which we stop reading. Defaults to `this.height`.
        @return Matrix2D</haxe_doc>
		</getSubMatrix>
		<getColumn public="1" get="inline" set="null" line="216" static="1">
			<f a="this:x">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>Returns an array containing the elements at the column `x`, from top to bottom.</haxe_doc>
		</getColumn>
		<getRow public="1" get="inline" set="null" line="223" static="1">
			<f a="this:y">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>Returns an array containing the elements at the row `y`, from left to right.</haxe_doc>
		</getRow>
		<setColumn public="1" get="inline" set="null" line="233" static="1">
			<f a="this:x:arr">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Replaces the elements of the column at index `x` with the elements in `arr`

        @param x the 0-based index of the column
        @param arr the new column. Must be at least of the same length as the matrix' height</haxe_doc>
		</setColumn>
		<setRow public="1" get="inline" set="null" line="244" static="1">
			<f a="this:y:arr">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Replaces the elements of the row at index `y` with the elements in `arr`

        @param y the 0-based index of the row
        @param arr the new row. Must be at least of the same length as the matrix' width</haxe_doc>
		</setRow>
		<insertColumn public="1" get="inline" set="null" line="256" static="1">
			<f a="this:x:arr">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<haxe_doc>Inserts an entire column right before the column at index `x`.

        @param x the 0-based index of the column to insert at
        @param arr the column to insert
        @return this modified `Matrix2D`</haxe_doc>
		</insertColumn>
		<insertRow public="1" get="inline" set="null" line="274" static="1">
			<f a="this:y:arr">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<haxe_doc>Inserts an entire row right before the row at index `y`.

        @param y the 0-based index of the row to insert at
        @param arr the row to insert
        @return this modified `Matrix2D`</haxe_doc>
		</insertRow>
		<removeColumn public="1" get="inline" set="null" line="291" static="1">
			<f a="this:x">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Int"/>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<haxe_doc>Removes an entire column from this `Matrix2D`.

        @param x the 0-based index of the column to remove
        @return this modified `Matrix2D`</haxe_doc>
		</removeColumn>
		<removeRow public="1" get="inline" set="null" line="307" static="1">
			<f a="this:y">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Int"/>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<haxe_doc>Removes an entire row from this `Matrix2D`.

        @param y the 0-based index of the row to remove
        @return this modified `Matrix2D`</haxe_doc>
		</removeRow>
		<toString public="1" get="inline" set="null" line="325" static="1">
			<f a="this:?precision:?pretty" v=":5:true">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ pretty : true, precision : 5 }</e></m></meta>
			<haxe_doc>Returns a string representation of this `Matrix2D`.

        @param precision How many numbers beyond the decimal point to display. Only relevant when `pretty` is set to `true`
        @param pretty Whether to return a pretty-print of the matrix or not. 
        A pretty print adds a distinct matrix border, centered numbers, and ellipsis where numbers are truncated.</haxe_doc>
		</toString>
		<IDENTITY public="1" get="inline" set="null" line="410" static="1">
			<f a=""><x path="vision.ds.TransformationMatrix2D"/></f>
			<haxe_doc>Generates an identity matrix.</haxe_doc>
		</IDENTITY>
		<ROTATION public="1" get="inline" set="null" line="425" static="1">
			<f a="angle:?degrees:?origin" v=":true:null">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="vision.ds.Point2D"/>
				<x path="vision.ds.TransformationMatrix2D"/>
			</f>
			<meta><m n=":value"><e>{ origin : null, degrees : true }</e></m></meta>
			<haxe_doc>Generates a rotation matrix of `angle` degrees/radians.

        @param angle The angle at which to rotate. goes counter-clockwise.
        @param degrees Whether `angle` is given in degrees or radians. Defaults to degrees.
		@param origin The point around which to rotate. Defaults to `(0, 0)`, which means the top-left corner.</haxe_doc>
		</ROTATION>
		<TRANSLATION public="1" get="inline" set="null" line="440" static="1">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.TransformationMatrix2D"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
			<haxe_doc>Generates a translation matrix that displaces the graphic 
        inside the image `x` pixels to the right and `y` pixels to the bottom.

        @param x Displacement in pixels to the right. Default value is 0.
        @param y Displacement in pixels to the bottom. Default value is 0.</haxe_doc>
		</TRANSLATION>
		<SCALE public="1" get="inline" set="null" line="454" static="1">
			<f a="?scaleX:?scaleY" v="1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.TransformationMatrix2D"/>
			</f>
			<meta><m n=":value"><e>{ scaleY : 1, scaleX : 1 }</e></m></meta>
			<haxe_doc>Generates a scaling matrix that "stretches" the width to the new width of `scaleX` * `width`,
        and the height to the new height of `scaleY` * `height`.
        @param scaleX Scaling along the X axis. Default value is 1.
        @param scaleY Scealing along the Y axis. Default value is 1.</haxe_doc>
		</SCALE>
		<SHEAR public="1" get="inline" set="null" line="469" static="1">
			<f a="?shearX:?shearY" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="vision.ds.TransformationMatrix2D"/>
			</f>
			<meta><m n=":value"><e>{ shearY : 0, shearX : 0 }</e></m></meta>
			<haxe_doc>Generates a shearing matrix that "skews" the slope of the image's edges in the x, y and z axis by `-1/shear`.
        For example, if `shearX` is `0.5`, the image is skewed horizontally, such that the slope of the two vertical edges becomes `-2`.

        @param shearX The amount of shearing done on the x-axis, or in other words, when dividing `-1` by `shearX`, determines the slope of the image on the vertical edges.
        @param shearY The amount of shearing done on the y-axis, or in other words, when dividing `-1` by `shearY`, determines the slope of the image on the horizontal edges.</haxe_doc>
		</SHEAR>
		<REFLECTION public="1" get="inline" set="null" line="483" static="1">
			<f a="angle:?degrees:?origin" v=":true:null">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="vision.ds.Point2D"/>
				<x path="vision.ds.TransformationMatrix2D"/>
			</f>
			<meta><m n=":value"><e>{ origin : null, degrees : true }</e></m></meta>
			<haxe_doc>Generates a reflection matrix that "mirrors" an image along the axis which is `angle` degrees/radians form the `x` axis.
    	@param angle The angle at which to reflect. goes counter-clockwise.
        @param degrees Whether `angle` is given in degrees or radians. Defaults to degrees.
		@param origin The point around which to reflect. Defaults to `(0, 0)`, which means the top-left corner.</haxe_doc>
		</REFLECTION>
		<PERSPECTIVE public="1" get="inline" set="null" line="498" static="1">
			<f a="pointPairs">
				<c path="Array"><c path="vision.ds.specifics.PointTransformationPair"/></c>
				<x path="vision.ds.TransformationMatrix2D"/>
			</f>
			<haxe_doc>Generates a perspective warp matrix, that tweaks the perspective of an image, such
        that points at `pointPairs[n].from` will end up in the position `pointPairs[n].to`.

        @param pointPairs 4 pairs of points to "pin-point" the transform on.</haxe_doc>
		</PERSPECTIVE>
		<DEPTH public="1" get="inline" set="null" line="515" static="1">
			<f a="z:?towards">
				<x path="Float"/>
				<c path="vision.ds.Point2D"/>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<haxe_doc>Generates a translation matrix, that displaces the graphic in only the `z` axis.
        a positive `z` moves the graphic backwards, 
        while a value that approaches 0 moves the graphic forward.

        @param z  Displacement in pixels to the back.
		@param towards The point the graphic goes towards, as in, when `z` approaches positive infinity, the graphic goes towards that point. Defaults to `(0, 0)`.</haxe_doc>
		</DEPTH>
		<createFilled public="1" get="inline" set="null" line="529" static="1">
			<f a="rows">
				<x path="haxe.Rest"><c path="Array"><x path="Float"/></c></x>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<haxe_doc><![CDATA[Creates a new `Matrix2D` filled with `rows`, and of `rows.length` height.

	    @param rows multiple parameters of type `Array<Float>`, or a single, `Array<Array<Float>>` preceded by a `...` 
	    @return A `Matrix2D` instance.]]></haxe_doc>
		</createFilled>
		<createTransformation public="1" get="inline" set="null" line="547" static="1">
			<f a="xRow:yRow:?homogeneousRow">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<haxe_doc>Helper function to generate a transformation matrix, 
        exists as sort of a guide for the creation of such matrix.

        @param xRow The first row of the matrix. Will be the row deciding the transformed `x` position of a point.
        @param yRow The second row of the matrix. Will be the row deciding the transformed `y` position of a point.
        @param homogeneousRow The third row of the matrix. On affine transformations (or, ones that are entirely 2D)
        This should be set to `[0, 0, 1]`. On perspective transformations, used to decide the `z` coordinate of a given point.
        When casted back into a 2D point, the point's `z` coordinate is used as a denominator for the other `x` and `y` coordinates.
        @return The newly created `Matrix2D`</haxe_doc>
		</createTransformation>
		<multiplyMatrices public="1" get="inline" set="null" line="567" static="1">
			<f a="a:b">
				<x path="vision.ds.Matrix2D"/>
				<x path="vision.ds.Matrix2D"/>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<meta><m n=":op"><e>A * B</e></m></meta>
		</multiplyMatrices>
		<addMatrices public="1" get="inline" set="null" line="585" static="1">
			<f a="a:b">
				<x path="vision.ds.Matrix2D"/>
				<x path="vision.ds.Matrix2D"/>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</addMatrices>
		<subtractMatrices public="1" get="inline" set="null" line="600" static="1">
			<f a="a:b">
				<x path="vision.ds.Matrix2D"/>
				<x path="vision.ds.Matrix2D"/>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</subtractMatrices>
		<divideMatrices public="1" get="inline" set="null" line="615" static="1">
			<f a="a:b">
				<x path="vision.ds.Matrix2D"/>
				<x path="vision.ds.Matrix2D"/>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<meta><m n=":op"><e>A / B</e></m></meta>
		</divideMatrices>
		<multiply public="1" get="inline" set="null" line="634" static="1">
			<f a="this:b">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="vision.ds.Matrix2D"/>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<meta><m n=":op"><e>A *= B</e></m></meta>
		</multiply>
		<add public="1" get="inline" set="null" line="654" static="1">
			<f a="this:b">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="vision.ds.Matrix2D"/>
				<d/>
			</f>
			<meta><m n=":op"><e>A += B</e></m></meta>
		</add>
		<subtract public="1" get="inline" set="null" line="668" static="1">
			<f a="this:b">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="vision.ds.Matrix2D"/>
				<d/>
			</f>
			<meta><m n=":op"><e>A -= B</e></m></meta>
		</subtract>
		<divide public="1" get="inline" set="null" line="683" static="1">
			<f a="this:b">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<x path="vision.ds.Matrix2D"/>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<meta><m n=":op"><e>A /= B</e></m></meta>
		</divide>
		<to_array_array_float set="method" line="717" static="1">
			<f a="this">
				<c path="vision.ds.Array2D"><x path="Float"/></c>
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
			</f>
			<meta><m n=":to"/></meta>
		</to_array_array_float>
		<from_array_array_float set="method" line="721" static="1">
			<f a="array">
				<c path="Array"><c path="Array"><x path="Float"/></c></c>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<meta><m n=":from"/></meta>
		</from_array_array_float>
		<from_array_array_int set="method" line="727" static="1">
			<f a="array">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<x path="vision.ds.Matrix2D"/>
			</f>
			<meta><m n=":from"/></meta>
		</from_array_array_int>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.ds.Pixel" params="" file="src/vision/ds/Pixel.hx">
		<x public="1">
			<x path="Int"/>
			<haxe_doc>The column on which the pixel is on</haxe_doc>
		</x>
		<y public="1">
			<x path="Int"/>
			<haxe_doc>The row on which the pixel is on</haxe_doc>
		</y>
		<color public="1">
			<x path="vision.ds.Color"/>
			<haxe_doc>The color of the pixel, in `ARGB` format.</haxe_doc>
		</color>
		<new public="1" get="inline" set="null" line="29">
			<f a="x:y:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.Color"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@param x The row on which the pixel is on 
		@param y The column on which the pixel is on 
		@param color The color of the pixel, in `ARGB` format.</haxe_doc>
		</new>
		<haxe_doc>A structure useful for representing a pixel in an image.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="vision.ds.PixelFormat" params="" file="src/vision/ds/PixelFormat.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="vision.ds._PixelFormat.PixelFormat_Impl_" params="" file="src/vision/ds/PixelFormat.hx" private="1" module="vision.ds.PixelFormat" final="1">
	<ARGB public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="vision.ds.PixelFormat"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>0xAARRGGBB</haxe_doc>
	</ARGB>
	<RGBA public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="vision.ds.PixelFormat"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>0xRRGGBBAA</haxe_doc>
	</RGBA>
	<ABGR public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="vision.ds.PixelFormat"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>0xAABBGGRR</haxe_doc>
	</ABGR>
	<BGRA public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="vision.ds.PixelFormat"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>0xBBGGRRAA</haxe_doc>
	</BGRA>
	<RGB public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
		<x path="vision.ds.PixelFormat"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>0x00RRGGBB</haxe_doc>
	</RGB>
	<BGR public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
		<x path="vision.ds.PixelFormat"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>0x00BBGGRR</haxe_doc>
	</BGR>
	<convertPixelFormat public="1" set="method" line="24" static="1">
		<f a="bytes:from:?to" v="::ARGB">
			<x path="vision.ds.ByteArray"/>
			<x path="vision.ds.PixelFormat"/>
			<x path="vision.ds.PixelFormat"/>
			<x path="vision.ds.ByteArray"/>
		</f>
		<meta><m n=":value"><e>{ to : ARGB }</e></m></meta>
		<haxe_doc>Takes bytes of pixel format `from`, and turns them into bytes of pixel format `to`.
        @param bytes the bytes to manipulate
        @param from the current pixel format
        @param to the desired pixel format

        @returns the same, manipulated, pixel format
        @throws UnknownPixelFormat if either `to` or `from` are invalid.</haxe_doc>
	</convertPixelFormat>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds._PixelFormat.PixelFormat_Impl_" params="" file="src/vision/ds/PixelFormat.hx" private="1" module="vision.ds.PixelFormat" final="1">
		<ARGB public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="vision.ds.PixelFormat"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>0xAARRGGBB</haxe_doc>
		</ARGB>
		<RGBA public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="vision.ds.PixelFormat"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>0xRRGGBBAA</haxe_doc>
		</RGBA>
		<ABGR public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="vision.ds.PixelFormat"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>0xAABBGGRR</haxe_doc>
		</ABGR>
		<BGRA public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="vision.ds.PixelFormat"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>0xBBGGRRAA</haxe_doc>
		</BGRA>
		<RGB public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
			<x path="vision.ds.PixelFormat"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>0x00RRGGBB</haxe_doc>
		</RGB>
		<BGR public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
			<x path="vision.ds.PixelFormat"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>0x00BBGGRR</haxe_doc>
		</BGR>
		<convertPixelFormat public="1" set="method" line="24" static="1">
			<f a="bytes:from:?to" v="::ARGB">
				<x path="vision.ds.ByteArray"/>
				<x path="vision.ds.PixelFormat"/>
				<x path="vision.ds.PixelFormat"/>
				<x path="vision.ds.ByteArray"/>
			</f>
			<meta><m n=":value"><e>{ to : ARGB }</e></m></meta>
			<haxe_doc>Takes bytes of pixel format `from`, and turns them into bytes of pixel format `to`.
        @param bytes the bytes to manipulate
        @param from the current pixel format
        @param to the desired pixel format

        @returns the same, manipulated, pixel format
        @throws UnknownPixelFormat if either `to` or `from` are invalid.</haxe_doc>
		</convertPixelFormat>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="vision.ds.Point2D" params="" file="src/vision/ds/Point2D.hx">
		<x public="1">
			<x path="Float"/>
			<haxe_doc>The x-coordinate of the point.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>The y-coordinate of the point.</haxe_doc>
		</y>
		<toString public="1" get="inline" set="null" line="33">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a `String` representations of this `Point2D`.</haxe_doc>
		</toString>
		<copy public="1" get="inline" set="null" line="40">
			<f a=""><c path="vision.ds.Point2D"/></f>
			<haxe_doc>Returns a new `Point2D` instance, similar to this one.</haxe_doc>
		</copy>
		<distanceTo public="1" get="inline" set="null" line="52">
			<f a="point">
				<c path="vision.ds.Point2D"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[Gets the distance between `this` and `point`.

		If `this` and `point` are have the same `x` & `y` position, `0` is returned.

		@param point The second point to calculate the distance to
		@return A `Float` representing the distance. `0` if `this` and `point` are congruent.]]></haxe_doc>
		</distanceTo>
		<degreesTo public="1" get="inline" set="null" line="64">
			<f a="point">
				<c path="vision.ds.Point2D"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[Gets the angle between `this` and `point`, in degrees.

		If `this` and `point` are have the same `x` & `y` position, `0` is returned.

		@param point The second point to calculate the angle to.
		@return A `Float` representing the angle, in degrees. `0` if `this` and `point` are congruent.]]></haxe_doc>
		</degreesTo>
		<radiansTo public="1" get="inline" set="null" line="76">
			<f a="point">
				<c path="vision.ds.Point2D"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[Gets the angle between `this` and `point`, in radians.

		If `this` and `point` are have the same `x` & `y` position, `0` is returned.

		@param point The second point to calculate the angle to.
		@return A `Float` representing the angle, in radians. `0` if `this` and `point` are congruent.]]></haxe_doc>
		</radiansTo>
		<new public="1" get="inline" set="null" line="25">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
			<haxe_doc>Initializes a new instance of the Point2D class with the specified x and y coordinates.

		you can construct a Point2D object by using the following syntax too:
		```haxe
		var point:Point2D = {x: 10, y: 20};
		```</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="vision.ds.Point3D" params="" file="src/vision/ds/Point3D.hx">
		<x public="1">
			<x path="Float"/>
			<haxe_doc>The x-coordinate of the point.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>The y-coordinate of the point.</haxe_doc>
		</y>
		<z public="1">
			<x path="Float"/>
			<haxe_doc>The z-coordinate of the point.</haxe_doc>
		</z>
		<distanceTo public="1" set="method" line="45">
			<f a="point">
				<c path="vision.ds.Point3D"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Gets the distance between `this` and `point`.

		If `this` and `point` are have the same `x`, `y` and `z` position, `0` is returned.

		@param point The second point to calculate the distance to
		@return A `Float` representing the distance. `0` if `this` and `point` are congruent.</haxe_doc>
		</distanceTo>
		<copy public="1" set="method" line="52">
			<f a=""><c path="vision.ds.Point3D"/></f>
			<haxe_doc>Returns a new `Point3D` instance, similar to this one.</haxe_doc>
		</copy>
		<toString public="1" set="method" line="59">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a `String` representations of this `Point3D`.</haxe_doc>
		</toString>
		<new public="1" set="method" line="31">
			<f a="x:y:z">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Initializes a new instance of the Point3D class with the specified x, y and z coordinates.

		you can construct a Point3D object by using the following syntax too:
		```haxe
		var point:Point3D = {x: 10, y: -4, z: 5};
		```</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="vision.ds.QueueCell" params="T" file="src/vision/ds/Queue.hx" module="vision.ds.Queue">
		<previous public="1"><c path="vision.ds.QueueCell"><c path="vision.ds.QueueCell.T"/></c></previous>
		<value public="1"><c path="vision.ds.QueueCell.T"/></value>
		<next public="1"><c path="vision.ds.QueueCell"><c path="vision.ds.QueueCell.T"/></c></next>
		<getValue public="1" set="method" line="17">
			<f a=""><c path="vision.ds.QueueCell.T"/></f>
			<meta>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</getValue>
		<new public="1" set="method" line="11"><f a="value:next:previous">
	<c path="vision.ds.QueueCell.T"/>
	<c path="vision.ds.QueueCell"><c path="vision.ds.QueueCell.T"/></c>
	<c path="vision.ds.QueueCell"><c path="vision.ds.QueueCell.T"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.ds.Queue" params="T" file="src/vision/ds/Queue.hx">
		<length public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</length>
		<first public="1"><c path="vision.ds.QueueCell"><c path="vision.ds.Queue.T"/></c></first>
		<last public="1" get="accessor" set="accessor"><c path="vision.ds.QueueCell"><c path="vision.ds.Queue.T"/></c></last>
		<iterator public="1" set="method" line="41">
			<f a=""><t path="Iterator"><c path="vision.ds.Queue.T"/></t></f>
			<haxe_doc>Returns an iterator over the elements of `this` Queue.</haxe_doc>
		</iterator>
		<dequeue public="1" set="method" line="60">
			<f a=""><c path="vision.ds.Queue.T"/></f>
			<haxe_doc><![CDATA[Gets the value of the first item in the queue, and removes it from the queue.

		(`last` `->` `...` `->` `first`)]]></haxe_doc>
		</dequeue>
		<enqueue public="1" set="method" line="73">
			<f a="value">
				<c path="vision.ds.Queue.T"/>
				<c path="vision.ds.Queue.T"/>
			</f>
			<haxe_doc>Adds a value to the end of the queue, and returns it.

		@param value The value to push to the end of the queue</haxe_doc>
		</enqueue>
		<has public="1" set="method" line="94">
			<f a="value">
				<c path="vision.ds.Queue.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Whether or not this `Queue` contains `value`.

		This function iterates over the elements from the end of the queue to the start,
		and checks for equality using standard equality (`==`).

		@param value the value to check with
		@returns Whether or not `value` is present in this `Queue`.</haxe_doc>
		</has>
		<toString public="1" set="method" line="122">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[Returns a `String` representation of this `Queue`, for example:

		```haxe
		var queue = new Queue<Int>();
		queue.enqueue(5);
		queue.enqueue(7);
		queue.enqueue(4);
		trace(queue.toString());
		```
		
		Outputs:

		```txt
		[4 -> 7 -> 5]
		```]]></haxe_doc>
		</toString>
		<get_last set="method" line="134"><f a=""><c path="vision.ds.QueueCell"><c path="vision.ds.Queue.T"/></c></f></get_last>
		<set_last set="method" line="143"><f a="value">
	<c path="vision.ds.QueueCell"><c path="vision.ds.Queue.T"/></c>
	<c path="vision.ds.QueueCell"><c path="vision.ds.Queue.T"/></c>
</f></set_last>
		<new public="1" set="method" line="36">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new `Queue` with 0 elements. 
		
		use `enqueue()`/`dequeue()` to add/remove elements.</haxe_doc>
		</new>
		<haxe_doc>Represents a queue, as a doubly linked list.</haxe_doc>
	</class>
	<class path="vision.ds.Ray2D" params="" file="src/vision/ds/Ray2D.hx">
		<from2Points public="1" get="inline" set="null" line="71" static="1">
			<f a="point1:point2">
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Ray2D"/>
			</f>
			<haxe_doc>Constructs a `Ray2D` from 2 `Point2D`s

		@param point1 First reference point, will be stored in the returned `Ray2D`'s `point` field.
		@param point2 Second reference point, used to calculate the slope of the ray.</haxe_doc>
		</from2Points>
		<point public="1">
			<c path="vision.ds.Point2D"/>
			<haxe_doc>A point this `Ray2D` passes through. Initially set to the `Point2D` given in the constructor.

		Changing this point's properties (or the point itself) moves the ray, while keeping its slope.</haxe_doc>
		</point>
		<slope public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The direction of this `Ray2D`, in a rise-over-run format.</haxe_doc>
		</slope>
		<degrees public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The direction of this `Ray2D`, in degrees</haxe_doc>
		</degrees>
		<radians public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The direction of this `Ray2D`, in radians</haxe_doc>
		</radians>
		<yIntercept public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>The `y` position in which `x = 0`</haxe_doc>
		</yIntercept>
		<xIntercept public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>The `x` position in which `y = 0`</haxe_doc>
		</xIntercept>
		<getPointAtX public="1" get="inline" set="null" line="79">
			<f a="x">
				<x path="Float"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<haxe_doc>Gets the point on this `Ray2D` at `(x, y)` when `x` is given.</haxe_doc>
		</getPointAtX>
		<getPointAtY public="1" get="inline" set="null" line="86">
			<f a="y">
				<x path="Float"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<haxe_doc>Gets the point on this `Ray2D` at `(x, y)` when `y` is given.</haxe_doc>
		</getPointAtY>
		<intersect public="1" get="inline" set="null" line="98">
			<f a="ray">
				<c path="vision.ds.Ray2D"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<haxe_doc>Gets the intersection point between `this` and `ray`.

		If `this` and `ray` are parallel, `null` is returned.

		@param ray The second ray to intersect with.
		@return A `Point2D` instance, `null` if `this` and `ray` are parallel.</haxe_doc>
		</intersect>
		<distanceTo public="1" set="method" line="110">
			<f a="ray">
				<c path="vision.ds.Ray2D"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Gets the distance between `this` and `ray`.

		If `this` and `ray` intersect, `0` is returned.

		@param ray The second ray to calculate the distance to.
		@return A `Float` representing the distance. `0` if `this` and `ray` intersect.</haxe_doc>
		</distanceTo>
		<set_slope get="inline" set="null" line="115"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_slope>
		<set_degrees get="inline" set="null" line="121"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_degrees>
		<set_radians get="inline" set="null" line="127"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radians>
		<get_yIntercept get="inline" set="null" line="133"><f a=""><x path="Float"/></f></get_yIntercept>
		<get_xIntercept get="inline" set="null" line="141"><f a=""><x path="Float"/></f></get_xIntercept>
		<new public="1" get="inline" set="null" line="48">
			<f a="point:?m:?degrees:?radians">
				<c path="vision.ds.Point2D"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@param point a point on the line
		@param m the slope of the line, optional - you can pass the degrees/radians instead, and set this to null
		@param degrees the degrees of the line, optional - you can pass the slope/radians instead, and set this to null
		@param radians the radians of the line, optional - you can pass the slope/degrees instead, and not set this</haxe_doc>
		</new>
		<haxe_doc>Represents a 2-dimensional ray on the cartesian coordinate system</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.ds.Rectangle" params="" file="src/vision/ds/Rectangle.hx">
		<x public="1">
			<x path="Int"/>
			<haxe_doc>The `x` position of this `Rectangle`</haxe_doc>
		</x>
		<y public="1">
			<x path="Int"/>
			<haxe_doc>The `y` position of this `Rectangle`</haxe_doc>
		</y>
		<width public="1">
			<x path="Int"/>
			<haxe_doc>The `width` of this `Rectangle`</haxe_doc>
		</width>
		<height public="1">
			<x path="Int"/>
			<haxe_doc>The `height` of this `Rectangle`</haxe_doc>
		</height>
		<new public="1" set="method" line="4">
			<f a="x:y:width:height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc>@param height The `height` of this `Rectangle`
@param width The `width` of this `Rectangle`
@param y The `y` position of this `Rectangle`
@param x The `x` position of this `Rectangle`</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="vision.ds.TransformationMatrix2D" params="" file="src/vision/ds/TransformationMatrix2D.hx">
		<from><icast field="fromMatrix2D"><x path="vision.ds.Matrix2D"/></icast></from>
		<this><x path="vision.ds.Matrix2D"/></this>
		<to><icast><x path="vision.ds.Matrix2D"/></icast></to>
		<meta>
			<m n=":forward.variance"/>
			<m n=":forward">
				<e>getRow</e>
				<e>getColumn</e>
				<e>setRow</e>
				<e>setColumn</e>
				<e>map</e>
				<e>clone</e>
				<e>fill</e>
				<e>toString</e>
			</m>
		</meta>
		<impl><class path="vision.ds._TransformationMatrix2D.TransformationMatrix2D_Impl_" params="" file="src/vision/ds/TransformationMatrix2D.hx" private="1" module="vision.ds.TransformationMatrix2D" final="1">
	<underlying public="1" get="accessor" set="null" static="1">
		<x path="vision.ds.Matrix2D"/>
		<haxe_doc>The underlying `Matrix2D` instance.
		you can safely use this for mathematical operations.</haxe_doc>
	</underlying>
	<get_underlying get="inline" set="null" line="14" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="vision.ds.Matrix2D"/>
</f></get_underlying>
	<a public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The top-left element in this matrix, at position `(0, 0)`:

		```haxe
		â”Œ          â”
		â”‚ a  áµ‡  áµ—Ë£ â”‚
		â”‚ á¶œ  áµˆ  áµ—Ê¸ â”‚
		â”‚ áµ‰  á¶   1  â”‚
		â””          â”˜
		```

		Used for manipulation on the X axis, using a given point's X value.</haxe_doc>
	</a>
	<get_a get="inline" set="null" line="30" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_a>
	<set_a get="inline" set="null" line="31" static="1"><f a="this:a">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_a>
	<b public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The top-middle element in this matrix, at position `(0, 1)`:

		```haxe
		â”Œ          â”
		â”‚ áµƒ  b  áµ—Ë£ â”‚
		â”‚ á¶œ  áµˆ  áµ—Ê¸ â”‚
		â”‚ áµ‰  á¶   1  â”‚
		â””          â”˜
		```

		Used for manipulation on the X axis, using a given point's Y value.</haxe_doc>
	</b>
	<get_b get="inline" set="null" line="47" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_b>
	<set_b get="inline" set="null" line="48" static="1"><f a="this:b">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_b>
	<c public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The middle-left element in this matrix, at position `(1, 0)`:

		```haxe
		â”Œ          â”
		â”‚ áµƒ  áµ‡  áµ—Ë£ â”‚
		â”‚ c  áµˆ  áµ—Ê¸ â”‚
		â”‚ áµ‰  á¶   1  â”‚
		â””          â”˜
		```

		Used for manipulation on the Y axis, using a given point's X value.</haxe_doc>
	</c>
	<get_c get="inline" set="null" line="64" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_c>
	<set_c get="inline" set="null" line="65" static="1"><f a="this:c">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_c>
	<d public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The center element in this matrix, at position `(1, 1)`:

		```haxe
		â”Œ          â”
		â”‚ áµƒ  áµ‡  áµ—Ë£ â”‚
		â”‚ á¶œ  d  áµ—Ê¸ â”‚
		â”‚ áµ‰  á¶   1  â”‚
		â””          â”˜
		```

		Used for manipulation on the Y axis, using a given point's Y value.</haxe_doc>
	</d>
	<get_d get="inline" set="null" line="81" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_d>
	<set_d get="inline" set="null" line="82" static="1"><f a="this:d">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_d>
	<e public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The bottom-left element in this matrix, at position `(0, 2)`:

		```haxe
		â”Œ          â”
		â”‚ áµƒ  áµ‡  áµ—Ë£ â”‚
		â”‚ á¶œ  áµˆ  áµ—Ê¸ â”‚
		â”‚ e  á¶   1  â”‚
		â””          â”˜
		```

		Used for manipulation on the Z axis, using a given point's X value.
		The higher a pixel's value on the Z axis, the "deeper" it is in the image, 
		or in other terms, the closer it is to the vanishing point.
		
		The vanishing point is decided when we apply the matrix to each pixel - it is the X
		and Y offsets we add to each point before the main calculation. It also plays a 
		role in rotations and reflections, by acting like the rotation/reflection center.</haxe_doc>
	</e>
	<get_e get="inline" set="null" line="104" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_e>
	<set_e get="inline" set="null" line="105" static="1"><f a="this:e">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_e>
	<f public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The bottom-middle element in this matrix, at position `(1, 2)`:

		```haxe
		â”Œ          â”
		â”‚ áµƒ  áµ‡  áµ—Ë£ â”‚
		â”‚ á¶œ  áµˆ  áµ—Ê¸ â”‚
		â”‚ áµ‰  f  1  â”‚
		â””          â”˜
		```

		Used for manipulation on the Z axis, using a given point's Y value.
		The higher a pixel's value on the Z axis, the "deeper" it is in the image, 
		or in other terms, the closer it is to the vanishing point.
		
		The vanishing point is decided when we apply the matrix to each pixel - it is the X
		and Y offsets we add to each point before the main calculation. It also plays a 
		role in rotations and reflections, by acting like the rotation/reflection center.</haxe_doc>
	</f>
	<get_f get="inline" set="null" line="127" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_f>
	<set_f get="inline" set="null" line="128" static="1"><f a="this:f">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_f>
	<tx public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The top-left element in this matrix, at position `(2, 0)`:

		```haxe
		â”Œ          â”
		â”‚ áµƒ  áµ‡  tx â”‚
		â”‚ á¶œ  áµˆ  áµ—Ê¸ â”‚
		â”‚ áµ‰  á¶   1  â”‚
		â””          â”˜
		```

		Used for translation on the X axis, or in other words, moving pixels horizontally.</haxe_doc>
	</tx>
	<get_tx get="inline" set="null" line="144" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_tx>
	<set_tx get="inline" set="null" line="145" static="1"><f a="this:tx">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_tx>
	<ty public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<haxe_doc>The middle-left element in this matrix, at position `(2, 0)`:

		```haxe
		â”Œ          â”
		â”‚ áµƒ  áµ‡  áµ—Ë£ â”‚
		â”‚ á¶œ  áµˆ  ty â”‚
		â”‚ áµ‰  á¶   1  â”‚
		â””          â”˜
		```

		Used for translation on the Y axis, or in other words, moving pixels vertically.</haxe_doc>
	</ty>
	<get_ty get="inline" set="null" line="161" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_ty>
	<set_ty get="inline" set="null" line="162" static="1"><f a="this:ty">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_ty>
	<_new set="method" line="164" static="1">
		<f a="m">
			<x path="vision.ds.Matrix2D"/>
			<x path="vision.ds.TransformationMatrix2D"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<transformPoint public="1" get="inline" set="null" line="176" static="1">
		<f a="this:point">
			<x path="vision.ds.Matrix2D"/>
			<c path="vision.ds.Point3D"/>
			<c path="vision.ds.Point3D"/>
		</f>
		<haxe_doc>Multiplies the given point by this `Matrix2D`:  
		The `x` coordinate is multiplied by the first row, 
		the `y` coordinate is multiplied by the second row,
		and the `z` coordinate is multiplied by the last row,
		@param point any 3D point
		@return a new, transformed `Point3D` instance</haxe_doc>
		<overloads><transformPoint public="1" get="inline" set="null" line="192">
	<f a="this:point">
		<x path="vision.ds.Matrix2D"/>
		<c path="vision.ds.Point2D"/>
		<c path="vision.ds.Point2D"/>
	</f>
	<haxe_doc>Multiplies the given point by this `Matrix2D`:  
		The `x` coordinate is multiplied by the first row, 
		and the `y` coordinate is multiplied by the second row.  
		The last row is ignored.
		@param point any 2D point
		@return a new, transformed `Point2D` instance</haxe_doc>
</transformPoint></overloads>
	</transformPoint>
	<fromMatrix2D set="method" line="201" static="1">
		<f a="m">
			<x path="vision.ds.Matrix2D"/>
			<x path="vision.ds.TransformationMatrix2D"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromMatrix2D>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds._TransformationMatrix2D.TransformationMatrix2D_Impl_" params="" file="src/vision/ds/TransformationMatrix2D.hx" private="1" module="vision.ds.TransformationMatrix2D" final="1">
		<underlying public="1" get="accessor" set="null" static="1">
			<x path="vision.ds.Matrix2D"/>
			<haxe_doc>The underlying `Matrix2D` instance.
		you can safely use this for mathematical operations.</haxe_doc>
		</underlying>
		<get_underlying get="inline" set="null" line="14" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="vision.ds.Matrix2D"/>
</f></get_underlying>
		<a public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The top-left element in this matrix, at position `(0, 0)`:

		```haxe
		â”Œ          â”
		â”‚ a  áµ‡  áµ—Ë£ â”‚
		â”‚ á¶œ  áµˆ  áµ—Ê¸ â”‚
		â”‚ áµ‰  á¶   1  â”‚
		â””          â”˜
		```

		Used for manipulation on the X axis, using a given point's X value.</haxe_doc>
		</a>
		<get_a get="inline" set="null" line="30" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_a>
		<set_a get="inline" set="null" line="31" static="1"><f a="this:a">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_a>
		<b public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The top-middle element in this matrix, at position `(0, 1)`:

		```haxe
		â”Œ          â”
		â”‚ áµƒ  b  áµ—Ë£ â”‚
		â”‚ á¶œ  áµˆ  áµ—Ê¸ â”‚
		â”‚ áµ‰  á¶   1  â”‚
		â””          â”˜
		```

		Used for manipulation on the X axis, using a given point's Y value.</haxe_doc>
		</b>
		<get_b get="inline" set="null" line="47" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_b>
		<set_b get="inline" set="null" line="48" static="1"><f a="this:b">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_b>
		<c public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The middle-left element in this matrix, at position `(1, 0)`:

		```haxe
		â”Œ          â”
		â”‚ áµƒ  áµ‡  áµ—Ë£ â”‚
		â”‚ c  áµˆ  áµ—Ê¸ â”‚
		â”‚ áµ‰  á¶   1  â”‚
		â””          â”˜
		```

		Used for manipulation on the Y axis, using a given point's X value.</haxe_doc>
		</c>
		<get_c get="inline" set="null" line="64" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_c>
		<set_c get="inline" set="null" line="65" static="1"><f a="this:c">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_c>
		<d public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The center element in this matrix, at position `(1, 1)`:

		```haxe
		â”Œ          â”
		â”‚ áµƒ  áµ‡  áµ—Ë£ â”‚
		â”‚ á¶œ  d  áµ—Ê¸ â”‚
		â”‚ áµ‰  á¶   1  â”‚
		â””          â”˜
		```

		Used for manipulation on the Y axis, using a given point's Y value.</haxe_doc>
		</d>
		<get_d get="inline" set="null" line="81" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_d>
		<set_d get="inline" set="null" line="82" static="1"><f a="this:d">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_d>
		<e public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The bottom-left element in this matrix, at position `(0, 2)`:

		```haxe
		â”Œ          â”
		â”‚ áµƒ  áµ‡  áµ—Ë£ â”‚
		â”‚ á¶œ  áµˆ  áµ—Ê¸ â”‚
		â”‚ e  á¶   1  â”‚
		â””          â”˜
		```

		Used for manipulation on the Z axis, using a given point's X value.
		The higher a pixel's value on the Z axis, the "deeper" it is in the image, 
		or in other terms, the closer it is to the vanishing point.
		
		The vanishing point is decided when we apply the matrix to each pixel - it is the X
		and Y offsets we add to each point before the main calculation. It also plays a 
		role in rotations and reflections, by acting like the rotation/reflection center.</haxe_doc>
		</e>
		<get_e get="inline" set="null" line="104" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_e>
		<set_e get="inline" set="null" line="105" static="1"><f a="this:e">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_e>
		<f public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The bottom-middle element in this matrix, at position `(1, 2)`:

		```haxe
		â”Œ          â”
		â”‚ áµƒ  áµ‡  áµ—Ë£ â”‚
		â”‚ á¶œ  áµˆ  áµ—Ê¸ â”‚
		â”‚ áµ‰  f  1  â”‚
		â””          â”˜
		```

		Used for manipulation on the Z axis, using a given point's Y value.
		The higher a pixel's value on the Z axis, the "deeper" it is in the image, 
		or in other terms, the closer it is to the vanishing point.
		
		The vanishing point is decided when we apply the matrix to each pixel - it is the X
		and Y offsets we add to each point before the main calculation. It also plays a 
		role in rotations and reflections, by acting like the rotation/reflection center.</haxe_doc>
		</f>
		<get_f get="inline" set="null" line="127" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_f>
		<set_f get="inline" set="null" line="128" static="1"><f a="this:f">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_f>
		<tx public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The top-left element in this matrix, at position `(2, 0)`:

		```haxe
		â”Œ          â”
		â”‚ áµƒ  áµ‡  tx â”‚
		â”‚ á¶œ  áµˆ  áµ—Ê¸ â”‚
		â”‚ áµ‰  á¶   1  â”‚
		â””          â”˜
		```

		Used for translation on the X axis, or in other words, moving pixels horizontally.</haxe_doc>
		</tx>
		<get_tx get="inline" set="null" line="144" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_tx>
		<set_tx get="inline" set="null" line="145" static="1"><f a="this:tx">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_tx>
		<ty public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The middle-left element in this matrix, at position `(2, 0)`:

		```haxe
		â”Œ          â”
		â”‚ áµƒ  áµ‡  áµ—Ë£ â”‚
		â”‚ á¶œ  áµˆ  ty â”‚
		â”‚ áµ‰  á¶   1  â”‚
		â””          â”˜
		```

		Used for translation on the Y axis, or in other words, moving pixels vertically.</haxe_doc>
		</ty>
		<get_ty get="inline" set="null" line="161" static="1"><f a="this">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
</f></get_ty>
		<set_ty get="inline" set="null" line="162" static="1"><f a="this:ty">
	<x path="vision.ds.Matrix2D"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_ty>
		<_new set="method" line="164" static="1">
			<f a="m">
				<x path="vision.ds.Matrix2D"/>
				<x path="vision.ds.TransformationMatrix2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<transformPoint public="1" get="inline" set="null" line="176" static="1">
			<f a="this:point">
				<x path="vision.ds.Matrix2D"/>
				<c path="vision.ds.Point3D"/>
				<c path="vision.ds.Point3D"/>
			</f>
			<haxe_doc>Multiplies the given point by this `Matrix2D`:  
		The `x` coordinate is multiplied by the first row, 
		the `y` coordinate is multiplied by the second row,
		and the `z` coordinate is multiplied by the last row,
		@param point any 3D point
		@return a new, transformed `Point3D` instance</haxe_doc>
			<overloads><transformPoint public="1" get="inline" set="null" line="192">
	<f a="this:point">
		<x path="vision.ds.Matrix2D"/>
		<c path="vision.ds.Point2D"/>
		<c path="vision.ds.Point2D"/>
	</f>
	<haxe_doc>Multiplies the given point by this `Matrix2D`:  
		The `x` coordinate is multiplied by the first row, 
		and the `y` coordinate is multiplied by the second row.  
		The last row is ignored.
		@param point any 2D point
		@return a new, transformed `Point2D` instance</haxe_doc>
</transformPoint></overloads>
		</transformPoint>
		<fromMatrix2D set="method" line="201" static="1">
			<f a="m">
				<x path="vision.ds.Matrix2D"/>
				<x path="vision.ds.TransformationMatrix2D"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromMatrix2D>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="vision.ds.UInt16Point2D" params="" file="src/vision/ds/UInt16Point2D.hx">
		<this><x path="Int"/></this>
		<to>
			<icast field="toPoint2D"><c path="vision.ds.Point2D"/></icast>
			<icast field="toIntPoint2D"><c path="vision.ds.Point2D"/></icast>
			<icast field="toInt"><x path="Int"/></icast>
		</to>
		<haxe_doc>A 2D point represented by 2, unsigned, 16-bit integers.

    An abstract over a 32-bit `Int`, with its first 16 bits representing
    the X value, and the other bits representing the Y value

    **Attention - this is a pass-by-value type**</haxe_doc>
		<meta><m n=":structInit"/></meta>
		<impl><class path="vision.ds._UInt16Point2D.UInt16Point2D_Impl_" params="" file="src/vision/ds/UInt16Point2D.hx" private="1" module="vision.ds.UInt16Point2D" final="1">
	<x public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>The `x` position of this `UInt16Point2D`</haxe_doc>
	</x>
	<y public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<haxe_doc>The `y` position of this `UInt16Point2D`</haxe_doc>
	</y>
	<_new public="1" get="inline" set="null" line="24" static="1">
		<f a="?X:?Y" v="0:0">
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.ds.UInt16Point2D"/>
		</f>
		<meta>
			<m n=":value"><e>{ Y : 0, X : 0 }</e></m>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<get_x get="inline" set="null" line="28" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_x>
	<set_x get="inline" set="null" line="32" static="1"><f a="this:x">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_x>
	<get_y get="inline" set="null" line="38" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_y>
	<set_y get="inline" set="null" line="42" static="1"><f a="this:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_y>
	<toString public="1" get="inline" set="null" line="48" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<toPoint2D public="1" get="inline" set="null" line="52" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="vision.ds.Point2D"/>
		</f>
		<meta><m n=":to"/></meta>
	</toPoint2D>
	<toIntPoint2D public="1" get="inline" set="null" line="56" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="vision.ds.Point2D"/>
		</f>
		<meta><m n=":to"/></meta>
	</toIntPoint2D>
	<toInt public="1" get="inline" set="null" line="60" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":to"/></meta>
	</toInt>
</class></impl>
	</abstract>
	<class path="vision.ds._UInt16Point2D.UInt16Point2D_Impl_" params="" file="src/vision/ds/UInt16Point2D.hx" private="1" module="vision.ds.UInt16Point2D" final="1">
		<x public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>The `x` position of this `UInt16Point2D`</haxe_doc>
		</x>
		<y public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>The `y` position of this `UInt16Point2D`</haxe_doc>
		</y>
		<_new public="1" get="inline" set="null" line="24" static="1">
			<f a="?X:?Y" v="0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.ds.UInt16Point2D"/>
			</f>
			<meta>
				<m n=":value"><e>{ Y : 0, X : 0 }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<get_x get="inline" set="null" line="28" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_x>
		<set_x get="inline" set="null" line="32" static="1"><f a="this:x">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_x>
		<get_y get="inline" set="null" line="38" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></get_y>
		<set_y get="inline" set="null" line="42" static="1"><f a="this:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_y>
		<toString public="1" get="inline" set="null" line="48" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<toPoint2D public="1" get="inline" set="null" line="52" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<meta><m n=":to"/></meta>
		</toPoint2D>
		<toIntPoint2D public="1" get="inline" set="null" line="56" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<meta><m n=":to"/></meta>
		</toIntPoint2D>
		<toInt public="1" get="inline" set="null" line="60" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":to"/></meta>
		</toInt>
	</class>
	<abstract path="vision.ds.canny.CannyObject" params="" file="src/vision/ds/canny/CannyObject.hx">
		<from><icast><x path="vision.ds.Image"/></icast></from>
		<this><x path="vision.ds.Image"/></this>
		<to><icast><x path="vision.ds.Image"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="vision.ds.canny._CannyObject.CannyObject_Impl_" params="" file="src/vision/ds/canny/CannyObject.hx" private="1" module="vision.ds.canny.CannyObject" extern="1" final="1"/></impl>
	</abstract>
	<class path="vision.ds.canny._CannyObject.CannyObject_Impl_" params="" file="src/vision/ds/canny/CannyObject.hx" private="1" module="vision.ds.canny.CannyObject" extern="1" final="1"/>
	<abstract path="vision.ds.gaussian.GaussianKernelSize" params="" file="src/vision/ds/gaussian/GaussianKernelSize.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="vision.ds.gaussian._GaussianKernelSize.GaussianKernelSize_Impl_" params="" file="src/vision/ds/gaussian/GaussianKernelSize.hx" private="1" module="vision.ds.gaussian.GaussianKernelSize" extern="1" final="1">
	<X1 public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="vision.ds.gaussian.GaussianKernelSize"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>No blurring</haxe_doc>
	</X1>
	<X3 public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
		<x path="vision.ds.gaussian.GaussianKernelSize"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Lower-quality blurring, best performance.</haxe_doc>
	</X3>
	<X5 public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
		<x path="vision.ds.gaussian.GaussianKernelSize"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Medium-quality blurring, medium performance</haxe_doc>
	</X5>
	<X7 public="1" get="inline" set="null" expr="cast 7" line="14" static="1">
		<x path="vision.ds.gaussian.GaussianKernelSize"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>High-quality blurring, slow-ish performance</haxe_doc>
	</X7>
	<X9 public="1" get="inline" set="null" expr="cast 9" line="17" static="1">
		<x path="vision.ds.gaussian.GaussianKernelSize"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Highest-quality blurring, worst performance</haxe_doc>
	</X9>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds.gaussian._GaussianKernelSize.GaussianKernelSize_Impl_" params="" file="src/vision/ds/gaussian/GaussianKernelSize.hx" private="1" module="vision.ds.gaussian.GaussianKernelSize" extern="1" final="1">
		<X1 public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="vision.ds.gaussian.GaussianKernelSize"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>No blurring</haxe_doc>
		</X1>
		<X3 public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
			<x path="vision.ds.gaussian.GaussianKernelSize"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Lower-quality blurring, best performance.</haxe_doc>
		</X3>
		<X5 public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
			<x path="vision.ds.gaussian.GaussianKernelSize"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Medium-quality blurring, medium performance</haxe_doc>
		</X5>
		<X7 public="1" get="inline" set="null" expr="cast 7" line="14" static="1">
			<x path="vision.ds.gaussian.GaussianKernelSize"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>High-quality blurring, slow-ish performance</haxe_doc>
		</X7>
		<X9 public="1" get="inline" set="null" expr="cast 9" line="17" static="1">
			<x path="vision.ds.gaussian.GaussianKernelSize"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Highest-quality blurring, worst performance</haxe_doc>
		</X9>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="vision.ds.hough.HoughAccumulator" params="" file="src/vision/ds/hough/HoughAccumulator.hx">
		<from><icast><c path="Array"><c path="Array"><x path="Int"/></c></c></icast></from>
		<this><c path="Array"><c path="Array"><x path="Int"/></c></c></this>
		<to><icast><c path="Array"><c path="Array"><x path="Int"/></c></c></icast></to>
		<haxe_doc>Used for the accumulator array of the hough transform.

	ranges should follow this format:

	- Ï: from `-d` to `d`
	- Î¸: from `0` to `180`

	(Ï - rho, Î¸ - theta)

	the underlying array will be accessed with `array[rho][theta]`</haxe_doc>
		<impl><class path="vision.ds.hough._HoughAccumulator.HoughAccumulator_Impl_" params="" file="src/vision/ds/hough/HoughAccumulator.hx" private="1" module="vision.ds.hough.HoughAccumulator" final="1">
	<rhoMax public="1" get="accessor" set="null" static="1"><x path="Int"/></rhoMax>
	<get_rhoMax set="method" line="20" static="1"><f a="this">
	<c path="Array"><c path="Array"><x path="Int"/></c></c>
	<x path="Int"/>
</f></get_rhoMax>
	<_new public="1" set="method" line="24" static="1">
		<f a="maxRho">
			<x path="Int"/>
			<x path="vision.ds.hough.HoughAccumulator"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<incrementCell public="1" set="method" line="38" static="1">
		<f a="this:rho:thetaIndex">
			<c path="Array"><c path="Array"><x path="Int"/></c></c>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>* Increments the value of the cell located in `rho`,`theta`.
	 * 
	 * The `theta` value is not actually the floating value in radians, but the `index` of `theta`.</haxe_doc>
	</incrementCell>
	<decrementCell public="1" set="method" line="48" static="1">
		<f a="this:rho:thetaIndex">
			<c path="Array"><c path="Array"><x path="Int"/></c></c>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>* Decrements the value of the cell located in `rho`,`theta`.
	 * 
	 * The `theta` value is not actually the floating value in radians, but the `index` of `theta`.</haxe_doc>
	</decrementCell>
	<setCell public="1" set="method" line="58" static="1">
		<f a="this:rho:thetaIndex:value">
			<c path="Array"><c path="Array"><x path="Int"/></c></c>
			<x path="Float"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>* Sets the value of the cell located in `rho`,`theta`.
	 * 
	 * The `theta` value is not actually the floating value in radians, but the `index` of `theta`.</haxe_doc>
	</setCell>
	<getMaximas public="1" set="method" line="67" static="1">
		<f a="this:threshold">
			<c path="Array"><c path="Array"><x path="Int"/></c></c>
			<x path="Int"/>
			<c path="Array"><x path="vision.ds.IntPoint2D"/></c>
		</f>
		<haxe_doc>* Retrieves the positions of all the cell containing a value which is a local maximum
	 * 
	 * @return an array of `IntPoint2D`s, containing the locations of the cells. `point.x` is `rho`, `point.y` is the theta's index.</haxe_doc>
	</getMaximas>
	<cellIterator public="1" set="method" line="91" static="1"><f a="this">
	<c path="Array"><c path="Array"><x path="Int"/></c></c>
	<c path="haxe.iterators.ArrayIterator"><c path="Array"><x path="Int"/></c></c>
</f></cellIterator>
</class></impl>
	</abstract>
	<class path="vision.ds.hough._HoughAccumulator.HoughAccumulator_Impl_" params="" file="src/vision/ds/hough/HoughAccumulator.hx" private="1" module="vision.ds.hough.HoughAccumulator" final="1">
		<rhoMax public="1" get="accessor" set="null" static="1"><x path="Int"/></rhoMax>
		<get_rhoMax set="method" line="20" static="1"><f a="this">
	<c path="Array"><c path="Array"><x path="Int"/></c></c>
	<x path="Int"/>
</f></get_rhoMax>
		<_new public="1" set="method" line="24" static="1">
			<f a="maxRho">
				<x path="Int"/>
				<x path="vision.ds.hough.HoughAccumulator"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<incrementCell public="1" set="method" line="38" static="1">
			<f a="this:rho:thetaIndex">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Increments the value of the cell located in `rho`,`theta`.
	 * 
	 * The `theta` value is not actually the floating value in radians, but the `index` of `theta`.</haxe_doc>
		</incrementCell>
		<decrementCell public="1" set="method" line="48" static="1">
			<f a="this:rho:thetaIndex">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Decrements the value of the cell located in `rho`,`theta`.
	 * 
	 * The `theta` value is not actually the floating value in radians, but the `index` of `theta`.</haxe_doc>
		</decrementCell>
		<setCell public="1" set="method" line="58" static="1">
			<f a="this:rho:thetaIndex:value">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the value of the cell located in `rho`,`theta`.
	 * 
	 * The `theta` value is not actually the floating value in radians, but the `index` of `theta`.</haxe_doc>
		</setCell>
		<getMaximas public="1" set="method" line="67" static="1">
			<f a="this:threshold">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<x path="Int"/>
				<c path="Array"><x path="vision.ds.IntPoint2D"/></c>
			</f>
			<haxe_doc>* Retrieves the positions of all the cell containing a value which is a local maximum
	 * 
	 * @return an array of `IntPoint2D`s, containing the locations of the cells. `point.x` is `rho`, `point.y` is the theta's index.</haxe_doc>
		</getMaximas>
		<cellIterator public="1" set="method" line="91" static="1"><f a="this">
	<c path="Array"><c path="Array"><x path="Int"/></c></c>
	<c path="haxe.iterators.ArrayIterator"><c path="Array"><x path="Int"/></c></c>
</f></cellIterator>
	</class>
	<class path="vision.ds.hough.HoughSpace" params="" file="src/vision/ds/hough/HoughSpace.hx">
		<accumulator public="1" set="null">
			<x path="vision.ds.hough.HoughAccumulator"/>
			<haxe_doc>The Hough space is a 2D array of `Int`.
		The accumulator is that array.</haxe_doc>
		</accumulator>
		<image public="1" set="null">
			<x path="vision.ds.Image"/>
			<haxe_doc>This isn't really the accumulator, but it is used to visualize the Hough space.
		the reason this and the accumulator are separate is because the accumulator's value
		is more "predictable" - represented as `Int` and not colors.</haxe_doc>
		</image>
		<maximums public="1">
			<c path="Array"><x path="vision.ds.IntPoint2D"/></c>
			<haxe_doc>The "maximums" of the Hough space:

		when a certain point in the accumulator is greater than a given value,
		the point is considered a maximum, and the value is added to the maximums array.</haxe_doc>
		</maximums>
		<rays public="1">
			<c path="Array"><c path="vision.ds.Ray2D"/></c>
			<haxe_doc>The rays detected from the accumulator.

		Those are defined only when using the ~~`getHoughSpaceWithRays`~~ method.

		@see ~~getHoughSpaceWithRays()~~</haxe_doc>
		</rays>
		<new public="1" set="method" line="35"><f a="accumulator:image">
	<x path="vision.ds.hough.HoughAccumulator"/>
	<x path="vision.ds.Image"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":structInit"/></meta>
	</class>
	<enum path="vision.ds.specifics.AlgorithmSettings" params="" file="src/vision/ds/specifics/AlgorithmSettings.hx">
		<VeryLow_VeryFast><haxe_doc>Lowest quality, best performance</haxe_doc></VeryLow_VeryFast>
		<Low_Fast><haxe_doc>Low quality, great performance</haxe_doc></Low_Fast>
		<Medium_Intermediate><haxe_doc>Medium quality, Medium performance</haxe_doc></Medium_Intermediate>
		<High_Slow><haxe_doc>High quality, worse performance</haxe_doc></High_Slow>
		<VeryHigh_VerySlow><haxe_doc>Highest quality, worst performance</haxe_doc></VeryHigh_VerySlow>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<abstract path="vision.ds.specifics.ColorImportanceOrder" params="" file="src/vision/ds/specifics/ColorImportanceOrder.hx">
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast><x path="vision.ds.Color"/></icast>
		</to>
		<haxe_doc>Importance order of different color channels when using morphology functions (dilation/erosion)</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="vision.ds.specifics._ColorImportanceOrder.ColorImportanceOrder_Impl_" params="" file="src/vision/ds/specifics/ColorImportanceOrder.hx" private="1" module="vision.ds.specifics.ColorImportanceOrder" extern="1" final="1">
	<RedGreenBlue public="1" get="inline" set="null" expr="cast 0xFFFFFEFD" line="15" static="1">
		<x path="vision.ds.specifics.ColorImportanceOrder"/>
		<meta>
			<m n=":value"><e>cast 0xFFFFFEFD</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>When using erosion/dilation, channel importance follows:

        1. Red
        1. Green
        1. Blue</haxe_doc>
	</RedGreenBlue>
	<GreenBlueRed public="1" get="inline" set="null" expr="cast 0xFFFDFFFE" line="24" static="1">
		<x path="vision.ds.specifics.ColorImportanceOrder"/>
		<meta>
			<m n=":value"><e>cast 0xFFFDFFFE</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>When using erosion/dilation, channel importance follows:

        1. Green
        1. Blue
        1. Red</haxe_doc>
	</GreenBlueRed>
	<BlueRedGreen public="1" get="inline" set="null" expr="cast 0xFFFEFDFF" line="33" static="1">
		<x path="vision.ds.specifics.ColorImportanceOrder"/>
		<meta>
			<m n=":value"><e>cast 0xFFFEFDFF</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>When using erosion/dilation, channel importance follows:

        1. Blue
        1. Red
        1. Green</haxe_doc>
	</BlueRedGreen>
	<BlueGreenRed public="1" get="inline" set="null" expr="cast 0xFFFDFEFF" line="42" static="1">
		<x path="vision.ds.specifics.ColorImportanceOrder"/>
		<meta>
			<m n=":value"><e>cast 0xFFFDFEFF</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>When using erosion/dilation, channel importance follows:

        1. Blue
        1. Green
        1. Red</haxe_doc>
	</BlueGreenRed>
	<RedBlueGreen public="1" get="inline" set="null" expr="cast 0xFFFFFDFE" line="51" static="1">
		<x path="vision.ds.specifics.ColorImportanceOrder"/>
		<meta>
			<m n=":value"><e>cast 0xFFFFFDFE</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>When using erosion/dilation, channel importance follows:

        1. Red
        1. Blue
        1. Green</haxe_doc>
	</RedBlueGreen>
	<GreenRedBlue public="1" get="inline" set="null" expr="cast 0xFFFEFFFD" line="60" static="1">
		<x path="vision.ds.specifics.ColorImportanceOrder"/>
		<meta>
			<m n=":value"><e>cast 0xFFFEFFFD</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>When using erosion/dilation, channel importance follows:

        1. Green
        1. Red
        1. Blue</haxe_doc>
	</GreenRedBlue>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds.specifics._ColorImportanceOrder.ColorImportanceOrder_Impl_" params="" file="src/vision/ds/specifics/ColorImportanceOrder.hx" private="1" module="vision.ds.specifics.ColorImportanceOrder" extern="1" final="1">
		<RedGreenBlue public="1" get="inline" set="null" expr="cast 0xFFFFFEFD" line="15" static="1">
			<x path="vision.ds.specifics.ColorImportanceOrder"/>
			<meta>
				<m n=":value"><e>cast 0xFFFFFEFD</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>When using erosion/dilation, channel importance follows:

        1. Red
        1. Green
        1. Blue</haxe_doc>
		</RedGreenBlue>
		<GreenBlueRed public="1" get="inline" set="null" expr="cast 0xFFFDFFFE" line="24" static="1">
			<x path="vision.ds.specifics.ColorImportanceOrder"/>
			<meta>
				<m n=":value"><e>cast 0xFFFDFFFE</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>When using erosion/dilation, channel importance follows:

        1. Green
        1. Blue
        1. Red</haxe_doc>
		</GreenBlueRed>
		<BlueRedGreen public="1" get="inline" set="null" expr="cast 0xFFFEFDFF" line="33" static="1">
			<x path="vision.ds.specifics.ColorImportanceOrder"/>
			<meta>
				<m n=":value"><e>cast 0xFFFEFDFF</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>When using erosion/dilation, channel importance follows:

        1. Blue
        1. Red
        1. Green</haxe_doc>
		</BlueRedGreen>
		<BlueGreenRed public="1" get="inline" set="null" expr="cast 0xFFFDFEFF" line="42" static="1">
			<x path="vision.ds.specifics.ColorImportanceOrder"/>
			<meta>
				<m n=":value"><e>cast 0xFFFDFEFF</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>When using erosion/dilation, channel importance follows:

        1. Blue
        1. Green
        1. Red</haxe_doc>
		</BlueGreenRed>
		<RedBlueGreen public="1" get="inline" set="null" expr="cast 0xFFFFFDFE" line="51" static="1">
			<x path="vision.ds.specifics.ColorImportanceOrder"/>
			<meta>
				<m n=":value"><e>cast 0xFFFFFDFE</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>When using erosion/dilation, channel importance follows:

        1. Red
        1. Blue
        1. Green</haxe_doc>
		</RedBlueGreen>
		<GreenRedBlue public="1" get="inline" set="null" expr="cast 0xFFFEFFFD" line="60" static="1">
			<x path="vision.ds.specifics.ColorImportanceOrder"/>
			<meta>
				<m n=":value"><e>cast 0xFFFEFFFD</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>When using erosion/dilation, channel importance follows:

        1. Green
        1. Red
        1. Blue</haxe_doc>
		</GreenRedBlue>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="vision.ds.specifics.EdgeFilterType" params="" file="src/vision/ds/specifics/EdgeFilterType.hx">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vision.ds.specifics._EdgeFilterType.EdgeFilterType_Impl_" params="" file="src/vision/ds/specifics/EdgeFilterType.hx" private="1" module="vision.ds.specifics.EdgeFilterType" extern="1" final="1">
	<SOBEL public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="vision.ds.specifics.EdgeFilterType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SOBEL>
	<PERWITT public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="vision.ds.specifics.EdgeFilterType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PERWITT>
	<ROBERT public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="vision.ds.specifics.EdgeFilterType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ROBERT>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds.specifics._EdgeFilterType.EdgeFilterType_Impl_" params="" file="src/vision/ds/specifics/EdgeFilterType.hx" private="1" module="vision.ds.specifics.EdgeFilterType" extern="1" final="1">
		<SOBEL public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="vision.ds.specifics.EdgeFilterType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SOBEL>
		<PERWITT public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="vision.ds.specifics.EdgeFilterType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PERWITT>
		<ROBERT public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="vision.ds.specifics.EdgeFilterType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ROBERT>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="vision.ds.specifics.ImageExpansionMode" params="" file="src/vision/ds/specifics/ImageExpansionMode.hx">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vision.ds.specifics._ImageExpansionMode.ImageExpansionMode_Impl_" params="" file="src/vision/ds/specifics/ImageExpansionMode.hx" private="1" module="vision.ds.specifics.ImageExpansionMode" extern="1" final="1">
	<SAME_SIZE public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="vision.ds.specifics.ImageExpansionMode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Does not change image size.</haxe_doc>
	</SAME_SIZE>
	<EXPAND public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="vision.ds.specifics.ImageExpansionMode"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Expands the image when the transformation matrix pushes pixels out of bounds.</haxe_doc>
	</EXPAND>
	<SHRINK public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="vision.ds.specifics.ImageExpansionMode"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Shrinks the image when the transformation matrix does not reach image bounds</haxe_doc>
	</SHRINK>
	<RESIZE public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="vision.ds.specifics.ImageExpansionMode"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>A combination of `EXPAND` and `SHRINK`, Changes image size when the 
		transformation matrix pushes pixels out of bounds, or does not reach them.</haxe_doc>
	</RESIZE>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds.specifics._ImageExpansionMode.ImageExpansionMode_Impl_" params="" file="src/vision/ds/specifics/ImageExpansionMode.hx" private="1" module="vision.ds.specifics.ImageExpansionMode" extern="1" final="1">
		<SAME_SIZE public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="vision.ds.specifics.ImageExpansionMode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Does not change image size.</haxe_doc>
		</SAME_SIZE>
		<EXPAND public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="vision.ds.specifics.ImageExpansionMode"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Expands the image when the transformation matrix pushes pixels out of bounds.</haxe_doc>
		</EXPAND>
		<SHRINK public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="vision.ds.specifics.ImageExpansionMode"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Shrinks the image when the transformation matrix does not reach image bounds</haxe_doc>
		</SHRINK>
		<RESIZE public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="vision.ds.specifics.ImageExpansionMode"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>A combination of `EXPAND` and `SHRINK`, Changes image size when the 
		transformation matrix pushes pixels out of bounds, or does not reach them.</haxe_doc>
		</RESIZE>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="vision.ds.specifics.PointTransformationPair" params="" file="src/vision/ds/specifics/PointTransformationPair.hx">
		<from public="1"><c path="vision.ds.Point2D"/></from>
		<to public="1"><c path="vision.ds.Point2D"/></to>
		<new public="1" set="method" line="9"><f a="from:to">
	<c path="vision.ds.Point2D"/>
	<c path="vision.ds.Point2D"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":structInit"/></meta>
	</class>
	<abstract path="vision.ds.specifics.TransformationMatrixOrigination" params="" file="src/vision/ds/specifics/TransformationMatrixOrigination.hx">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vision.ds.specifics._TransformationMatrixOrigination.TransformationMatrixOrigination_Impl_" params="" file="src/vision/ds/specifics/TransformationMatrixOrigination.hx" private="1" module="vision.ds.specifics.TransformationMatrixOrigination" extern="1" final="1">
	<CENTER public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Transformation origin is offset to:  
		`(image.width / 2, image.height / 2)`
		```
		â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		â”‚      *      â”‚
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
		```</haxe_doc>
	</CENTER>
	<TOP_LEFT public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Transformation origin is offset to:
		`(0, 0)`
		```
		*â•¶â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		â”‚             â”‚
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
		```</haxe_doc>
	</TOP_LEFT>
	<TOP_RIGHT public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Transformation origin is offset to:
		`(image.width, 0)`
		```
		â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•´*
		â”‚             â”‚
		â”‚             â”‚
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</haxe_doc>
	</TOP_RIGHT>
	<BOTTOM_LEFT public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Transformation origin is offset to:
		`(0, image.height)`
		```
		â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		â”‚             â”‚
		â”‚             â”‚
		*â•¶â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</haxe_doc>
	</BOTTOM_LEFT>
	<BOTTOM_RIGHT public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
		<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Transformation origin is offset to:
		`(image.width, image.height)`
		```
		â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		â”‚             â”‚
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•´*
		```</haxe_doc>
	</BOTTOM_RIGHT>
	<TOP_CENTER public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
		<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Transformation origin is offset to:
		`(image.width / 2, 0)`
		```
		â”Œâ”€â”€â”€â”€â”€â•´*â•¶â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		â”‚             â”‚
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
		```</haxe_doc>
	</TOP_CENTER>
	<BOTTOM_CENTER public="1" get="inline" set="null" expr="cast 6" line="1" static="1">
		<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Transformation origin is offset to:
		`(image.width / 2, image.height)`
		```
		â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		â”‚             â”‚
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â•´*â•¶â”€â”€â”€â”€â”€â”˜
		```</haxe_doc>
	</BOTTOM_CENTER>
	<LEFT_CENTER public="1" get="inline" set="null" expr="cast 7" line="1" static="1">
		<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Transformation origin is offset to:
		`(0, image.height / 2)`
		```
		â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		*             â”‚
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
		```</haxe_doc>
	</LEFT_CENTER>
	<RIGHT_CENTER public="1" get="inline" set="null" expr="cast 8" line="1" static="1">
		<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Transformation origin is offset to:
		`(image.width, image.height / 2)`
		```
		â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		â”‚             *
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
		```</haxe_doc>
	</RIGHT_CENTER>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds.specifics._TransformationMatrixOrigination.TransformationMatrixOrigination_Impl_" params="" file="src/vision/ds/specifics/TransformationMatrixOrigination.hx" private="1" module="vision.ds.specifics.TransformationMatrixOrigination" extern="1" final="1">
		<CENTER public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Transformation origin is offset to:  
		`(image.width / 2, image.height / 2)`
		```
		â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		â”‚      *      â”‚
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
		```</haxe_doc>
		</CENTER>
		<TOP_LEFT public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Transformation origin is offset to:
		`(0, 0)`
		```
		*â•¶â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		â”‚             â”‚
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
		```</haxe_doc>
		</TOP_LEFT>
		<TOP_RIGHT public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Transformation origin is offset to:
		`(image.width, 0)`
		```
		â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•´*
		â”‚             â”‚
		â”‚             â”‚
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</haxe_doc>
		</TOP_RIGHT>
		<BOTTOM_LEFT public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Transformation origin is offset to:
		`(0, image.height)`
		```
		â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		â”‚             â”‚
		â”‚             â”‚
		*â•¶â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</haxe_doc>
		</BOTTOM_LEFT>
		<BOTTOM_RIGHT public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
			<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Transformation origin is offset to:
		`(image.width, image.height)`
		```
		â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		â”‚             â”‚
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•´*
		```</haxe_doc>
		</BOTTOM_RIGHT>
		<TOP_CENTER public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
			<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Transformation origin is offset to:
		`(image.width / 2, 0)`
		```
		â”Œâ”€â”€â”€â”€â”€â•´*â•¶â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		â”‚             â”‚
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
		```</haxe_doc>
		</TOP_CENTER>
		<BOTTOM_CENTER public="1" get="inline" set="null" expr="cast 6" line="1" static="1">
			<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Transformation origin is offset to:
		`(image.width / 2, image.height)`
		```
		â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		â”‚             â”‚
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â•´*â•¶â”€â”€â”€â”€â”€â”˜
		```</haxe_doc>
		</BOTTOM_CENTER>
		<LEFT_CENTER public="1" get="inline" set="null" expr="cast 7" line="1" static="1">
			<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Transformation origin is offset to:
		`(0, image.height / 2)`
		```
		â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		*             â”‚
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
		```</haxe_doc>
		</LEFT_CENTER>
		<RIGHT_CENTER public="1" get="inline" set="null" expr="cast 8" line="1" static="1">
			<x path="vision.ds.specifics.TransformationMatrixOrigination"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Transformation origin is offset to:
		`(image.width, image.height / 2)`
		```
		â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
		â”‚             â”‚
		â”‚             *
		â”‚             â”‚
		â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
		```</haxe_doc>
		</RIGHT_CENTER>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="vision.ds.specifics.WhiteNoiseRange" params="" file="src/vision/ds/specifics/WhiteNoiseRange.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="vision.ds.specifics._WhiteNoiseRange.WhiteNoiseRange_Impl_" params="" file="src/vision/ds/specifics/WhiteNoiseRange.hx" private="1" module="vision.ds.specifics.WhiteNoiseRange" extern="1" final="1">
	<RANGE_2 public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="vision.ds.specifics.WhiteNoiseRange"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Allows 2 shades of "gray" - either black or white.</haxe_doc>
	</RANGE_2>
	<RANGE_8 public="1" get="inline" set="null" expr="cast 8" line="13" static="1">
		<x path="vision.ds.specifics.WhiteNoiseRange"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Allows 8 shades of gray</haxe_doc>
	</RANGE_8>
	<RANGE_16 public="1" get="inline" set="null" expr="cast 16" line="18" static="1">
		<x path="vision.ds.specifics.WhiteNoiseRange"/>
		<meta>
			<m n=":value"><e>cast 16</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Allows 16 shades of gray.</haxe_doc>
	</RANGE_16>
	<RANGE_64 public="1" get="inline" set="null" expr="cast 64" line="23" static="1">
		<x path="vision.ds.specifics.WhiteNoiseRange"/>
		<meta>
			<m n=":value"><e>cast 64</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Allows 64 shades of gray.</haxe_doc>
	</RANGE_64>
	<RANGE_256 public="1" get="inline" set="null" expr="cast 256" line="28" static="1">
		<x path="vision.ds.specifics.WhiteNoiseRange"/>
		<meta>
			<m n=":value"><e>cast 256</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Allows 256 shades of gray.</haxe_doc>
	</RANGE_256>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vision.ds.specifics._WhiteNoiseRange.WhiteNoiseRange_Impl_" params="" file="src/vision/ds/specifics/WhiteNoiseRange.hx" private="1" module="vision.ds.specifics.WhiteNoiseRange" extern="1" final="1">
		<RANGE_2 public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="vision.ds.specifics.WhiteNoiseRange"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Allows 2 shades of "gray" - either black or white.</haxe_doc>
		</RANGE_2>
		<RANGE_8 public="1" get="inline" set="null" expr="cast 8" line="13" static="1">
			<x path="vision.ds.specifics.WhiteNoiseRange"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Allows 8 shades of gray</haxe_doc>
		</RANGE_8>
		<RANGE_16 public="1" get="inline" set="null" expr="cast 16" line="18" static="1">
			<x path="vision.ds.specifics.WhiteNoiseRange"/>
			<meta>
				<m n=":value"><e>cast 16</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Allows 16 shades of gray.</haxe_doc>
		</RANGE_16>
		<RANGE_64 public="1" get="inline" set="null" expr="cast 64" line="23" static="1">
			<x path="vision.ds.specifics.WhiteNoiseRange"/>
			<meta>
				<m n=":value"><e>cast 64</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Allows 64 shades of gray.</haxe_doc>
		</RANGE_64>
		<RANGE_256 public="1" get="inline" set="null" expr="cast 256" line="28" static="1">
			<x path="vision.ds.specifics.WhiteNoiseRange"/>
			<meta>
				<m n=":value"><e>cast 256</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Allows 256 shades of gray.</haxe_doc>
		</RANGE_256>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="vision.exceptions.VisionException" params="" file="src/vision/exceptions/VisionException.hx">
		<extends path="haxe.Exception"/>
		<new public="1" set="method" line="22"><f a="message:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>A type of error, thrown by components of the `Vision` library</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.exceptions.ImageLoadingFailed" params="" file="src/vision/exceptions/ImageLoadingFailed.hx">
		<extends path="vision.exceptions.VisionException"/>
		<new public="1" set="method" line="6"><f a="type:reason">
	<x path="vision.ds.ImageFormat"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="vision.exceptions.ImageSavingFailed" params="" file="src/vision/exceptions/ImageSavingFailed.hx">
		<extends path="vision.exceptions.VisionException"/>
		<new public="1" set="method" line="6"><f a="type:reason">
	<x path="vision.ds.ImageFormat"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="vision.exceptions.InvalidGaussianKernelSize" params="" file="src/vision/exceptions/InvalidGaussianKernelSize.hx">
		<extends path="vision.exceptions.VisionException"/>
		<getReason get="inline" set="null" line="10"><f a="size">
	<x path="Int"/>
	<c path="String"/>
</f></getReason>
		<new public="1" set="method" line="6"><f a="size">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.exceptions.LibraryRequired" params="" file="src/vision/exceptions/LibraryRequired.hx">
		<extends path="vision.exceptions.VisionException"/>
		<getInclusionMethod set="method" line="8" static="1"><f a="libs">
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
</f></getInclusionMethod>
		<new public="1" set="method" line="4">
			<f a="library:dependencies:classDotField:?fieldType" v=":::&quot;function&quot;">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fieldType : "function" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.exceptions.MatrixOperationError" params="" file="src/vision/exceptions/MatrixOperationError.hx">
		<extends path="vision.exceptions.VisionException"/>
		<errorByType public="1" set="method" line="18" static="1"><f a="type:mats:off">
	<c path="String"/>
	<c path="Array"><x path="vision.ds.Matrix2D"/></c>
	<x path="vision.exceptions.MatrixError"/>
	<c path="String"/>
</f></errorByType>
		<new public="1" set="method" line="14">
			<f a="op:matrices:offense">
				<c path="String"/>
				<c path="Array"><x path="vision.ds.Matrix2D"/></c>
				<x path="vision.exceptions.MatrixError"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Notice - assumes 2 matrices
    	@param op mathematical operation theat caused the error, named (e.g. `+` -> addition, `-` -> subtraction)
    	@param matrices the two offending matrices]]></haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="vision.exceptions.MatrixError" params="" file="src/vision/exceptions/MatrixOperationError.hx" module="vision.exceptions.MatrixOperationError">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="vision.exceptions._MatrixOperationError.MatrixError_Impl_" params="" file="src/vision/exceptions/MatrixOperationError.hx" private="1" module="vision.exceptions.MatrixOperationError" extern="1" final="1">
	<Mult_MismatchingDimensions public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="vision.exceptions.MatrixError"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Mult_MismatchingDimensions>
	<Add_MismatchingDimensions public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="vision.exceptions.MatrixError"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Add_MismatchingDimensions>
	<Sub_MismatchingDimensions public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="vision.exceptions.MatrixError"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Sub_MismatchingDimensions>
	<Div_MismatchingDimensions public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="vision.exceptions.MatrixError"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Div_MismatchingDimensions>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="vision.exceptions._MatrixOperationError.MatrixError_Impl_" params="" file="src/vision/exceptions/MatrixOperationError.hx" private="1" module="vision.exceptions.MatrixOperationError" extern="1" final="1">
		<Mult_MismatchingDimensions public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="vision.exceptions.MatrixError"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Mult_MismatchingDimensions>
		<Add_MismatchingDimensions public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="vision.exceptions.MatrixError"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Add_MismatchingDimensions>
		<Sub_MismatchingDimensions public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="vision.exceptions.MatrixError"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Sub_MismatchingDimensions>
		<Div_MismatchingDimensions public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="vision.exceptions.MatrixError"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Div_MismatchingDimensions>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="vision.exceptions.MultithreadFailure" params="" file="src/vision/exceptions/MultithreadFailure.hx">
		<extends path="vision.exceptions.VisionException"/>
		<new public="1" set="method" line="4"><f a="count:reason">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.exceptions.OutOfBounds" params="" file="src/vision/exceptions/OutOfBounds.hx">
		<extends path="vision.exceptions.VisionException"/>
		<new public="1" set="method" line="8"><f a="image:position">
	<x path="vision.ds.Image"/>
	<c path="vision.ds.Point2D"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.exceptions.Unimplemented" params="" file="src/vision/exceptions/Unimplemented.hx">
		<extends path="vision.exceptions.VisionException"/>
		<new public="1" set="method" line="4"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.helpers.TextDrawer" params="" file="src/vision/helpers/TextDrawer.hx">
		<reportDependencies public="1" set="method" line="13" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Throws the correct error when dependencies of opentype.hx are missing, unless vision_quiet is defined</haxe_doc>
		</reportDependencies>
		<drawTextOnImage public="1" set="method" line="23" static="1"><f a="image:x:y:size:text:font">
	<x path="vision.ds.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></drawTextOnImage>
	</class>
	<class path="vision.helpers.VisionThread" params="" file="src/vision/helpers/VisionThread.hx">
		<COUNT expr="0" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</COUNT>
		<create public="1" set="method" line="83" static="1"><f a="job">
	<f a=""><x path="Void"/></f>
	<c path="vision.helpers.VisionThread"/>
</f></create>
		<underlying><x path="sys.thread.Thread"/></underlying>
		<job public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* The currently assigned job. should be a function with 0 parameters and no return type (`Void` `->` `Void`)]]></haxe_doc>
		</job>
		<onFailed public="1" set="accessor">
			<f a="">
				<c path="haxe.Exception"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Dispatches when the job fails</haxe_doc>
		</onFailed>
		<onDone public="1" set="accessor">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Dispatches when the job is done</haxe_doc>
		</onDone>
		<jobDone public="1" set="null">
			<x path="Null"><x path="Bool"/></x>
			<haxe_doc>* |Value|Status|
	 * |---|:---:|
	 * |`true`|After the job is done|
	 * |`false`|After the job has failed|
	 * |`null`|Before/During the job|</haxe_doc>
		</jobDone>
		<relaunchEvents public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Makes `Done` and `Failed` events relaunch when set.</haxe_doc>
		</relaunchEvents>
		<count final="1" public="1">
			<x path="Int"/>
			<haxe_doc>* The `ID` of the thread. useful for debugging when the thread fails.</haxe_doc>
		</count>
		<start public="1" set="method" line="59"><f a=""><x path="Void"/></f></start>
		<onFailedWrapper set="method" line="78"><f a="d">
	<c path="haxe.Exception"/>
	<x path="Void"/>
</f></onFailedWrapper>
		<set_onFailed set="method" line="89"><f a="value">
	<f a="">
		<c path="haxe.Exception"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="haxe.Exception"/>
		<x path="Void"/>
	</f>
</f></set_onFailed>
		<set_onDone set="method" line="96"><f a="value">
	<f a=""><x path="Void"/></f>
	<f a=""><x path="Void"/></f>
</f></set_onDone>
		<new public="1" set="method" line="50"><f a="job">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="vision.helpers.pixelTriangle.iter._BoundIterator.BoundIterator_Fields_" params="" file="src/vision/helpers/pixelTriangle/iter/BoundIterator.hx" private="1" module="vision.helpers.pixelTriangle.iter.BoundIterator" final="1"><boundIterator3 public="1" get="inline" set="null" line="30" static="1">
	<f a="a:b:c">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Float"/>
		<c path="IntIterator"/>
	</f>
	<haxe_doc>Used for bounding box iteration, calculates lo...hi iterator from 3 values.</haxe_doc>
</boundIterator3></class>
	<class path="vision.helpers.pixelTriangle.iter.IntIterStart" params="" file="src/vision/helpers/pixelTriangle/iter/IteratorRange.hx" module="vision.helpers.pixelTriangle.iter.IteratorRange">
		<start public="1"><x path="Int"/></start>
		<max public="1"><x path="Int"/></max>
		<new public="1" set="method" line="35"><f a="min_:max_">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Like a normal IntIterator but allows access of start and max after construction and reuse.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access">
				<e>IntIterator.min</e>
				<e>IntIterator.max</e>
			</m>
		</meta>
	</class>
	<abstract path="vision.helpers.pixelTriangle.iter.IteratorRange" params="" file="src/vision/helpers/pixelTriangle/iter/IteratorRange.hx">
		<from>
			<icast><c path="vision.helpers.pixelTriangle.iter.IntIterStart"/></icast>
			<icast field="fromIterator"><c path="IntIterator"/></icast>
		</from>
		<this><c path="vision.helpers.pixelTriangle.iter.IntIterStart"/></this>
		<to><icast field="toIterStart"><x path="vision.helpers.pixelTriangle.iter.IteratorRange"/></icast></to>
		<meta>
			<m n=":transitive"/>
			<m n=":access">
				<e>IntIterator.min</e>
				<e>IntIterator.max</e>
			</m>
			<m n=":forward"/>
		</meta>
		<impl><class path="vision.helpers.pixelTriangle.iter._IteratorRange.IteratorRange_Impl_" params="" file="src/vision/helpers/pixelTriangle/iter/IteratorRange.hx" private="1" module="vision.helpers.pixelTriangle.iter.IteratorRange" final="1">
	<startLength public="1" get="inline" set="null" line="45" static="1"><f a="min:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
</f></startLength>
	<_new public="1" get="inline" set="null" line="49" static="1">
		<f a="min:max">
			<x path="Int"/>
			<x path="Int"/>
			<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<fromIterator public="1" get="inline" set="null" line="54" static="1">
		<f a="ii">
			<c path="IntIterator"/>
			<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromIterator>
	<toIterStart set="method" line="59" static="1">
		<f a="this">
			<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
			<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
		</f>
		<meta><m n=":to"/></meta>
	</toIterStart>
	<iterator public="1" get="inline" set="null" line="63" static="1"><f a="this">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<c path="IntIterator"/>
</f></iterator>
	<adding public="1" get="inline" set="null" line="67" static="1">
		<f a="a:b">
			<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
			<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
			<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</adding>
	<add public="1" get="inline" set="null" line="71" static="1"><f a="this:b">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
	<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
</f></add>
	<length public="1" get="accessor" set="accessor" static="1"><x path="Int"/></length>
	<get_length get="inline" set="null" line="79" static="1"><f a="this">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<x path="Int"/>
</f></get_length>
	<set_length get="inline" set="null" line="83" static="1"><f a="this:l">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_length>
	<contains public="1" get="inline" set="null" line="88" static="1"><f a="this:v">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></contains>
	<isWithin public="1" get="inline" set="null" line="92" static="1"><f a="this:ir">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
	<x path="Bool"/>
</f></isWithin>
	<moveRange public="1" get="inline" set="null" line="96" static="1"><f a="this:v">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Void"/>
</f></moveRange>
	<addAssign public="1" get="inline" set="null" line="102" static="1">
		<f a="a:v">
			<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
			<x path="Int"/>
			<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
		</f>
		<meta><m n=":op"><e>A += B</e></m></meta>
	</addAssign>
	<minusAssign public="1" get="inline" set="null" line="108" static="1">
		<f a="a:v">
			<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
			<x path="Int"/>
			<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
		</f>
		<meta><m n=":op"><e>A -= B</e></m></meta>
	</minusAssign>
	<ifContainMove public="1" get="inline" set="null" line="112" static="1"><f a="this:v:amount">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></ifContainMove>
	<meta><m n=":access">
	<e>IntIterator.min</e>
	<e>IntIterator.max</e>
</m></meta>
</class></impl>
	</abstract>
	<class path="vision.helpers.pixelTriangle.iter._IteratorRange.IteratorRange_Impl_" params="" file="src/vision/helpers/pixelTriangle/iter/IteratorRange.hx" private="1" module="vision.helpers.pixelTriangle.iter.IteratorRange" final="1">
		<startLength public="1" get="inline" set="null" line="45" static="1"><f a="min:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
</f></startLength>
		<_new public="1" get="inline" set="null" line="49" static="1">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<fromIterator public="1" get="inline" set="null" line="54" static="1">
			<f a="ii">
				<c path="IntIterator"/>
				<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromIterator>
		<toIterStart set="method" line="59" static="1">
			<f a="this">
				<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
				<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
			</f>
			<meta><m n=":to"/></meta>
		</toIterStart>
		<iterator public="1" get="inline" set="null" line="63" static="1"><f a="this">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<c path="IntIterator"/>
</f></iterator>
		<adding public="1" get="inline" set="null" line="67" static="1">
			<f a="a:b">
				<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
				<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
				<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</adding>
		<add public="1" get="inline" set="null" line="71" static="1"><f a="this:b">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
	<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
</f></add>
		<length public="1" get="accessor" set="accessor" static="1"><x path="Int"/></length>
		<get_length get="inline" set="null" line="79" static="1"><f a="this">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<x path="Int"/>
</f></get_length>
		<set_length get="inline" set="null" line="83" static="1"><f a="this:l">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Int"/>
</f></set_length>
		<contains public="1" get="inline" set="null" line="88" static="1"><f a="this:v">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></contains>
		<isWithin public="1" get="inline" set="null" line="92" static="1"><f a="this:ir">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
	<x path="Bool"/>
</f></isWithin>
		<moveRange public="1" get="inline" set="null" line="96" static="1"><f a="this:v">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Void"/>
</f></moveRange>
		<addAssign public="1" get="inline" set="null" line="102" static="1">
			<f a="a:v">
				<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
				<x path="Int"/>
				<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
			</f>
			<meta><m n=":op"><e>A += B</e></m></meta>
		</addAssign>
		<minusAssign public="1" get="inline" set="null" line="108" static="1">
			<f a="a:v">
				<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
				<x path="Int"/>
				<x path="vision.helpers.pixelTriangle.iter.IteratorRange"/>
			</f>
			<meta><m n=":op"><e>A -= B</e></m></meta>
		</minusAssign>
		<ifContainMove public="1" get="inline" set="null" line="112" static="1"><f a="this:v:amount">
	<c path="vision.helpers.pixelTriangle.iter.IntIterStart"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></ifContainMove>
		<meta><m n=":access">
	<e>IntIterator.min</e>
	<e>IntIterator.max</e>
</m></meta>
	</class>
	<class path="vision.helpers.pixelTriangle.pixelPlus._BlendAlpha.BlendAlpha_Fields_" params="" file="src/vision/helpers/pixelTriangle/pixelPlus/BlendAlpha.hx" private="1" module="vision.helpers.pixelTriangle.pixelPlus.BlendAlpha" final="1">
		<alphaBlendImage public="1" get="inline" set="null" line="28" static="1"><f a="imageTarget:imageSource:xTarget:yTarget:xSource:ySource:w:h">
	<x path="vision.ds.Image"/>
	<x path="vision.ds.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></alphaBlendImage>
		<alphaBlend public="1" get="inline" set="null" line="35" static="1">
			<f a="lhs:rhs">
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
				<x path="vision.ds.Color"/>
			</f>
			<haxe_doc>provides alpha channel blend which is commumative</haxe_doc>
		</alphaBlend>
	</class>
	<class path="vision.helpers.pixelTriangle.pixelPlus._BytesHelper.BytesHelper_Fields_" params="" file="src/vision/helpers/pixelTriangle/pixelPlus/BytesHelper.hx" private="1" module="vision.helpers.pixelTriangle.pixelPlus.BytesHelper" final="1">
		<imageOff final="1" public="1" set="null" expr="vision.ds.Image.OFFSET" line="27" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>vision.ds.Image.OFFSET</e></m>
				<m n=":access"><e>vision.ds.Image.OFFSET</e></m>
			</meta>
			<haxe_doc>Allows injection of Bytes data directly into the Image and direct extraction</haxe_doc>
		</imageOff>
		<imageLen public="1" get="inline" set="null" line="30" static="1"><f a="image">
	<x path="vision.ds.Image"/>
	<x path="Int"/>
</f></imageLen>
		<injectBytesInImage public="1" get="inline" set="null" line="33" static="1"><f a="bytes:image">
	<c path="haxe.io.Bytes"/>
	<x path="vision.ds.Image"/>
	<x path="Void"/>
</f></injectBytesInImage>
		<extractBytesFromImage public="1" get="inline" set="null" line="35" static="1"><f a="image">
	<x path="vision.ds.Image"/>
	<c path="haxe.io.Bytes"/>
</f></extractBytesFromImage>
	</class>
	<class path="vision.helpers.pixelTriangle.pixelPlus._ChannelHelp.ChannelHelp_Fields_" params="" file="src/vision/helpers/pixelTriangle/pixelPlus/ChannelHelp.hx" private="1" module="vision.helpers.pixelTriangle.pixelPlus.ChannelHelp" final="1">
		<boundChannel public="1" get="inline" set="null" line="23" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></boundChannel>
		<colBlendFunc public="1" get="inline" set="null" line="31" static="1"><f a="x1:x2:a3:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></colBlendFunc>
		<alphaBlendFunc public="1" get="inline" set="null" line="34" static="1"><f a="a3:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></alphaBlendFunc>
		<channelFloat public="1" get="inline" set="null" line="37" static="1"><f a="color">
	<x path="Int"/>
	<x path="Float"/>
</f></channelFloat>
	</class>
	<class path="vision.helpers.pixelTriangle.pixelPlus._PixelsTransform.PixelsTransform_Fields_" params="" file="src/vision/helpers/pixelTriangle/pixelPlus/PixelsTransform.hx" private="1" module="vision.helpers.pixelTriangle.pixelPlus.PixelsTransform" final="1"><pixelsTransform public="1" get="inline" set="null" line="28" static="1"><f a="imageTarget:imageSource:transformFunc:xTarget:yTarget:xSource:ySource:w:h">
	<x path="vision.ds.Image"/>
	<x path="vision.ds.Image"/>
	<f a="colorTarget:colorSource">
		<x path="vision.ds.Color"/>
		<x path="vision.ds.Color"/>
		<x path="vision.ds.Color"/>
	</f>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></pixelsTransform></class>
	<class path="vision.helpers.pixelTriangle.shape._Circle.Circle_Fields_" params="" file="src/vision/helpers/pixelTriangle/shape/Circle.hx" private="1" module="vision.helpers.pixelTriangle.shape.Circle" final="1">
		<ellipseFill public="1" get="inline" set="null" line="30" static="1"><f a="image:cx:cy:rx:ry:color">
	<x path="vision.ds.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></ellipseFill>
		<ellipseFillRadialGradient public="1" get="inline" set="null" line="45" static="1"><f a="image:cx:cy:rx:ry:colorIn:colorOut">
	<x path="vision.ds.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></ellipseFillRadialGradient>
		<quadrantGradientFill public="1" get="inline" set="null" line="60" static="1"><f a="image:cx:cy:rx:ry:rotation:colorIn:colorOut">
	<x path="vision.ds.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></quadrantGradientFill>
		<circleError public="1" get="inline" set="null" line="76" static="1">
			<f a="radius:?targetE:?minN:?maxN" v=":0.5:12:500">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ maxN : 500, minN : 12, targetE : 0.5 }</e></m></meta>
		</circleError>
		<getSidesDivisible4 public="1" get="inline" set="null" line="87" static="1">
			<f a="rx:ry:?targetError" v="::0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ targetError : 0.5 }</e></m></meta>
		</getSidesDivisible4>
	</class>
	<class path="vision.helpers.pixelTriangle.shape._Line.Line_Fields_" params="" file="src/vision/helpers/pixelTriangle/shape/Line.hx" private="1" module="vision.helpers.pixelTriangle.shape.Line" final="1">
		<lineFill public="1" get="inline" set="null" line="33" static="1">
			<f a="image:px:py:qx:qy:thick:color">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>provides a thick line using two triangles vector p, q</haxe_doc>
		</lineFill>
		<lineGradientFill public="1" get="inline" set="null" line="45" static="1">
			<f a="image:px:py:qx:qy:thick:colorA:colorB:colorC:colorD">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>provides a thick line using two gradient triangle vector p,q
	the four colors are arranged clockwise a,b,c,d</haxe_doc>
		</lineGradientFill>
		<rotateLine public="1" get="inline" set="null" line="53" static="1"><f a="image:px:py:thick:h:theta:color">
	<x path="vision.ds.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotateLine>
		<rotateGradLine public="1" get="inline" set="null" line="85" static="1"><f a="image:px:py:thick:h:theta:colorA:colorB:colorC:colorD">
	<x path="vision.ds.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotateGradLine>
		<rotX public="1" get="inline" set="null" line="118" static="1"><f a="x:y:sin:cos">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></rotX>
		<rotY public="1" get="inline" set="null" line="121" static="1"><f a="x:y:sin:cos">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></rotY>
	</class>
	<class path="vision.helpers.pixelTriangle.shape._Quad.Quad_Fields_" params="" file="src/vision/helpers/pixelTriangle/shape/Quad.hx" private="1" module="vision.helpers.pixelTriangle.shape.Quad" final="1">
		<quadFill public="1" get="inline" set="null" line="33" static="1">
			<f a="image:ax:ay:bx:by:cx:cy:dx:dy:color">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>uses two triangles to create a filled quad using four coordinates a,b,c,d arranged clockwise</haxe_doc>
		</quadFill>
		<quadGradientFill public="1" get="inline" set="null" line="45" static="1">
			<f a="image:ax:ay:colorA:bx:by:colorB:cx:cy:colorC:dx:dy:colorD">
				<x path="vision.ds.Image"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>uses two triangle to form a quad with clockwise coordinates a,b,c,d
	with respective colours after each coordinate pair</haxe_doc>
		</quadGradientFill>
	</class>
	<class path="vision.helpers.pixelTriangle.shape._Triangle.Triangle_Fields_" params="" file="src/vision/helpers/pixelTriangle/shape/Triangle.hx" private="1" module="vision.helpers.pixelTriangle.shape.Triangle" final="1">
		<triangleFill public="1" get="inline" set="null" line="33" static="1"><f a="image:ax:ay:bx:by:cx:cy:color">
	<x path="vision.ds.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></triangleFill>
		<fillTriangleUnsafe public="1" get="inline" set="null" line="46" static="1"><f a="image:ax:ay:bx:by:cx:cy:color">
	<x path="vision.ds.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fillTriangleUnsafe>
		<triangleGradientFill public="1" get="inline" set="null" line="84" static="1"><f a="image:ax:ay:colA:bx:by:colB:cx:cy:colC">
	<x path="vision.ds.Image"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></triangleGradientFill>
		<dot public="1" get="inline" set="null" line="127" static="1"><f a="ax:ay:bx:by">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></dot>
		<dotSame public="1" get="inline" set="null" line="130" static="1"><f a="ax:ay">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></dotSame>
	</class>
	<class path="vision.tools.ImageTools" params="" file="src/vision/tools/ImageTools.hx">
		<defaultResizeAlgorithm public="1" expr="BilinearInterpolation" line="43" static="1">
			<x path="vision.ds.ImageResizeAlgorithm"/>
			<meta><m n=":value"><e>BilinearInterpolation</e></m></meta>
			<haxe_doc>* The default algorithm to use when resizing an image by "brute force" (setting its `width`/`height` when `vision_allow_resize` is defined)</haxe_doc>
		</defaultResizeAlgorithm>
		<loadFromFile public="1" set="method" line="63" static="1">
			<f a="?image:path:?onComplete">
				<x path="vision.ds.Image"/>
				<c path="String"/>
				<f a="">
					<x path="vision.ds.Image"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Gets an image from a file. 

		the given path can be an absolute path or a relative path. a URL is valid too.  

		**Note: On Non-`js` targets, this function requires the `format` library, and only supports PNG.**

		To install:  
		  
		`haxelib install format`

		@param image optional, if you don't want to create a new image instance (usage: `image.loadFromFile("path/to/image.png")`)
		@param path the path to the image file. On `js`, it can only be a relative path/a URL

		@returns the image object.
		@throws LibraryRequired Thrown when used on `sys` targets without installing & including `format`
		@throws ImageLoadingFailed Thrown when trying to load a corrupted file.]]></haxe_doc>
		</loadFromFile>
		<saveToFile public="1" set="method" line="171" static="1">
			<f a="image:pathWithFileName:?saveFormat" v="::PNG">
				<x path="vision.ds.Image"/>
				<c path="String"/>
				<x path="vision.ds.ImageFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ saveFormat : PNG }</e></m></meta>
			<haxe_doc><![CDATA[Saves an image to a path.

		**Note: this function requires the `format` library, and only supports PNG.**

		To install:

		`haxelib install format`


		@param image The image to save
		@param pathWithFileName The path to save to
		@param saveFormat An image format.
		@throws LibraryRequired Thrown when used without installing & including `format`
		@throws ImageSavingFailed Thrown when trying to save a corrupted image.]]></haxe_doc>
		</saveToFile>
		<addToScreen public="1" set="method" line="239" static="1">
			<f a="image:x:y:?units">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="Int"/>
				<a>
					<zIndex>
						<x path="Null"><c path="String"/></x>
						<meta><m n=":optional"/></meta>
					</zIndex>
					<yUnits>
						<x path="Null"><c path="String"/></x>
						<meta><m n=":optional"/></meta>
					</yUnits>
					<xUnits>
						<x path="Null"><c path="String"/></x>
						<meta><m n=":optional"/></meta>
					</xUnits>
				</a>
				<x path="vision.ds.Image"/>
			</f>
			<haxe_doc>Adds an `Image` to the screen.

		**Currently, this function only works on the web**, and
		it uses an absolutely positioned canvas element.

		#### Notice - JS Only

		if you want to use this function to add an image to a web page,
		and also want to use different units than pixels, you can use the `units` parameter.

			addToScreen(image, 50, 20, {xUnits: "vw", yUnits: "vh", zIndex: 1});

		@param image the image to add.
		@param x the x position of the image.
		@param y the y position of the image.

		@returns the image object.</haxe_doc>
		</addToScreen>
		<getNeighborsOfPixel public="1" get="inline" set="null" line="284" static="1">
			<f a="image:x:y:kernelSize">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="vision.ds.Array2D"><x path="vision.ds.Color"/></c>
			</f>
			<haxe_doc><![CDATA[Gets an `Array2D` of all neighboring pixels at `x, y`.
		
		The pixels are added to the Array2D from left to right, top to bottom.
		
		@param image The image to get the neighbors in.
		@param x The x position of the pixel.
		@param y The y position of the pixel.
		@param kernelSize the width & height of the kernel.
		@return an `Array2D` of colors]]></haxe_doc>
		</getNeighborsOfPixel>
		<getNeighborsOfPixelIter public="1" get="inline" set="null" line="305" static="1">
			<f a="image:x:y:kernelSize:?circular" v="::::false">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<t path="Iterator"><x path="vision.ds.Color"/></t>
			</f>
			<meta><m n=":value"><e>{ circular : false }</e></m></meta>
			<haxe_doc><![CDATA[Gets an iterator over all neighboring pixels at `x, y`.

		The pixels are iterated on from left to right, top to bottom.

		@param image The image to get the neighbors in.
		@param x The x position of the pixel.
		@param y The y position of the pixel.
		@param kernelSize the width & height of the kernel.
		@param circular Whether or not the kernel is a circle, or a square. to get more "accurate" neighbors, set this to `true`. `false` by default.
		@return an `Array2D` of colors]]></haxe_doc>
		</getNeighborsOfPixelIter>
		<grayscalePixel public="1" get="inline" set="null" line="309" static="1"><f a="pixel">
	<x path="vision.ds.Color"/>
	<x path="vision.ds.Color"/>
</f></grayscalePixel>
		<haxe_doc>A class used to provide extra utilities to the `Image` class.

	Those properties are not included because they are not needed for the basic functionality of that object.

	to use those utilities, use this class at the top of you file:

		using vision.tools.ImageTools;</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>vision.ds.Image</e></m>
		</meta>
	</class>
	<class path="vision.tools._ImageTools.NeighborsIterator" params="" file="src/vision/tools/ImageTools.hx" private="1" module="vision.tools.ImageTools">
		<roundedDown><x path="Int"/></roundedDown>
		<image><x path="vision.ds.Image"/></image>
		<x><x path="Int"/></x>
		<y><x path="Int"/></y>
		<X><x path="Int"/></X>
		<Y><x path="Int"/></Y>
		<circular><x path="Bool"/></circular>
		<next public="1" get="inline" set="null" line="585"><f a=""><x path="vision.ds.Color"/></f></next>
		<hasNext public="1" get="inline" set="null" line="596"><f a=""><x path="Bool"/></f></hasNext>
		<new public="1" get="inline" set="null" line="575">
			<f a="image:x:y:kernelSize:?circular" v="::::false">
				<x path="vision.ds.Image"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ circular : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="vision.tools.MathTools" params="" file="src/vision/tools/MathTools.hx">
		<PI public="1" get="accessor" set="null" static="1"><x path="Float"/></PI>
		<PI_OVER_2 public="1" get="accessor" set="null" static="1"><x path="Float"/></PI_OVER_2>
		<NEGATIVE_INFINITY public="1" get="accessor" set="null" static="1"><x path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" get="accessor" set="null" static="1"><x path="Float"/></POSITIVE_INFINITY>
		<NaN public="1" get="accessor" set="null" static="1"><x path="Float"/></NaN>
		<distanceFromRayToPoint2D public="1" get="inline" set="null" line="38" static="1"><f a="ray:point">
	<c path="vision.ds.Ray2D"/>
	<c path="vision.ds.Point2D"/>
	<x path="Float"/>
</f></distanceFromRayToPoint2D>
		<intersectionBetweenRay2Ds public="1" get="inline" set="null" line="42" static="1"><f a="ray:ray2">
	<c path="vision.ds.Ray2D"/>
	<c path="vision.ds.Ray2D"/>
	<c path="vision.ds.Point2D"/>
</f></intersectionBetweenRay2Ds>
		<distanceBetweenRays2D public="1" get="inline" set="null" line="71" static="1"><f a="ray:ray2">
	<c path="vision.ds.Ray2D"/>
	<c path="vision.ds.Ray2D"/>
	<x path="Float"/>
</f></distanceBetweenRays2D>
		<findPointAtDistanceUsingX public="1" get="inline" set="null" line="91" static="1">
			<f a="ray:startXPos:distance:?goPositive" v=":::true">
				<c path="vision.ds.Ray2D"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<meta><m n=":value"><e>{ goPositive : true }</e></m></meta>
			<haxe_doc>* Gets the point on `ray` , which is `distance` points away
	 * from `startXPos`.
	 * 
	 * In order to avoid returning two points (since
	 * any point on the ray has 2 points with the exact same distance from it),
	 * you have the `goPositive` value.
	 * 
	 * 
	 * @param startXPos The `x` position to start from.
	 * @param distance The distance from `start` to the resulting point.
	 * @param goPositive Whether or not the resulting point is in front/behind `start`. `true` means in front, `false` means behind.</haxe_doc>
		</findPointAtDistanceUsingX>
		<findPointAtDistanceUsingY public="1" get="inline" set="null" line="115" static="1">
			<f a="ray:startYPos:distance:?goPositive" v=":::true">
				<c path="vision.ds.Ray2D"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<meta><m n=":value"><e>{ goPositive : true }</e></m></meta>
			<haxe_doc>* Gets the point on `ray` , which is `distance` points away
	 * from `startYPos`.
	 * 
	 * In order to avoid returning two points (since
	 * any point on the ray has 2 points with the exact same distance from it),
	 * you have the `goPositive` value.
	 * 
	 * 
	 * @param startYPos The `y` position to start from.
	 * @param distance The distance from `start` to the resulting point.
	 * @param goPositive Whether or not the resulting point is in front/behind `start`. `true` means in front, `false` means behind.</haxe_doc>
		</findPointAtDistanceUsingY>
		<distanceFromLineToPoint2D public="1" get="inline" set="null" line="130" static="1"><f a="line:point">
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Point2D"/>
	<x path="Float"/>
</f></distanceFromLineToPoint2D>
		<distanceBetweenLines2D public="1" get="inline" set="null" line="140" static="1"><f a="line1:line2">
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Line2D"/>
	<x path="Float"/>
</f></distanceBetweenLines2D>
		<radiansFromLineToPoint2D public="1" get="inline" set="null" line="153" static="1"><f a="line:point">
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Point2D"/>
	<x path="Float"/>
</f></radiansFromLineToPoint2D>
		<intersectionBetweenLine2Ds public="1" get="inline" set="null" line="157" static="1"><f a="line1:line2">
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Point2D"/>
</f></intersectionBetweenLine2Ds>
		<mirrorInsideRectangle public="1" get="inline" set="null" line="183" static="1"><f a="line:rect">
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Rectangle"/>
	<c path="vision.ds.Line2D"/>
</f></mirrorInsideRectangle>
		<flipInsideRectangle public="1" get="inline" set="null" line="192" static="1"><f a="line:rect">
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Rectangle"/>
	<c path="vision.ds.Line2D"/>
</f></flipInsideRectangle>
		<invertInsideRectangle public="1" get="inline" set="null" line="201" static="1"><f a="line:rect">
	<c path="vision.ds.Line2D"/>
	<c path="vision.ds.Rectangle"/>
	<c path="vision.ds.Line2D"/>
</f></invertInsideRectangle>
		<distanceFromPointToRay2D public="1" get="inline" set="null" line="218" static="1">
			<f a="point:ray">
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Ray2D"/>
				<x path="Float"/>
			</f>
			<overloads><distanceFromPointToRay2D public="1" get="inline" set="null" line="314"><f a="point:ray">
	<x path="vision.ds.IntPoint2D"/>
	<c path="vision.ds.Ray2D"/>
	<x path="Float"/>
</f></distanceFromPointToRay2D></overloads>
		</distanceFromPointToRay2D>
		<distanceFromPointToLine2D public="1" get="inline" set="null" line="230" static="1">
			<f a="point:line">
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Line2D"/>
				<x path="Float"/>
			</f>
			<overloads><distanceFromPointToLine2D public="1" get="inline" set="null" line="326"><f a="point:line">
	<x path="vision.ds.IntPoint2D"/>
	<c path="vision.ds.Line2D"/>
	<x path="Float"/>
</f></distanceFromPointToLine2D></overloads>
		</distanceFromPointToLine2D>
		<radiansFromPointToLine2D public="1" get="inline" set="null" line="249" static="1">
			<f a="point:line">
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Line2D"/>
				<x path="Float"/>
			</f>
			<overloads><radiansFromPointToLine2D public="1" get="inline" set="null" line="345"><f a="point:line">
	<x path="vision.ds.IntPoint2D"/>
	<c path="vision.ds.Line2D"/>
	<x path="Float"/>
</f></radiansFromPointToLine2D></overloads>
		</radiansFromPointToLine2D>
		<radiansFromPointToPoint2D public="1" get="inline" set="null" line="255" static="1">
			<f a="point1:point2">
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Point2D"/>
				<x path="Float"/>
			</f>
			<overloads>
				<radiansFromPointToPoint2D public="1" get="inline" set="null" line="371"><f a="point1:point2">
	<x path="vision.ds.IntPoint2D"/>
	<c path="vision.ds.Point2D"/>
	<x path="Float"/>
</f></radiansFromPointToPoint2D>
				<radiansFromPointToPoint2D public="1" get="inline" set="null" line="351"><f a="point1:point2">
	<x path="vision.ds.IntPoint2D"/>
	<x path="vision.ds.IntPoint2D"/>
	<x path="Float"/>
</f></radiansFromPointToPoint2D>
				<radiansFromPointToPoint2D public="1" get="inline" set="null" line="275"><f a="point1:point2">
	<c path="vision.ds.Point2D"/>
	<x path="vision.ds.IntPoint2D"/>
	<x path="Float"/>
</f></radiansFromPointToPoint2D>
			</overloads>
		</radiansFromPointToPoint2D>
		<degreesFromPointToPoint2D public="1" get="inline" set="null" line="261" static="1">
			<f a="point1:point2">
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Point2D"/>
				<x path="Float"/>
			</f>
			<overloads>
				<degreesFromPointToPoint2D public="1" get="inline" set="null" line="377"><f a="point1:point2">
	<x path="vision.ds.IntPoint2D"/>
	<c path="vision.ds.Point2D"/>
	<x path="Float"/>
</f></degreesFromPointToPoint2D>
				<degreesFromPointToPoint2D public="1" get="inline" set="null" line="357"><f a="point1:point2">
	<x path="vision.ds.IntPoint2D"/>
	<x path="vision.ds.IntPoint2D"/>
	<x path="Float"/>
</f></degreesFromPointToPoint2D>
				<degreesFromPointToPoint2D public="1" get="inline" set="null" line="281"><f a="point1:point2">
	<c path="vision.ds.Point2D"/>
	<x path="vision.ds.IntPoint2D"/>
	<x path="Float"/>
</f></degreesFromPointToPoint2D>
			</overloads>
		</degreesFromPointToPoint2D>
		<slopeFromPointToPoint2D public="1" get="inline" set="null" line="265" static="1">
			<f a="point1:point2">
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Point2D"/>
				<x path="Float"/>
			</f>
			<overloads>
				<slopeFromPointToPoint2D public="1" get="inline" set="null" line="381"><f a="point1:point2">
	<x path="vision.ds.IntPoint2D"/>
	<c path="vision.ds.Point2D"/>
	<x path="Float"/>
</f></slopeFromPointToPoint2D>
				<slopeFromPointToPoint2D public="1" get="inline" set="null" line="361"><f a="point1:point2">
	<x path="vision.ds.IntPoint2D"/>
	<x path="vision.ds.IntPoint2D"/>
	<x path="Float"/>
</f></slopeFromPointToPoint2D>
				<slopeFromPointToPoint2D public="1" get="inline" set="null" line="285"><f a="point1:point2">
	<c path="vision.ds.Point2D"/>
	<x path="vision.ds.IntPoint2D"/>
	<x path="Float"/>
</f></slopeFromPointToPoint2D>
			</overloads>
		</slopeFromPointToPoint2D>
		<distanceBetweenPoints public="1" get="inline" set="null" line="269" static="1">
			<f a="point1:point2">
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Point2D"/>
				<x path="Float"/>
			</f>
			<overloads>
				<distanceBetweenPoints public="1" get="inline" set="null" line="410"><f a="point1:point2">
	<c path="vision.ds.Point3D"/>
	<c path="vision.ds.Point3D"/>
	<x path="Float"/>
</f></distanceBetweenPoints>
				<distanceBetweenPoints public="1" get="inline" set="null" line="385"><f a="point1:point2">
	<x path="vision.ds.IntPoint2D"/>
	<c path="vision.ds.Point2D"/>
	<x path="Float"/>
</f></distanceBetweenPoints>
				<distanceBetweenPoints public="1" get="inline" set="null" line="365"><f a="point1:point2">
	<x path="vision.ds.IntPoint2D"/>
	<x path="vision.ds.IntPoint2D"/>
	<x path="Float"/>
</f></distanceBetweenPoints>
				<distanceBetweenPoints public="1" get="inline" set="null" line="289"><f a="point1:point2">
	<c path="vision.ds.Point2D"/>
	<x path="vision.ds.IntPoint2D"/>
	<x path="Float"/>
</f></distanceBetweenPoints>
			</overloads>
		</distanceBetweenPoints>
		<getClosestPointOnRay2D public="1" get="inline" set="null" line="295" static="1">
			<f a="point:ray">
				<c path="vision.ds.Point2D"/>
				<c path="vision.ds.Ray2D"/>
				<c path="vision.ds.Point2D"/>
			</f>
			<overloads><getClosestPointOnRay2D public="1" get="inline" set="null" line="391"><f a="point:ray">
	<x path="vision.ds.IntPoint2D"/>
	<c path="vision.ds.Ray2D"/>
	<c path="vision.ds.Point2D"/>
</f></getClosestPointOnRay2D></overloads>
		</getClosestPointOnRay2D>
		<clamp public="1" get="inline" set="null" line="421" static="1"><f a="value:mi:ma">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></clamp>
		<isBetweenRanges public="1" set="method" line="425" static="1"><f a="value:ranges">
	<x path="Float"/>
	<x path="haxe.Rest"><a>
	<start><x path="Float"/></start>
	<end><x path="Float"/></end>
</a></x>
	<x path="Bool"/>
</f></isBetweenRanges>
		<isBetweenRange public="1" get="inline" set="null" line="440" static="1"><f a="value:min:max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isBetweenRange>
		<wrapInt public="1" get="inline" set="null" line="448" static="1">
			<f a="value:min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Ensures that the value is between min and max, by wrapping the value around
		when it is outside of the range.</haxe_doc>
		</wrapInt>
		<wrapFloat public="1" get="inline" set="null" line="461" static="1">
			<f a="value:min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Ensures that the value is between min and max, by wrapping the value around
		when it is outside of the range.</haxe_doc>
		</wrapFloat>
		<boundInt public="1" set="method" line="473" static="1">
			<f a="value:min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Ensures that the value is between min and max, by bounding the value when it is outside of the range.</haxe_doc>
		</boundInt>
		<boundFloat public="1" set="method" line="482" static="1">
			<f a="value:min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Ensures that the value is between min and max, by bounding the value when it is outside of the range.</haxe_doc>
		</boundFloat>
		<isPositive public="1" params="T" get="inline" set="null" line="490" static="1">
			<f a="number">
				<c path="isPositive.T"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>Returns `true` if `number` is positive, `false` if negative</haxe_doc>
		</isPositive>
		<gamma public="1" set="method" line="494" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></gamma>
		<factorial public="1" set="method" line="512" static="1"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></factorial>
		<slopeToDegrees public="1" get="inline" set="null" line="521" static="1"><f a="slope">
	<x path="Float"/>
	<x path="Float"/>
</f></slopeToDegrees>
		<slopeToRadians public="1" get="inline" set="null" line="525" static="1"><f a="slope">
	<x path="Float"/>
	<x path="Float"/>
</f></slopeToRadians>
		<degreesToSlope public="1" get="inline" set="null" line="529" static="1"><f a="degrees">
	<x path="Float"/>
	<x path="Float"/>
</f></degreesToSlope>
		<degreesToRadians public="1" get="inline" set="null" line="533" static="1"><f a="degrees">
	<x path="Float"/>
	<x path="Float"/>
</f></degreesToRadians>
		<radiansToDegrees public="1" get="inline" set="null" line="537" static="1"><f a="radians">
	<x path="Float"/>
	<x path="Float"/>
</f></radiansToDegrees>
		<radiansToSlope public="1" get="inline" set="null" line="541" static="1"><f a="radians">
	<x path="Float"/>
	<x path="Float"/>
</f></radiansToSlope>
		<cotan public="1" get="inline" set="null" line="549" static="1"><f a="radians">
	<x path="Float"/>
	<x path="Float"/>
</f></cotan>
		<cosec public="1" get="inline" set="null" line="553" static="1"><f a="radians">
	<x path="Float"/>
	<x path="Float"/>
</f></cosec>
		<sec public="1" get="inline" set="null" line="557" static="1"><f a="radians">
	<x path="Float"/>
	<x path="Float"/>
</f></sec>
		<sind public="1" get="inline" set="null" line="561" static="1"><f a="degrees">
	<x path="Float"/>
	<x path="Float"/>
</f></sind>
		<cosd public="1" get="inline" set="null" line="565" static="1"><f a="degrees">
	<x path="Float"/>
	<x path="Float"/>
</f></cosd>
		<tand public="1" get="inline" set="null" line="569" static="1"><f a="degrees">
	<x path="Float"/>
	<x path="Float"/>
</f></tand>
		<cotand public="1" get="inline" set="null" line="573" static="1"><f a="degrees">
	<x path="Float"/>
	<x path="Float"/>
</f></cotand>
		<cosecd public="1" get="inline" set="null" line="577" static="1"><f a="degrees">
	<x path="Float"/>
	<x path="Float"/>
</f></cosecd>
		<secd public="1" get="inline" set="null" line="581" static="1"><f a="degrees">
	<x path="Float"/>
	<x path="Float"/>
</f></secd>
		<truncate public="1" get="inline" set="null" line="589" static="1"><f a="num:numbersAfterDecimal">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></truncate>
		<cropDecimal public="1" get="inline" set="null" line="594" static="1"><f a="number">
	<x path="Float"/>
	<x path="Int"/>
</f></cropDecimal>
		<flatten public="1" params="T" get="inline" set="null" line="608" static="1">
			<f a="array">
				<c path="Array"><c path="Array"><c path="flatten.T"/></c></c>
				<c path="Array"><c path="flatten.T"/></c>
			</f>
			<haxe_doc><![CDATA[* Takes a 2D array and flattens it to a regular, 1D array.
	 * @param array
	 * @return Array<T>]]></haxe_doc>
		</flatten>
		<raise public="1" params="T" get="inline" set="null" line="621" static="1">
			<f a="array:delimiter">
				<c path="Array"><c path="raise.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="Array"><c path="raise.T"/></c></c>
			</f>
			<haxe_doc><![CDATA[* Takes a 1D array and turns it into a 2D array, while splitting into arrays every `delimiter` indexes
	 * @param array
	 * @param delimiter
	 * @return Array<T>]]></haxe_doc>
		</raise>
		<minFloat public="1" get="inline" set="null" line="630" static="1">
			<f a="values">
				<x path="haxe.Rest"><x path="Float"/></x>
				<x path="Float"/>
			</f>
			<overloads><minFloat public="1" get="inline" set="null" line="639"><f a="values">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
</f></minFloat></overloads>
		</minFloat>
		<min public="1" get="inline" set="null" line="648" static="1">
			<f a="values">
				<x path="haxe.Rest"><x path="Int"/></x>
				<x path="Int"/>
			</f>
			<overloads><min public="1" get="inline" set="null" line="657"><f a="values">
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
</f></min></overloads>
		</min>
		<maxFloat public="1" get="inline" set="null" line="666" static="1">
			<f a="values">
				<x path="haxe.Rest"><x path="Float"/></x>
				<x path="Float"/>
			</f>
			<overloads><maxFloat public="1" get="inline" set="null" line="675"><f a="values">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
</f></maxFloat></overloads>
		</maxFloat>
		<max public="1" get="inline" set="null" line="684" static="1">
			<f a="values">
				<x path="haxe.Rest"><x path="Int"/></x>
				<x path="Int"/>
			</f>
			<overloads><max public="1" get="inline" set="null" line="693"><f a="values">
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
</f></max></overloads>
		</max>
		<average public="1" get="inline" set="null" line="702" static="1">
			<f a="values">
				<x path="haxe.Rest"><x path="Float"/></x>
				<x path="Float"/>
			</f>
			<overloads><average public="1" params="T:Uint:Int64:Float" get="inline" set="null" line="710"><f a="values">
	<c path="Array"><c path="average.T"/></c>
	<x path="Float"/>
</f></average></overloads>
		</average>
		<median public="1" params="T:UInt:Int64" get="inline" set="null" line="721" static="1">
			<f a="values">
				<x path="haxe.Rest"><c path="median.T"/></x>
				<c path="median.T"/>
			</f>
			<haxe_doc>* Gets the median of the given values. For large arrays, Radix sort is used to boost performance (1000 elements or above)</haxe_doc>
			<overloads>
				<median public="1" get="inline" set="null" line="754">
					<f a="values">
						<c path="Array"><x path="Float"/></c>
						<x path="Float"/>
					</f>
					<haxe_doc>* Gets the median of the given values.</haxe_doc>
				</median>
				<median public="1" params="T:UInt:Int64" get="inline" set="null" line="742">
					<f a="values">
						<c path="Array"><c path="median.T"/></c>
						<c path="median.T"/>
					</f>
					<haxe_doc>* Gets the median of the given values. For large arrays, Radix sort is used to boost performance (5000 elements or above)</haxe_doc>
				</median>
				<median public="1" get="inline" set="null" line="733">
					<f a="values">
						<x path="haxe.Rest"><x path="Float"/></x>
						<x path="Float"/>
					</f>
					<haxe_doc>* Gets the median of the given values.</haxe_doc>
				</median>
			</overloads>
		</median>
		<isInt public="1" get="inline" set="null" line="760" static="1"><f a="v">
	<x path="Float"/>
	<x path="Bool"/>
</f></isInt>
		<get_NEGATIVE_INFINITY get="inline" set="null" line="774" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_NEGATIVE_INFINITY>
		<get_POSITIVE_INFINITY get="inline" set="null" line="775" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_POSITIVE_INFINITY>
		<get_NaN get="inline" set="null" line="776" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_NaN>
		<get_PI_OVER_2 get="inline" set="null" line="777" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_PI_OVER_2>
		<get_PI get="inline" set="null" line="778" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_PI>
		<abs public="1" get="inline" set="null" line="781" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></abs>
		<acos public="1" get="inline" set="null" line="784" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></acos>
		<asin public="1" get="inline" set="null" line="787" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></asin>
		<atan public="1" get="inline" set="null" line="790" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></atan>
		<atan2 public="1" get="inline" set="null" line="793" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<ceil public="1" get="inline" set="null" line="796" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></ceil>
		<cos public="1" get="inline" set="null" line="799" static="1"><f a="radians">
	<x path="Float"/>
	<x path="Float"/>
</f></cos>
		<exp public="1" get="inline" set="null" line="802" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></exp>
		<floor public="1" get="inline" set="null" line="805" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></floor>
		<log public="1" get="inline" set="null" line="808" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></log>
		<pow public="1" get="inline" set="null" line="811" static="1"><f a="v:exp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<random public="1" get="inline" set="null" line="814" static="1"><f a=""><x path="Float"/></f></random>
		<round public="1" get="inline" set="null" line="817" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></round>
		<sin public="1" get="inline" set="null" line="820" static="1"><f a="radians">
	<x path="Float"/>
	<x path="Float"/>
</f></sin>
		<sqrt public="1" get="inline" set="null" line="823" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></sqrt>
		<tan public="1" get="inline" set="null" line="826" static="1"><f a="radians">
	<x path="Float"/>
	<x path="Float"/>
</f></tan>
		<ffloor public="1" get="inline" set="null" line="829" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" get="inline" set="null" line="832" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<fround public="1" get="inline" set="null" line="835" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<isFinite public="1" get="inline" set="null" line="838" static="1"><f a="f">
	<x path="Float"/>
	<x path="Bool"/>
</f></isFinite>
		<isNaN public="1" get="inline" set="null" line="841" static="1"><f a="f">
	<x path="Float"/>
	<x path="Bool"/>
</f></isNaN>
		<parseFloat public="1" set="method" line="853" static="1"><f a="s">
	<c path="String"/>
	<x path="Float"/>
</f></parseFloat>
		<parseInt public="1" set="method" line="856" static="1"><f a="s">
	<c path="String"/>
	<x path="Float"/>
</f></parseInt>
		<parseBool public="1" set="method" line="858" static="1"><f a="s">
	<c path="String"/>
	<x path="Bool"/>
</f></parseBool>
		<haxe_doc>A class consisting of a **b u n c h** of static methods for manipulating values,
	calculating distances, intersections, etc.

	This class is fully compatible with haxe's `Math` class. That means you don't have to use
	both at the same time.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="vision.tools.Number" params="" file="src/vision/tools/MathTools.hx" module="vision.tools.MathTools">
		<from>
			<icast><x path="Float"/></icast>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><x path="Float"/></icast>
			<icast><x path="Int"/></icast>
			<icast><x path="UInt"/></icast>
		</to>
		<impl><class path="vision.tools._MathTools.Number_Impl_" params="" file="src/vision/tools/MathTools.hx" private="1" module="vision.tools.MathTools" extern="1" final="1"/></impl>
	</abstract>
	<class path="vision.tools._MathTools.Number_Impl_" params="" file="src/vision/tools/MathTools.hx" private="1" module="vision.tools.MathTools" extern="1" final="1"/>
</haxe>